'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

exports.default = evaluateInner;

var _hyphenateStyleName = require('fbjs/lib/hyphenateStyleName');

var _hyphenateStyleName2 = _interopRequireDefault(_hyphenateStyleName);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The below code is inspired by the css function in styled components
 * https://github.com/styled-components/styled-components/blob/master/src/constructors/css.js
 */
function evaluateInner(styles) {
  for (var _len = arguments.length, interpolations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    interpolations[_key - 1] = arguments[_key];
  }

  return flatten(interleave(styles, interpolations)).join('');
}


function interleave(strings, interpolations) {
  var result = [strings[0]];
  for (var i = 0; i < interpolations.length; i++) {
    result.push(interpolations[i], strings[i + 1]);
  }

  return result;
}

function flatten(chunks) {
  var executionContext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { theme: { __ATLASKIT_THEME__: { mode: 'light' } } };

  return chunks.reduce(function (ruleSet, chunk) {
    /* Remove falsey values */
    if (chunk === undefined || chunk === null || chunk === false || chunk === '') {
      return ruleSet;
    }

    /* Flatten ruleSet */
    if (Array.isArray(chunk)) {
      ruleSet.push.apply(ruleSet, (0, _toConsumableArray3.default)(flatten(chunk, executionContext)));
      return ruleSet;
    }

    /* Either execute or defer the function */
    if (typeof chunk === 'function') {
      if (executionContext) {
        var nextChunk = chunk(executionContext);
        ruleSet.push.apply(ruleSet, (0, _toConsumableArray3.default)(flatten([nextChunk], executionContext)));
      } else ruleSet.push(chunk);

      return ruleSet;
    }
    //$FlowFixMe
    ruleSet.push(isPlainObject(chunk) ? objToCss(chunk) : chunk.toString());

    return ruleSet;
  }, []);
}

function isPlainObject(x) {
  return (typeof x === 'undefined' ? 'undefined' : (0, _typeof3.default)(x)) === 'object' && x.constructor === Object;
}

function objToCss(obj, prevKey) {
  var css = (0, _keys2.default)(obj).filter(function (key) {
    var chunk = obj[key];
    return chunk !== undefined && chunk !== null && chunk !== false && chunk !== '';
  }).map(function (key) {
    if (isPlainObject(obj[key])) return objToCss(obj[key], key);
    return (0, _hyphenateStyleName2.default)(key) + ': ' + obj[key] + ';';
  }).join(' ');
  return prevKey ? prevKey + ' {\n    ' + css + '\n  }' : css;
}