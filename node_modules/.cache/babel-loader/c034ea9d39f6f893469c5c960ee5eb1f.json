{"ast":null,"code":"/*\n Highmaps JS v7.2.1 (2019-10-31)\n\n (c) 2011-2018 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n(function (P, K) {\n  \"object\" === typeof module && module.exports ? (K[\"default\"] = K, module.exports = P.document ? K(P) : K) : \"function\" === typeof define && define.amd ? define(\"highcharts/highmaps\", function () {\n    return K(P);\n  }) : (P.Highcharts && P.Highcharts.error(16, !0), P.Highcharts = K(P));\n})(\"undefined\" !== typeof window ? window : this, function (P) {\n  function K(c, f, H, D) {\n    c.hasOwnProperty(f) || (c[f] = D.apply(null, H));\n  }\n\n  var C = {};\n  K(C, \"parts/Globals.js\", [], function () {\n    var c = \"undefined\" !== typeof P ? P : \"undefined\" !== typeof window ? window : {},\n        f = c.document,\n        H = c.navigator && c.navigator.userAgent || \"\",\n        D = f && f.createElementNS && !!f.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\").createSVGRect,\n        A = /(edge|msie|trident)/i.test(H) && !c.opera,\n        E = -1 !== H.indexOf(\"Firefox\"),\n        p = -1 !== H.indexOf(\"Chrome\"),\n        y = E && 4 > parseInt(H.split(\"Firefox/\")[1], 10);\n    return {\n      product: \"Highcharts\",\n      version: \"7.2.1\",\n      deg2rad: 2 * Math.PI / 360,\n      doc: f,\n      hasBidiBug: y,\n      hasTouch: !!c.TouchEvent,\n      isMS: A,\n      isWebKit: -1 !== H.indexOf(\"AppleWebKit\"),\n      isFirefox: E,\n      isChrome: p,\n      isSafari: !p && -1 !== H.indexOf(\"Safari\"),\n      isTouchDevice: /(Mobile|Android|Windows Phone)/.test(H),\n      SVG_NS: \"http://www.w3.org/2000/svg\",\n      chartCount: 0,\n      seriesTypes: {},\n      symbolSizes: {},\n      svg: D,\n      win: c,\n      marginNames: [\"plotTop\", \"marginRight\", \"marginBottom\", \"plotLeft\"],\n      noop: function noop() {},\n      charts: [],\n      dateFormats: {}\n    };\n  });\n  K(C, \"parts/Utilities.js\", [C[\"parts/Globals.js\"]], function (c) {\n    function f(b, d) {\n      return parseInt(b, d || 10);\n    }\n\n    function H(b) {\n      return \"string\" === typeof b;\n    }\n\n    function D(b) {\n      b = Object.prototype.toString.call(b);\n      return \"[object Array]\" === b || \"[object Array Iterator]\" === b;\n    }\n\n    function A(b, d) {\n      return !!b && \"object\" === typeof b && (!d || !D(b));\n    }\n\n    function E(b) {\n      return A(b) && \"number\" === typeof b.nodeType;\n    }\n\n    function p(b) {\n      var d = b && b.constructor;\n      return !(!A(b, !0) || E(b) || !d || !d.name || \"Object\" === d.name);\n    }\n\n    function y(b) {\n      return \"number\" === typeof b && !isNaN(b) && Infinity > b && -Infinity < b;\n    }\n\n    function G(b) {\n      return \"undefined\" !== typeof b && null !== b;\n    }\n\n    function v(b, d, a) {\n      var e;\n      H(d) ? G(a) ? b.setAttribute(d, a) : b && b.getAttribute && ((e = b.getAttribute(d)) || \"class\" !== d || (e = b.getAttribute(d + \"Name\"))) : m(d, function (a, d) {\n        b.setAttribute(d, a);\n      });\n      return e;\n    }\n\n    function q(b, d) {\n      var a;\n      b || (b = {});\n\n      for (a in d) {\n        b[a] = d[a];\n      }\n\n      return b;\n    }\n\n    function k() {\n      for (var b = arguments, d = b.length, a = 0; a < d; a++) {\n        var e = b[a];\n        if (\"undefined\" !== typeof e && null !== e) return e;\n      }\n    }\n\n    function m(b, d, a) {\n      for (var e in b) {\n        Object.hasOwnProperty.call(b, e) && d.call(a || b[e], b[e], e, b);\n      }\n    }\n\n    c.timers = [];\n    var w = c.charts,\n        g = c.doc,\n        e = c.win;\n\n    c.error = function (b, d, a, h) {\n      var n = y(b),\n          g = n ? \"Highcharts error #\" + b + \": www.highcharts.com/errors/\" + b + \"/\" : b.toString(),\n          r = function r() {\n        if (d) throw Error(g);\n        e.console && console.log(g);\n      };\n\n      if (\"undefined\" !== typeof h) {\n        var x = \"\";\n        n && (g += \"?\");\n        c.objectEach(h, function (a, b) {\n          x += \"\\n\" + b + \": \" + a;\n          n && (g += encodeURI(b) + \"=\" + encodeURI(a));\n        });\n        g += x;\n      }\n\n      a ? c.fireEvent(a, \"displayError\", {\n        code: b,\n        message: g,\n        params: h\n      }, r) : r();\n    };\n\n    c.Fx = function (b, d, a) {\n      this.options = d;\n      this.elem = b;\n      this.prop = a;\n    };\n\n    c.Fx.prototype = {\n      dSetter: function dSetter() {\n        var b = this.paths[0],\n            d = this.paths[1],\n            a = [],\n            e = this.now,\n            n = b.length;\n        if (1 === e) a = this.toD;else if (n === d.length && 1 > e) for (; n--;) {\n          var c = parseFloat(b[n]);\n          a[n] = isNaN(c) || \"A\" === d[n - 4] || \"A\" === d[n - 5] ? d[n] : e * parseFloat(\"\" + (d[n] - c)) + c;\n        } else a = d;\n        this.elem.attr(\"d\", a, null, !0);\n      },\n      update: function update() {\n        var b = this.elem,\n            d = this.prop,\n            a = this.now,\n            e = this.options.step;\n        if (this[d + \"Setter\"]) this[d + \"Setter\"]();else b.attr ? b.element && b.attr(d, a, null, !0) : b.style[d] = a + this.unit;\n        e && e.call(b, a, this);\n      },\n      run: function run(b, d, a) {\n        var h = this,\n            n = h.options,\n            g = function g(a) {\n          return g.stopped ? !1 : h.step(a);\n        },\n            r = e.requestAnimationFrame || function (a) {\n          setTimeout(a, 13);\n        },\n            x = function x() {\n          for (var a = 0; a < c.timers.length; a++) {\n            c.timers[a]() || c.timers.splice(a--, 1);\n          }\n\n          c.timers.length && r(x);\n        };\n\n        b !== d || this.elem[\"forceAnimate:\" + this.prop] ? (this.startTime = +new Date(), this.start = b, this.end = d, this.unit = a, this.now = this.start, this.pos = 0, g.elem = this.elem, g.prop = this.prop, g() && 1 === c.timers.push(g) && r(x)) : (delete n.curAnim[this.prop], n.complete && 0 === Object.keys(n.curAnim).length && n.complete.call(this.elem));\n      },\n      step: function step(b) {\n        var d = +new Date(),\n            a = this.options,\n            e = this.elem,\n            n = a.complete,\n            c = a.duration,\n            r = a.curAnim;\n        if (e.attr && !e.element) b = !1;else if (b || d >= c + this.startTime) {\n          this.now = this.end;\n          this.pos = 1;\n          this.update();\n          var g = r[this.prop] = !0;\n          m(r, function (a) {\n            !0 !== a && (g = !1);\n          });\n          g && n && n.call(e);\n          b = !1;\n        } else this.pos = a.easing((d - this.startTime) / c), this.now = this.start + (this.end - this.start) * this.pos, this.update(), b = !0;\n        return b;\n      },\n      initPath: function initPath(b, d, a) {\n        function e(a) {\n          for (k = a.length; k--;) {\n            var b = \"M\" === a[k] || \"L\" === a[k];\n            var d = /[a-zA-Z]/.test(a[k + 3]);\n            b && d && a.splice(k + 1, 0, a[k + 1], a[k + 2], a[k + 1], a[k + 2]);\n          }\n        }\n\n        function n(a, b) {\n          for (; a.length < m;) {\n            a[0] = b[m - a.length];\n            var d = a.slice(0, t);\n            [].splice.apply(a, [0, 0].concat(d));\n            z && (d = a.slice(a.length - t), [].splice.apply(a, [a.length, 0].concat(d)), k--);\n          }\n\n          a[0] = \"M\";\n        }\n\n        function c(a, b) {\n          for (var d = (m - a.length) / t; 0 < d && d--;) {\n            B = a.slice().splice(a.length / u - t, t * u), B[0] = b[m - t - d * t], l && (B[t - 6] = B[t - 2], B[t - 5] = B[t - 1]), [].splice.apply(a, [a.length / u, 0].concat(B)), z && d--;\n          }\n        }\n\n        d = d || \"\";\n        var r = b.startX,\n            g = b.endX,\n            l = -1 < d.indexOf(\"C\"),\n            t = l ? 7 : 3,\n            B,\n            k;\n        d = d.split(\" \");\n        a = a.slice();\n        var z = b.isArea,\n            u = z ? 2 : 1;\n        l && (e(d), e(a));\n\n        if (r && g) {\n          for (k = 0; k < r.length; k++) {\n            if (r[k] === g[0]) {\n              var L = k;\n              break;\n            } else if (r[0] === g[g.length - r.length + k]) {\n              L = k;\n              var M = !0;\n              break;\n            } else if (r[r.length - 1] === g[g.length - r.length + k]) {\n              L = r.length - k;\n              break;\n            }\n          }\n\n          \"undefined\" === typeof L && (d = []);\n        }\n\n        if (d.length && y(L)) {\n          var m = a.length + L * u * t;\n          M ? (n(d, a), c(a, d)) : (n(a, d), c(d, a));\n        }\n\n        return [d, a];\n      },\n      fillSetter: function fillSetter() {\n        c.Fx.prototype.strokeSetter.apply(this, arguments);\n      },\n      strokeSetter: function strokeSetter() {\n        this.elem.attr(this.prop, c.color(this.start).tweenTo(c.color(this.end), this.pos), null, !0);\n      }\n    };\n\n    c.merge = function () {\n      var b,\n          d = arguments,\n          a = {},\n          e = function e(a, b) {\n        \"object\" !== typeof a && (a = {});\n        m(b, function (d, h) {\n          !A(d, !0) || p(d) || E(d) ? a[h] = b[h] : a[h] = e(a[h] || {}, d);\n        });\n        return a;\n      };\n\n      !0 === d[0] && (a = d[1], d = Array.prototype.slice.call(d, 2));\n      var n = d.length;\n\n      for (b = 0; b < n; b++) {\n        a = e(a, d[b]);\n      }\n\n      return a;\n    };\n\n    c.clearTimeout = function (b) {\n      G(b) && clearTimeout(b);\n    };\n\n    c.css = function (b, d) {\n      c.isMS && !c.svg && d && \"undefined\" !== typeof d.opacity && (d.filter = \"alpha(opacity=\" + 100 * d.opacity + \")\");\n      q(b.style, d);\n    };\n\n    c.createElement = function (b, d, a, e, n) {\n      b = g.createElement(b);\n      var h = c.css;\n      d && q(b, d);\n      n && h(b, {\n        padding: \"0\",\n        border: \"none\",\n        margin: \"0\"\n      });\n      a && h(b, a);\n      e && e.appendChild(b);\n      return b;\n    };\n\n    c.extendClass = function (b, d) {\n      var a = function a() {};\n\n      a.prototype = new b();\n      q(a.prototype, d);\n      return a;\n    };\n\n    c.pad = function (b, d, a) {\n      return Array((d || 2) + 1 - String(b).replace(\"-\", \"\").length).join(a || \"0\") + b;\n    };\n\n    c.relativeLength = function (b, d, a) {\n      return /%$/.test(b) ? d * parseFloat(b) / 100 + (a || 0) : parseFloat(b);\n    };\n\n    c.wrap = function (b, d, a) {\n      var e = b[d];\n\n      b[d] = function () {\n        var b = Array.prototype.slice.call(arguments),\n            d = arguments,\n            h = this;\n\n        h.proceed = function () {\n          e.apply(h, arguments.length ? arguments : d);\n        };\n\n        b.unshift(e);\n        b = a.apply(this, b);\n        h.proceed = null;\n        return b;\n      };\n    };\n\n    c.datePropsToTimestamps = function (b) {\n      m(b, function (d, a) {\n        A(d) && \"function\" === typeof d.getTime ? b[a] = d.getTime() : (A(d) || D(d)) && c.datePropsToTimestamps(d);\n      });\n    };\n\n    c.formatSingle = function (b, d, a) {\n      var e = /\\.([0-9])/,\n          n = c.defaultOptions.lang;\n      /f$/.test(b) ? (a = (a = b.match(e)) ? a[1] : -1, null !== d && (d = c.numberFormat(d, a, n.decimalPoint, -1 < b.indexOf(\",\") ? n.thousandsSep : \"\"))) : d = (a || c.time).dateFormat(b, d);\n      return d;\n    };\n\n    c.format = function (b, d, a) {\n      for (var e = \"{\", n = !1, g, r, k, l, t = [], B; b;) {\n        e = b.indexOf(e);\n        if (-1 === e) break;\n        g = b.slice(0, e);\n\n        if (n) {\n          g = g.split(\":\");\n          r = g.shift().split(\".\");\n          l = r.length;\n          B = d;\n\n          for (k = 0; k < l; k++) {\n            B && (B = B[r[k]]);\n          }\n\n          g.length && (B = c.formatSingle(g.join(\":\"), B, a));\n          t.push(B);\n        } else t.push(g);\n\n        b = b.slice(e + 1);\n        e = (n = !n) ? \"}\" : \"{\";\n      }\n\n      t.push(b);\n      return t.join(\"\");\n    };\n\n    c.getMagnitude = function (b) {\n      return Math.pow(10, Math.floor(Math.log(b) / Math.LN10));\n    };\n\n    c.normalizeTickInterval = function (b, d, a, e, n) {\n      var h = b;\n      a = k(a, 1);\n      var r = b / a;\n      d || (d = n ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === e && (1 === a ? d = d.filter(function (a) {\n        return 0 === a % 1;\n      }) : .1 >= a && (d = [1 / a])));\n\n      for (e = 0; e < d.length && !(h = d[e], n && h * a >= b || !n && r <= (d[e] + (d[e + 1] || d[e])) / 2); e++) {\n        ;\n      }\n\n      return h = c.correctFloat(h * a, -Math.round(Math.log(.001) / Math.LN10));\n    };\n\n    c.stableSort = function (b, d) {\n      var a = b.length,\n          e,\n          c;\n\n      for (c = 0; c < a; c++) {\n        b[c].safeI = c;\n      }\n\n      b.sort(function (a, b) {\n        e = d(a, b);\n        return 0 === e ? a.safeI - b.safeI : e;\n      });\n\n      for (c = 0; c < a; c++) {\n        delete b[c].safeI;\n      }\n    };\n\n    c.correctFloat = function (b, d) {\n      return parseFloat(b.toPrecision(d || 14));\n    };\n\n    c.animObject = function (b) {\n      return A(b) ? c.merge(b) : {\n        duration: b ? 500 : 0\n      };\n    };\n\n    c.timeUnits = {\n      millisecond: 1,\n      second: 1E3,\n      minute: 6E4,\n      hour: 36E5,\n      day: 864E5,\n      week: 6048E5,\n      month: 24192E5,\n      year: 314496E5\n    };\n\n    c.numberFormat = function (b, d, a, e) {\n      b = +b || 0;\n      d = +d;\n      var h = c.defaultOptions.lang,\n          g = (b.toString().split(\".\")[1] || \"\").split(\"e\")[0].length,\n          r = b.toString().split(\"e\");\n      if (-1 === d) d = Math.min(g, 20);else if (!y(d)) d = 2;else if (d && r[1] && 0 > r[1]) {\n        var x = d + +r[1];\n        0 <= x ? (r[0] = (+r[0]).toExponential(x).split(\"e\")[0], d = x) : (r[0] = r[0].split(\".\")[0] || 0, b = 20 > d ? (r[0] * Math.pow(10, r[1])).toFixed(d) : 0, r[1] = 0);\n      }\n      var l = (Math.abs(r[1] ? r[0] : b) + Math.pow(10, -Math.max(d, g) - 1)).toFixed(d);\n      g = String(f(l));\n      x = 3 < g.length ? g.length % 3 : 0;\n      a = k(a, h.decimalPoint);\n      e = k(e, h.thousandsSep);\n      b = (0 > b ? \"-\" : \"\") + (x ? g.substr(0, x) + e : \"\");\n      b += g.substr(x).replace(/(\\d{3})(?=\\d)/g, \"$1\" + e);\n      d && (b += a + l.slice(-d));\n      r[1] && 0 !== +b && (b += \"e\" + r[1]);\n      return b;\n    };\n\n    Math.easeInOutSine = function (b) {\n      return -.5 * (Math.cos(Math.PI * b) - 1);\n    };\n\n    c.getStyle = function (b, d, a) {\n      if (\"width\" === d) return d = Math.min(b.offsetWidth, b.scrollWidth), a = b.getBoundingClientRect && b.getBoundingClientRect().width, a < d && a >= d - 1 && (d = Math.floor(a)), Math.max(0, d - c.getStyle(b, \"padding-left\") - c.getStyle(b, \"padding-right\"));\n      if (\"height\" === d) return Math.max(0, Math.min(b.offsetHeight, b.scrollHeight) - c.getStyle(b, \"padding-top\") - c.getStyle(b, \"padding-bottom\"));\n      e.getComputedStyle || c.error(27, !0);\n      if (b = e.getComputedStyle(b, void 0)) b = b.getPropertyValue(d), k(a, \"opacity\" !== d) && (b = f(b));\n      return b;\n    };\n\n    c.inArray = function (b, d, a) {\n      return d.indexOf(b, a);\n    };\n\n    c.find = Array.prototype.find ? function (b, d) {\n      return b.find(d);\n    } : function (b, d) {\n      var a,\n          e = b.length;\n\n      for (a = 0; a < e; a++) {\n        if (d(b[a], a)) return b[a];\n      }\n    };\n    c.keys = Object.keys;\n\n    c.offset = function (b) {\n      var d = g.documentElement;\n      b = b.parentElement || b.parentNode ? b.getBoundingClientRect() : {\n        top: 0,\n        left: 0\n      };\n      return {\n        top: b.top + (e.pageYOffset || d.scrollTop) - (d.clientTop || 0),\n        left: b.left + (e.pageXOffset || d.scrollLeft) - (d.clientLeft || 0)\n      };\n    };\n\n    c.stop = function (b, d) {\n      for (var a = c.timers.length; a--;) {\n        c.timers[a].elem !== b || d && d !== c.timers[a].prop || (c.timers[a].stopped = !0);\n      }\n    };\n\n    m({\n      map: \"map\",\n      each: \"forEach\",\n      grep: \"filter\",\n      reduce: \"reduce\",\n      some: \"some\"\n    }, function (b, d) {\n      c[d] = function (a) {\n        return Array.prototype[b].apply(a, [].slice.call(arguments, 1));\n      };\n    });\n\n    c.addEvent = function (b, d, a, e) {\n      void 0 === e && (e = {});\n      var h = b.addEventListener || c.addEventListenerPolyfill;\n      var g = \"function\" === typeof b && b.prototype ? b.prototype.protoEvents = b.prototype.protoEvents || {} : b.hcEvents = b.hcEvents || {};\n      c.Point && b instanceof c.Point && b.series && b.series.chart && (b.series.chart.runTrackerClick = !0);\n      h && h.call(b, d, a, !1);\n      g[d] || (g[d] = []);\n      g[d].push({\n        fn: a,\n        order: \"number\" === typeof e.order ? e.order : Infinity\n      });\n      g[d].sort(function (a, b) {\n        return a.order - b.order;\n      });\n      return function () {\n        c.removeEvent(b, d, a);\n      };\n    };\n\n    c.removeEvent = function (b, d, a) {\n      function e(a, d) {\n        var e = b.removeEventListener || c.removeEventListenerPolyfill;\n        e && e.call(b, a, d, !1);\n      }\n\n      function g(a) {\n        var h;\n\n        if (b.nodeName) {\n          if (d) {\n            var l = {};\n            l[d] = !0;\n          } else l = a;\n\n          m(l, function (b, d) {\n            if (a[d]) for (h = a[d].length; h--;) {\n              e(d, a[d][h].fn);\n            }\n          });\n        }\n      }\n\n      var k;\n      [\"protoEvents\", \"hcEvents\"].forEach(function (h, c) {\n        var l = (c = c ? b : b.prototype) && c[h];\n        l && (d ? (k = l[d] || [], a ? (l[d] = k.filter(function (b) {\n          return a !== b.fn;\n        }), e(d, a)) : (g(l), l[d] = [])) : (g(l), c[h] = {}));\n      });\n    };\n\n    c.fireEvent = function (b, d, a, e) {\n      var h;\n      a = a || {};\n\n      if (g.createEvent && (b.dispatchEvent || b.fireEvent)) {\n        var c = g.createEvent(\"Events\");\n        c.initEvent(d, !0, !0);\n        q(c, a);\n        b.dispatchEvent ? b.dispatchEvent(c) : b.fireEvent(d, c);\n      } else a.target || q(a, {\n        preventDefault: function preventDefault() {\n          a.defaultPrevented = !0;\n        },\n        target: b,\n        type: d\n      }), function (d, e) {\n        void 0 === d && (d = []);\n        void 0 === e && (e = []);\n        var l = 0,\n            c = 0,\n            r = d.length + e.length;\n\n        for (h = 0; h < r; h++) {\n          !1 === (d[l] ? e[c] ? d[l].order <= e[c].order ? d[l++] : e[c++] : d[l++] : e[c++]).fn.call(b, a) && a.preventDefault();\n        }\n      }(b.protoEvents && b.protoEvents[d], b.hcEvents && b.hcEvents[d]);\n\n      e && !a.defaultPrevented && e.call(b, a);\n    };\n\n    c.animate = function (b, d, a) {\n      var e,\n          g = \"\",\n          k,\n          r;\n\n      if (!A(a)) {\n        var x = arguments;\n        a = {\n          duration: x[2],\n          easing: x[3],\n          complete: x[4]\n        };\n      }\n\n      y(a.duration) || (a.duration = 400);\n      a.easing = \"function\" === typeof a.easing ? a.easing : Math[a.easing] || Math.easeInOutSine;\n      a.curAnim = c.merge(d);\n      m(d, function (h, t) {\n        c.stop(b, t);\n        r = new c.Fx(b, a, t);\n        k = null;\n        \"d\" === t ? (r.paths = r.initPath(b, b.d, d.d), r.toD = d.d, e = 0, k = 1) : b.attr ? e = b.attr(t) : (e = parseFloat(c.getStyle(b, t)) || 0, \"opacity\" !== t && (g = \"px\"));\n        k || (k = h);\n        k && k.match && k.match(\"px\") && (k = k.replace(/px/g, \"\"));\n        r.run(e, k, g);\n      });\n    };\n\n    c.seriesType = function (b, d, a, e, g) {\n      var h = c.getOptions(),\n          r = c.seriesTypes;\n      h.plotOptions[b] = c.merge(h.plotOptions[d], a);\n      r[b] = c.extendClass(r[d] || function () {}, e);\n      r[b].prototype.type = b;\n      g && (r[b].prototype.pointClass = c.extendClass(c.Point, g));\n      return r[b];\n    };\n\n    c.uniqueKey = function () {\n      var b = Math.random().toString(36).substring(2, 9),\n          d = 0;\n      return function () {\n        return \"highcharts-\" + b + \"-\" + d++;\n      };\n    }();\n\n    c.isFunction = function (b) {\n      return \"function\" === typeof b;\n    };\n\n    e.jQuery && (e.jQuery.fn.highcharts = function () {\n      var b = [].slice.call(arguments);\n      if (this[0]) return b[0] ? (new c[H(b[0]) ? b.shift() : \"Chart\"](this[0], b[0], b[1]), this) : w[v(this[0], \"data-highcharts-chart\")];\n    });\n    return {\n      arrayMax: function arrayMax(b) {\n        for (var d = b.length, a = b[0]; d--;) {\n          b[d] > a && (a = b[d]);\n        }\n\n        return a;\n      },\n      arrayMin: function arrayMin(b) {\n        for (var d = b.length, a = b[0]; d--;) {\n          b[d] < a && (a = b[d]);\n        }\n\n        return a;\n      },\n      attr: v,\n      defined: G,\n      destroyObjectProperties: function destroyObjectProperties(b, d) {\n        m(b, function (a, e) {\n          a && a !== d && a.destroy && a.destroy();\n          delete b[e];\n        });\n      },\n      discardElement: function discardElement(b) {\n        var d = c.garbageBin;\n        d || (d = c.createElement(\"div\"));\n        b && d.appendChild(b);\n        d.innerHTML = \"\";\n      },\n      erase: function erase(b, d) {\n        for (var a = b.length; a--;) {\n          if (b[a] === d) {\n            b.splice(a, 1);\n            break;\n          }\n        }\n      },\n      extend: q,\n      isArray: D,\n      isClass: p,\n      isDOMElement: E,\n      isNumber: y,\n      isObject: A,\n      isString: H,\n      objectEach: m,\n      pick: k,\n      pInt: f,\n      setAnimation: function setAnimation(b, d) {\n        d.renderer.globalAnimation = k(b, d.options.chart.animation, !0);\n      },\n      splat: function splat(b) {\n        return D(b) ? b : [b];\n      },\n      syncTimeout: function syncTimeout(b, d, a) {\n        if (0 < d) return setTimeout(b, d, a);\n        b.call(0, a);\n        return -1;\n      }\n    };\n  });\n  K(C, \"parts/Color.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var H = f.isNumber,\n        D = f.pInt,\n        A = c.merge;\n\n    c.Color = function (f) {\n      if (!(this instanceof c.Color)) return new c.Color(f);\n      this.init(f);\n    };\n\n    c.Color.prototype = {\n      parsers: [{\n        regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n        parse: function parse(c) {\n          return [D(c[1]), D(c[2]), D(c[3]), parseFloat(c[4], 10)];\n        }\n      }, {\n        regex: /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n        parse: function parse(c) {\n          return [D(c[1]), D(c[2]), D(c[3]), 1];\n        }\n      }],\n      names: {\n        white: \"#ffffff\",\n        black: \"#000000\"\n      },\n      init: function init(f) {\n        var p, y;\n        if ((this.input = f = this.names[f && f.toLowerCase ? f.toLowerCase() : \"\"] || f) && f.stops) this.stops = f.stops.map(function (f) {\n          return new c.Color(f[1]);\n        });else {\n          if (f && f.charAt && \"#\" === f.charAt()) {\n            var G = f.length;\n            f = parseInt(f.substr(1), 16);\n            7 === G ? p = [(f & 16711680) >> 16, (f & 65280) >> 8, f & 255, 1] : 4 === G && (p = [(f & 3840) >> 4 | (f & 3840) >> 8, (f & 240) >> 4 | f & 240, (f & 15) << 4 | f & 15, 1]);\n          }\n\n          if (!p) for (y = this.parsers.length; y-- && !p;) {\n            var v = this.parsers[y];\n            (G = v.regex.exec(f)) && (p = v.parse(G));\n          }\n        }\n        this.rgba = p || [];\n      },\n      get: function get(c) {\n        var f = this.input,\n            y = this.rgba;\n\n        if (this.stops) {\n          var G = A(f);\n          G.stops = [].concat(G.stops);\n          this.stops.forEach(function (f, q) {\n            G.stops[q] = [G.stops[q][0], f.get(c)];\n          });\n        } else G = y && H(y[0]) ? \"rgb\" === c || !c && 1 === y[3] ? \"rgb(\" + y[0] + \",\" + y[1] + \",\" + y[2] + \")\" : \"a\" === c ? y[3] : \"rgba(\" + y.join(\",\") + \")\" : f;\n\n        return G;\n      },\n      brighten: function brighten(c) {\n        var f,\n            y = this.rgba;\n        if (this.stops) this.stops.forEach(function (f) {\n          f.brighten(c);\n        });else if (H(c) && 0 !== c) for (f = 0; 3 > f; f++) {\n          y[f] += D(255 * c), 0 > y[f] && (y[f] = 0), 255 < y[f] && (y[f] = 255);\n        }\n        return this;\n      },\n      setOpacity: function setOpacity(c) {\n        this.rgba[3] = c;\n        return this;\n      },\n      tweenTo: function tweenTo(c, f) {\n        var y = this.rgba,\n            p = c.rgba;\n        p.length && y && y.length ? (c = 1 !== p[3] || 1 !== y[3], f = (c ? \"rgba(\" : \"rgb(\") + Math.round(p[0] + (y[0] - p[0]) * (1 - f)) + \",\" + Math.round(p[1] + (y[1] - p[1]) * (1 - f)) + \",\" + Math.round(p[2] + (y[2] - p[2]) * (1 - f)) + (c ? \",\" + (p[3] + (y[3] - p[3]) * (1 - f)) : \"\") + \")\") : f = c.input || \"none\";\n        return f;\n      }\n    };\n\n    c.color = function (f) {\n      return new c.Color(f);\n    };\n  });\n  K(C, \"parts/SvgRenderer.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var H = f.attr,\n        D = f.defined,\n        A = f.destroyObjectProperties,\n        E = f.erase,\n        p = f.extend,\n        y = f.isArray,\n        G = f.isNumber,\n        v = f.isObject,\n        q = f.isString,\n        k = f.objectEach,\n        m = f.pick,\n        w = f.pInt,\n        g = f.splat,\n        e = c.addEvent,\n        b = c.animate,\n        d = c.charts,\n        a = c.color,\n        h = c.css,\n        n = c.createElement,\n        F = c.deg2rad,\n        r = c.doc,\n        x = c.hasTouch,\n        l = c.isFirefox,\n        t = c.isMS,\n        B = c.isWebKit,\n        I = c.merge,\n        z = c.noop,\n        u = c.removeEvent,\n        L = c.stop,\n        M = c.svg,\n        T = c.SVG_NS,\n        Q = c.symbolSizes,\n        R = c.win;\n\n    var N = c.SVGElement = function () {\n      return this;\n    };\n\n    p(N.prototype, {\n      opacity: 1,\n      SVG_NS: T,\n      textProps: \"direction fontSize fontWeight fontFamily fontStyle color lineHeight width textAlign textDecoration textOverflow textOutline cursor\".split(\" \"),\n      init: function init(a, b) {\n        this.element = \"span\" === b ? n(b) : r.createElementNS(this.SVG_NS, b);\n        this.renderer = a;\n        c.fireEvent(this, \"afterInit\");\n      },\n      animate: function animate(a, d, e) {\n        var J = c.animObject(m(d, this.renderer.globalAnimation, !0));\n        m(r.hidden, r.msHidden, r.webkitHidden, !1) && (J.duration = 0);\n        0 !== J.duration ? (e && (J.complete = e), b(this, a, J)) : (this.attr(a, void 0, e), k(a, function (a, b) {\n          J.step && J.step.call(this, a, {\n            prop: b,\n            pos: 1\n          });\n        }, this));\n        return this;\n      },\n      complexColor: function complexColor(a, b, d) {\n        var e = this.renderer,\n            J,\n            u,\n            z,\n            h,\n            l,\n            O,\n            t,\n            r,\n            g,\n            n,\n            B,\n            M = [],\n            L;\n        c.fireEvent(this.renderer, \"complexColor\", {\n          args: arguments\n        }, function () {\n          a.radialGradient ? u = \"radialGradient\" : a.linearGradient && (u = \"linearGradient\");\n          u && (z = a[u], l = e.gradients, t = a.stops, n = d.radialReference, y(z) && (a[u] = z = {\n            x1: z[0],\n            y1: z[1],\n            x2: z[2],\n            y2: z[3],\n            gradientUnits: \"userSpaceOnUse\"\n          }), \"radialGradient\" === u && n && !D(z.gradientUnits) && (h = z, z = I(z, e.getRadialAttr(n, h), {\n            gradientUnits: \"userSpaceOnUse\"\n          })), k(z, function (a, b) {\n            \"id\" !== b && M.push(b, a);\n          }), k(t, function (a) {\n            M.push(a);\n          }), M = M.join(\",\"), l[M] ? B = l[M].attr(\"id\") : (z.id = B = c.uniqueKey(), l[M] = O = e.createElement(u).attr(z).add(e.defs), O.radAttr = h, O.stops = [], t.forEach(function (a) {\n            0 === a[1].indexOf(\"rgba\") ? (J = c.color(a[1]), r = J.get(\"rgb\"), g = J.get(\"a\")) : (r = a[1], g = 1);\n            a = e.createElement(\"stop\").attr({\n              offset: a[0],\n              \"stop-color\": r,\n              \"stop-opacity\": g\n            }).add(O);\n            O.stops.push(a);\n          })), L = \"url(\" + e.url + \"#\" + B + \")\", d.setAttribute(b, L), d.gradient = M, a.toString = function () {\n            return L;\n          });\n        });\n      },\n      applyTextOutline: function applyTextOutline(a) {\n        var b = this.element,\n            d;\n        -1 !== a.indexOf(\"contrast\") && (a = a.replace(/contrast/g, this.renderer.getContrast(b.style.fill)));\n        a = a.split(\" \");\n        var e = a[a.length - 1];\n\n        if ((d = a[0]) && \"none\" !== d && c.svg) {\n          this.fakeTS = !0;\n          a = [].slice.call(b.getElementsByTagName(\"tspan\"));\n          this.ySetter = this.xSetter;\n          d = d.replace(/(^[\\d\\.]+)(.*?)$/g, function (a, b, d) {\n            return 2 * b + d;\n          });\n          this.removeTextOutline(a);\n          var J = b.firstChild;\n          a.forEach(function (a, u) {\n            0 === u && (a.setAttribute(\"x\", b.getAttribute(\"x\")), u = b.getAttribute(\"y\"), a.setAttribute(\"y\", u || 0), null === u && b.setAttribute(\"y\", 0));\n            a = a.cloneNode(1);\n            H(a, {\n              \"class\": \"highcharts-text-outline\",\n              fill: e,\n              stroke: e,\n              \"stroke-width\": d,\n              \"stroke-linejoin\": \"round\"\n            });\n            b.insertBefore(a, J);\n          });\n        }\n      },\n      removeTextOutline: function removeTextOutline(a) {\n        for (var b = a.length, d; b--;) {\n          d = a[b], \"highcharts-text-outline\" === d.getAttribute(\"class\") && E(a, this.element.removeChild(d));\n        }\n      },\n      symbolCustomAttribs: \"x y width height r start end innerR anchorX anchorY rounded\".split(\" \"),\n      attr: function attr(a, b, d, e) {\n        var u = this.element,\n            J,\n            z = this,\n            h,\n            l,\n            t = this.symbolCustomAttribs;\n\n        if (\"string\" === typeof a && void 0 !== b) {\n          var r = a;\n          a = {};\n          a[r] = b;\n        }\n\n        \"string\" === typeof a ? z = (this[a + \"Getter\"] || this._defaultGetter).call(this, a, u) : (k(a, function (b, d) {\n          h = !1;\n          e || L(this, d);\n          this.symbolName && -1 !== c.inArray(d, t) && (J || (this.symbolAttr(a), J = !0), h = !0);\n          !this.rotation || \"x\" !== d && \"y\" !== d || (this.doTransform = !0);\n          h || (l = this[d + \"Setter\"] || this._defaultSetter, l.call(this, b, d, u), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(d) && this.updateShadows(d, b, l));\n        }, this), this.afterSetters());\n        d && d.call(this);\n        return z;\n      },\n      afterSetters: function afterSetters() {\n        this.doTransform && (this.updateTransform(), this.doTransform = !1);\n      },\n      updateShadows: function updateShadows(a, b, d) {\n        for (var e = this.shadows, u = e.length; u--;) {\n          d.call(e[u], \"height\" === a ? Math.max(b - (e[u].cutHeight || 0), 0) : \"d\" === a ? this.d : b, a, e[u]);\n        }\n      },\n      addClass: function addClass(a, b) {\n        var d = b ? \"\" : this.attr(\"class\") || \"\";\n        a = (a || \"\").split(/ /g).reduce(function (a, b) {\n          -1 === d.indexOf(b) && a.push(b);\n          return a;\n        }, d ? [d] : []).join(\" \");\n        a !== d && this.attr(\"class\", a);\n        return this;\n      },\n      hasClass: function hasClass(a) {\n        return -1 !== (this.attr(\"class\") || \"\").split(\" \").indexOf(a);\n      },\n      removeClass: function removeClass(a) {\n        return this.attr(\"class\", (this.attr(\"class\") || \"\").replace(q(a) ? new RegExp(\" ?\" + a + \" ?\") : a, \"\"));\n      },\n      symbolAttr: function symbolAttr(a) {\n        var b = this;\n        \"x y r start end width height innerR anchorX anchorY clockwise\".split(\" \").forEach(function (d) {\n          b[d] = m(a[d], b[d]);\n        });\n        b.attr({\n          d: b.renderer.symbols[b.symbolName](b.x, b.y, b.width, b.height, b)\n        });\n      },\n      clip: function clip(a) {\n        return this.attr(\"clip-path\", a ? \"url(\" + this.renderer.url + \"#\" + a.id + \")\" : \"none\");\n      },\n      crisp: function crisp(a, b) {\n        b = b || a.strokeWidth || 0;\n        var d = Math.round(b) % 2 / 2;\n        a.x = Math.floor(a.x || this.x || 0) + d;\n        a.y = Math.floor(a.y || this.y || 0) + d;\n        a.width = Math.floor((a.width || this.width || 0) - 2 * d);\n        a.height = Math.floor((a.height || this.height || 0) - 2 * d);\n        D(a.strokeWidth) && (a.strokeWidth = b);\n        return a;\n      },\n      css: function css(a) {\n        var b = this.styles,\n            d = {},\n            e = this.element,\n            u = \"\",\n            z = !b,\n            J = [\"textOutline\", \"textOverflow\", \"width\"];\n        a && a.color && (a.fill = a.color);\n        b && k(a, function (a, e) {\n          a !== b[e] && (d[e] = a, z = !0);\n        });\n\n        if (z) {\n          b && (a = p(b, d));\n          if (a) if (null === a.width || \"auto\" === a.width) delete this.textWidth;else if (\"text\" === e.nodeName.toLowerCase() && a.width) var l = this.textWidth = w(a.width);\n          this.styles = a;\n          l && !M && this.renderer.forExport && delete a.width;\n\n          if (e.namespaceURI === this.SVG_NS) {\n            var c = function c(a, b) {\n              return \"-\" + b.toLowerCase();\n            };\n\n            k(a, function (a, b) {\n              -1 === J.indexOf(b) && (u += b.replace(/([A-Z])/g, c) + \":\" + a + \";\");\n            });\n            u && H(e, \"style\", u);\n          } else h(e, a);\n\n          this.added && (\"text\" === this.element.nodeName && this.renderer.buildText(this), a && a.textOutline && this.applyTextOutline(a.textOutline));\n        }\n\n        return this;\n      },\n      getStyle: function getStyle(a) {\n        return R.getComputedStyle(this.element || this, \"\").getPropertyValue(a);\n      },\n      strokeWidth: function strokeWidth() {\n        if (!this.renderer.styledMode) return this[\"stroke-width\"] || 0;\n        var a = this.getStyle(\"stroke-width\");\n        if (a.indexOf(\"px\") === a.length - 2) a = w(a);else {\n          var b = r.createElementNS(T, \"rect\");\n          H(b, {\n            width: a,\n            \"stroke-width\": 0\n          });\n          this.element.parentNode.appendChild(b);\n          a = b.getBBox().width;\n          b.parentNode.removeChild(b);\n        }\n        return a;\n      },\n      on: function on(a, b) {\n        var d = this,\n            e = d.element;\n        x && \"click\" === a ? (e.ontouchstart = function (a) {\n          d.touchEventFired = Date.now();\n          a.preventDefault();\n          b.call(e, a);\n        }, e.onclick = function (a) {\n          (-1 === R.navigator.userAgent.indexOf(\"Android\") || 1100 < Date.now() - (d.touchEventFired || 0)) && b.call(e, a);\n        }) : e[\"on\" + a] = b;\n        return this;\n      },\n      setRadialReference: function setRadialReference(a) {\n        var b = this.renderer.gradients[this.element.gradient];\n        this.element.radialReference = a;\n        b && b.radAttr && b.animate(this.renderer.getRadialAttr(a, b.radAttr));\n        return this;\n      },\n      translate: function translate(a, b) {\n        return this.attr({\n          translateX: a,\n          translateY: b\n        });\n      },\n      invert: function invert(a) {\n        this.inverted = a;\n        this.updateTransform();\n        return this;\n      },\n      updateTransform: function updateTransform() {\n        var a = this.translateX || 0,\n            b = this.translateY || 0,\n            d = this.scaleX,\n            e = this.scaleY,\n            u = this.inverted,\n            z = this.rotation,\n            h = this.matrix,\n            l = this.element;\n        u && (a += this.width, b += this.height);\n        a = [\"translate(\" + a + \",\" + b + \")\"];\n        D(h) && a.push(\"matrix(\" + h.join(\",\") + \")\");\n        u ? a.push(\"rotate(90) scale(-1,1)\") : z && a.push(\"rotate(\" + z + \" \" + m(this.rotationOriginX, l.getAttribute(\"x\"), 0) + \" \" + m(this.rotationOriginY, l.getAttribute(\"y\") || 0) + \")\");\n        (D(d) || D(e)) && a.push(\"scale(\" + m(d, 1) + \" \" + m(e, 1) + \")\");\n        a.length && l.setAttribute(\"transform\", a.join(\" \"));\n      },\n      toFront: function toFront() {\n        var a = this.element;\n        a.parentNode.appendChild(a);\n        return this;\n      },\n      align: function align(a, b, d) {\n        var e,\n            u = {};\n        var z = this.renderer;\n        var h = z.alignedObjects;\n        var l, J;\n\n        if (a) {\n          if (this.alignOptions = a, this.alignByTranslate = b, !d || q(d)) this.alignTo = e = d || \"renderer\", E(h, this), h.push(this), d = null;\n        } else a = this.alignOptions, b = this.alignByTranslate, e = this.alignTo;\n\n        d = m(d, z[e], z);\n        e = a.align;\n        z = a.verticalAlign;\n        h = (d.x || 0) + (a.x || 0);\n        var c = (d.y || 0) + (a.y || 0);\n        \"right\" === e ? l = 1 : \"center\" === e && (l = 2);\n        l && (h += (d.width - (a.width || 0)) / l);\n        u[b ? \"translateX\" : \"x\"] = Math.round(h);\n        \"bottom\" === z ? J = 1 : \"middle\" === z && (J = 2);\n        J && (c += (d.height - (a.height || 0)) / J);\n        u[b ? \"translateY\" : \"y\"] = Math.round(c);\n        this[this.placed ? \"animate\" : \"attr\"](u);\n        this.placed = !0;\n        this.alignAttr = u;\n        return this;\n      },\n      getBBox: function getBBox(a, b) {\n        var d,\n            e = this.renderer,\n            u = this.element,\n            z = this.styles,\n            h = this.textStr,\n            l,\n            J = e.cache,\n            c = e.cacheKeys,\n            t = u.namespaceURI === this.SVG_NS;\n        b = m(b, this.rotation, 0);\n        var r = e.styledMode ? u && N.prototype.getStyle.call(u, \"font-size\") : z && z.fontSize;\n\n        if (D(h)) {\n          var g = h.toString();\n          -1 === g.indexOf(\"<\") && (g = g.replace(/[0-9]/g, \"0\"));\n          g += [\"\", b, r, this.textWidth, z && z.textOverflow].join();\n        }\n\n        g && !a && (d = J[g]);\n\n        if (!d) {\n          if (t || e.forExport) {\n            try {\n              (l = this.fakeTS && function (a) {\n                [].forEach.call(u.querySelectorAll(\".highcharts-text-outline\"), function (b) {\n                  b.style.display = a;\n                });\n              }) && l(\"none\"), d = u.getBBox ? p({}, u.getBBox()) : {\n                width: u.offsetWidth,\n                height: u.offsetHeight\n              }, l && l(\"\");\n            } catch (ba) {\n              \"\";\n            }\n\n            if (!d || 0 > d.width) d = {\n              width: 0,\n              height: 0\n            };\n          } else d = this.htmlGetBBox();\n\n          e.isSVG && (a = d.width, e = d.height, t && (d.height = e = {\n            \"11px,17\": 14,\n            \"13px,20\": 16\n          }[z && z.fontSize + \",\" + Math.round(e)] || e), b && (z = b * F, d.width = Math.abs(e * Math.sin(z)) + Math.abs(a * Math.cos(z)), d.height = Math.abs(e * Math.cos(z)) + Math.abs(a * Math.sin(z))));\n\n          if (g && 0 < d.height) {\n            for (; 250 < c.length;) {\n              delete J[c.shift()];\n            }\n\n            J[g] || c.push(g);\n            J[g] = d;\n          }\n        }\n\n        return d;\n      },\n      show: function show(a) {\n        return this.attr({\n          visibility: a ? \"inherit\" : \"visible\"\n        });\n      },\n      hide: function hide(a) {\n        a ? this.attr({\n          y: -9999\n        }) : this.attr({\n          visibility: \"hidden\"\n        });\n        return this;\n      },\n      fadeOut: function fadeOut(a) {\n        var b = this;\n        b.animate({\n          opacity: 0\n        }, {\n          duration: a || 150,\n          complete: function complete() {\n            b.attr({\n              y: -9999\n            });\n          }\n        });\n      },\n      add: function add(a) {\n        var b = this.renderer,\n            d = this.element;\n        a && (this.parentGroup = a);\n        this.parentInverted = a && a.inverted;\n        void 0 !== this.textStr && b.buildText(this);\n        this.added = !0;\n        if (!a || a.handleZ || this.zIndex) var e = this.zIndexSetter();\n        e || (a ? a.element : b.box).appendChild(d);\n        if (this.onAdd) this.onAdd();\n        return this;\n      },\n      safeRemoveChild: function safeRemoveChild(a) {\n        var b = a.parentNode;\n        b && b.removeChild(a);\n      },\n      destroy: function destroy() {\n        var a = this,\n            b = a.element || {},\n            d = a.renderer,\n            e = d.isSVG && \"SPAN\" === b.nodeName && a.parentGroup,\n            u = b.ownerSVGElement,\n            z = a.clipPath;\n        b.onclick = b.onmouseout = b.onmouseover = b.onmousemove = b.point = null;\n        L(a);\n        z && u && ([].forEach.call(u.querySelectorAll(\"[clip-path],[CLIP-PATH]\"), function (a) {\n          -1 < a.getAttribute(\"clip-path\").indexOf(z.element.id) && a.removeAttribute(\"clip-path\");\n        }), a.clipPath = z.destroy());\n\n        if (a.stops) {\n          for (u = 0; u < a.stops.length; u++) {\n            a.stops[u] = a.stops[u].destroy();\n          }\n\n          a.stops = null;\n        }\n\n        a.safeRemoveChild(b);\n\n        for (d.styledMode || a.destroyShadows(); e && e.div && 0 === e.div.childNodes.length;) {\n          b = e.parentGroup, a.safeRemoveChild(e.div), delete e.div, e = b;\n        }\n\n        a.alignTo && E(d.alignedObjects, a);\n        k(a, function (b, d) {\n          a[d] && a[d].parentGroup === a && a[d].destroy && a[d].destroy();\n          delete a[d];\n        });\n      },\n      shadow: function shadow(a, b, d) {\n        var e = [],\n            u,\n            z = this.element;\n        if (!a) this.destroyShadows();else if (!this.shadows) {\n          var h = m(a.width, 3);\n          var l = (a.opacity || .15) / h;\n          var c = this.parentInverted ? \"(-1,-1)\" : \"(\" + m(a.offsetX, 1) + \", \" + m(a.offsetY, 1) + \")\";\n\n          for (u = 1; u <= h; u++) {\n            var J = z.cloneNode(0);\n            var g = 2 * h + 1 - 2 * u;\n            H(J, {\n              stroke: a.color || \"#000000\",\n              \"stroke-opacity\": l * u,\n              \"stroke-width\": g,\n              transform: \"translate\" + c,\n              fill: \"none\"\n            });\n            J.setAttribute(\"class\", (J.getAttribute(\"class\") || \"\") + \" highcharts-shadow\");\n            d && (H(J, \"height\", Math.max(H(J, \"height\") - g, 0)), J.cutHeight = g);\n            b ? b.element.appendChild(J) : z.parentNode && z.parentNode.insertBefore(J, z);\n            e.push(J);\n          }\n\n          this.shadows = e;\n        }\n        return this;\n      },\n      destroyShadows: function destroyShadows() {\n        (this.shadows || []).forEach(function (a) {\n          this.safeRemoveChild(a);\n        }, this);\n        this.shadows = void 0;\n      },\n      xGetter: function xGetter(a) {\n        \"circle\" === this.element.nodeName && (\"x\" === a ? a = \"cx\" : \"y\" === a && (a = \"cy\"));\n        return this._defaultGetter(a);\n      },\n      _defaultGetter: function _defaultGetter(a) {\n        a = m(this[a + \"Value\"], this[a], this.element ? this.element.getAttribute(a) : null, 0);\n        /^[\\-0-9\\.]+$/.test(a) && (a = parseFloat(a));\n        return a;\n      },\n      dSetter: function dSetter(a, b, d) {\n        a && a.join && (a = a.join(\" \"));\n        /(NaN| {2}|^$)/.test(a) && (a = \"M 0 0\");\n        this[b] !== a && (d.setAttribute(b, a), this[b] = a);\n      },\n      dashstyleSetter: function dashstyleSetter(a) {\n        var b,\n            d = this[\"stroke-width\"];\n        \"inherit\" === d && (d = 1);\n\n        if (a = a && a.toLowerCase()) {\n          a = a.replace(\"shortdashdotdot\", \"3,1,1,1,1,1,\").replace(\"shortdashdot\", \"3,1,1,1\").replace(\"shortdot\", \"1,1,\").replace(\"shortdash\", \"3,1,\").replace(\"longdash\", \"8,3,\").replace(/dot/g, \"1,3,\").replace(\"dash\", \"4,3,\").replace(/,$/, \"\").split(\",\");\n\n          for (b = a.length; b--;) {\n            a[b] = w(a[b]) * d;\n          }\n\n          a = a.join(\",\").replace(/NaN/g, \"none\");\n          this.element.setAttribute(\"stroke-dasharray\", a);\n        }\n      },\n      alignSetter: function alignSetter(a) {\n        var b = {\n          left: \"start\",\n          center: \"middle\",\n          right: \"end\"\n        };\n        b[a] && (this.alignValue = a, this.element.setAttribute(\"text-anchor\", b[a]));\n      },\n      opacitySetter: function opacitySetter(a, b, d) {\n        this[b] = a;\n        d.setAttribute(b, a);\n      },\n      titleSetter: function titleSetter(a) {\n        var b = this.element.getElementsByTagName(\"title\")[0];\n        b || (b = r.createElementNS(this.SVG_NS, \"title\"), this.element.appendChild(b));\n        b.firstChild && b.removeChild(b.firstChild);\n        b.appendChild(r.createTextNode(String(m(a, \"\")).replace(/<[^>]*>/g, \"\").replace(/&lt;/g, \"<\").replace(/&gt;/g, \">\")));\n      },\n      textSetter: function textSetter(a) {\n        a !== this.textStr && (delete this.bBox, delete this.textPxLength, this.textStr = a, this.added && this.renderer.buildText(this));\n      },\n      setTextPath: function setTextPath(a, b) {\n        var d = this.element,\n            e = {\n          textAnchor: \"text-anchor\"\n        },\n            u = !1,\n            h = this.textPathWrapper,\n            l = !h;\n        b = I(!0, {\n          enabled: !0,\n          attributes: {\n            dy: -5,\n            startOffset: \"50%\",\n            textAnchor: \"middle\"\n          }\n        }, b);\n        var g = b.attributes;\n\n        if (a && b && b.enabled) {\n          this.options && this.options.padding && (g.dx = -this.options.padding);\n          h || (this.textPathWrapper = h = this.renderer.createElement(\"textPath\"), u = !0);\n          var t = h.element;\n          (b = a.element.getAttribute(\"id\")) || a.element.setAttribute(\"id\", b = c.uniqueKey());\n          if (l) for (a = d.getElementsByTagName(\"tspan\"); a.length;) {\n            a[0].setAttribute(\"y\", 0), t.appendChild(a[0]);\n          }\n          u && h.add({\n            element: this.text ? this.text.element : d\n          });\n          t.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", this.renderer.url + \"#\" + b);\n          D(g.dy) && (t.parentNode.setAttribute(\"dy\", g.dy), delete g.dy);\n          D(g.dx) && (t.parentNode.setAttribute(\"dx\", g.dx), delete g.dx);\n          k(g, function (a, b) {\n            t.setAttribute(e[b] || b, a);\n          });\n          d.removeAttribute(\"transform\");\n          this.removeTextOutline.call(h, [].slice.call(d.getElementsByTagName(\"tspan\")));\n          this.text && !this.renderer.styledMode && this.attr({\n            fill: \"none\",\n            \"stroke-width\": 0\n          });\n          this.applyTextOutline = this.updateTransform = z;\n        } else h && (delete this.updateTransform, delete this.applyTextOutline, this.destroyTextPath(d, a));\n\n        return this;\n      },\n      destroyTextPath: function destroyTextPath(a, b) {\n        var d;\n        b.element.setAttribute(\"id\", \"\");\n\n        for (d = this.textPathWrapper.element.childNodes; d.length;) {\n          a.firstChild.appendChild(d[0]);\n        }\n\n        a.firstChild.removeChild(this.textPathWrapper.element);\n        delete b.textPathWrapper;\n      },\n      fillSetter: function fillSetter(a, b, d) {\n        \"string\" === typeof a ? d.setAttribute(b, a) : a && this.complexColor(a, b, d);\n      },\n      visibilitySetter: function visibilitySetter(a, b, d) {\n        \"inherit\" === a ? d.removeAttribute(b) : this[b] !== a && d.setAttribute(b, a);\n        this[b] = a;\n      },\n      zIndexSetter: function zIndexSetter(a, b) {\n        var d = this.renderer,\n            e = this.parentGroup,\n            u = (e || d).element || d.box,\n            z = this.element,\n            h = !1;\n        d = u === d.box;\n        var l = this.added;\n        var c;\n        D(a) ? (z.setAttribute(\"data-z-index\", a), a = +a, this[b] === a && (l = !1)) : D(this[b]) && z.removeAttribute(\"data-z-index\");\n        this[b] = a;\n\n        if (l) {\n          (a = this.zIndex) && e && (e.handleZ = !0);\n          b = u.childNodes;\n\n          for (c = b.length - 1; 0 <= c && !h; c--) {\n            e = b[c];\n            l = e.getAttribute(\"data-z-index\");\n            var g = !D(l);\n            if (e !== z) if (0 > a && g && !d && !c) u.insertBefore(z, b[c]), h = !0;else if (w(l) <= a || g && (!D(a) || 0 <= a)) u.insertBefore(z, b[c + 1] || null), h = !0;\n          }\n\n          h || (u.insertBefore(z, b[d ? 3 : 0] || null), h = !0);\n        }\n\n        return h;\n      },\n      _defaultSetter: function _defaultSetter(a, b, d) {\n        d.setAttribute(b, a);\n      }\n    });\n    N.prototype.yGetter = N.prototype.xGetter;\n\n    N.prototype.translateXSetter = N.prototype.translateYSetter = N.prototype.rotationSetter = N.prototype.verticalAlignSetter = N.prototype.rotationOriginXSetter = N.prototype.rotationOriginYSetter = N.prototype.scaleXSetter = N.prototype.scaleYSetter = N.prototype.matrixSetter = function (a, b) {\n      this[b] = a;\n      this.doTransform = !0;\n    };\n\n    N.prototype[\"stroke-widthSetter\"] = N.prototype.strokeSetter = function (a, b, d) {\n      this[b] = a;\n      this.stroke && this[\"stroke-width\"] ? (N.prototype.fillSetter.call(this, this.stroke, \"stroke\", d), d.setAttribute(\"stroke-width\", this[\"stroke-width\"]), this.hasStroke = !0) : \"stroke-width\" === b && 0 === a && this.hasStroke ? (d.removeAttribute(\"stroke\"), this.hasStroke = !1) : this.renderer.styledMode && this[\"stroke-width\"] && (d.setAttribute(\"stroke-width\", this[\"stroke-width\"]), this.hasStroke = !0);\n    };\n\n    f = c.SVGRenderer = function () {\n      this.init.apply(this, arguments);\n    };\n\n    p(f.prototype, {\n      Element: N,\n      SVG_NS: T,\n      init: function init(a, b, d, u, z, c, g) {\n        var t = this.createElement(\"svg\").attr({\n          version: \"1.1\",\n          \"class\": \"highcharts-root\"\n        });\n        g || t.css(this.getStyle(u));\n        u = t.element;\n        a.appendChild(u);\n        H(a, \"dir\", \"ltr\");\n        -1 === a.innerHTML.indexOf(\"xmlns\") && H(u, \"xmlns\", this.SVG_NS);\n        this.isSVG = !0;\n        this.box = u;\n        this.boxWrapper = t;\n        this.alignedObjects = [];\n        this.url = (l || B) && r.getElementsByTagName(\"base\").length ? R.location.href.split(\"#\")[0].replace(/<[^>]*>/g, \"\").replace(/([\\('\\)])/g, \"\\\\$1\").replace(/ /g, \"%20\") : \"\";\n        this.createElement(\"desc\").add().element.appendChild(r.createTextNode(\"Created with Highcharts 7.2.1\"));\n        this.defs = this.createElement(\"defs\").add();\n        this.allowHTML = c;\n        this.forExport = z;\n        this.styledMode = g;\n        this.gradients = {};\n        this.cache = {};\n        this.cacheKeys = [];\n        this.imgCount = 0;\n        this.setSize(b, d, !1);\n        var n;\n        l && a.getBoundingClientRect && (b = function b() {\n          h(a, {\n            left: 0,\n            top: 0\n          });\n          n = a.getBoundingClientRect();\n          h(a, {\n            left: Math.ceil(n.left) - n.left + \"px\",\n            top: Math.ceil(n.top) - n.top + \"px\"\n          });\n        }, b(), this.unSubPixelFix = e(R, \"resize\", b));\n      },\n      definition: function definition(a) {\n        function b(a, e) {\n          var u;\n          g(a).forEach(function (a) {\n            var z = d.createElement(a.tagName),\n                h = {};\n            k(a, function (a, b) {\n              \"tagName\" !== b && \"children\" !== b && \"textContent\" !== b && (h[b] = a);\n            });\n            z.attr(h);\n            z.add(e || d.defs);\n            a.textContent && z.element.appendChild(r.createTextNode(a.textContent));\n            b(a.children || [], z);\n            u = z;\n          });\n          return u;\n        }\n\n        var d = this;\n        return b(a);\n      },\n      getStyle: function getStyle(a) {\n        return this.style = p({\n          fontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", Arial, Helvetica, sans-serif',\n          fontSize: \"12px\"\n        }, a);\n      },\n      setStyle: function setStyle(a) {\n        this.boxWrapper.css(this.getStyle(a));\n      },\n      isHidden: function isHidden() {\n        return !this.boxWrapper.getBBox().width;\n      },\n      destroy: function destroy() {\n        var a = this.defs;\n        this.box = null;\n        this.boxWrapper = this.boxWrapper.destroy();\n        A(this.gradients || {});\n        this.gradients = null;\n        a && (this.defs = a.destroy());\n        this.unSubPixelFix && this.unSubPixelFix();\n        return this.alignedObjects = null;\n      },\n      createElement: function createElement(a) {\n        var b = new this.Element();\n        b.init(this, a);\n        return b;\n      },\n      draw: z,\n      getRadialAttr: function getRadialAttr(a, b) {\n        return {\n          cx: a[0] - a[2] / 2 + b.cx * a[2],\n          cy: a[1] - a[2] / 2 + b.cy * a[2],\n          r: b.r * a[2]\n        };\n      },\n      truncate: function truncate(a, b, d, e, u, z, h) {\n        var l = this,\n            c = a.rotation,\n            g,\n            t = e ? 1 : 0,\n            n = (d || e).length,\n            B = n,\n            k = [],\n            J = function J(a) {\n          b.firstChild && b.removeChild(b.firstChild);\n          a && b.appendChild(r.createTextNode(a));\n        },\n            M = function M(z, c) {\n          c = c || z;\n          if (void 0 === k[c]) if (b.getSubStringLength) try {\n            k[c] = u + b.getSubStringLength(0, e ? c + 1 : c);\n          } catch (ca) {\n            \"\";\n          } else l.getSpanWidth && (J(h(d || e, z)), k[c] = u + l.getSpanWidth(a, b));\n          return k[c];\n        },\n            L;\n\n        a.rotation = 0;\n        var x = M(b.textContent.length);\n\n        if (L = u + x > z) {\n          for (; t <= n;) {\n            B = Math.ceil((t + n) / 2), e && (g = h(e, B)), x = M(B, g && g.length - 1), t === n ? t = n + 1 : x > z ? n = B - 1 : t = B;\n          }\n\n          0 === n ? J(\"\") : d && n === d.length - 1 || J(g || h(d || e, B));\n        }\n\n        e && e.splice(0, B);\n        a.actualWidth = x;\n        a.rotation = c;\n        return L;\n      },\n      escapes: {\n        \"&\": \"&amp;\",\n        \"<\": \"&lt;\",\n        \">\": \"&gt;\",\n        \"'\": \"&#39;\",\n        '\"': \"&quot;\"\n      },\n      buildText: function buildText(a) {\n        var b = a.element,\n            d = this,\n            e = d.forExport,\n            u = m(a.textStr, \"\").toString(),\n            z = -1 !== u.indexOf(\"<\"),\n            l = b.childNodes,\n            c,\n            g = H(b, \"x\"),\n            t = a.styles,\n            n = a.textWidth,\n            B = t && t.lineHeight,\n            J = t && t.textOutline,\n            L = t && \"ellipsis\" === t.textOverflow,\n            x = t && \"nowrap\" === t.whiteSpace,\n            I = t && t.fontSize,\n            F,\n            f = l.length;\n        t = n && !a.added && this.box;\n\n        var q = function q(a) {\n          var e;\n          d.styledMode || (e = /(px|em)$/.test(a && a.style.fontSize) ? a.style.fontSize : I || d.style.fontSize || 12);\n          return B ? w(B) : d.fontMetrics(e, a.getAttribute(\"style\") ? a : b).h;\n        },\n            p = function p(a, b) {\n          k(d.escapes, function (d, e) {\n            b && -1 !== b.indexOf(d) || (a = a.toString().replace(new RegExp(d, \"g\"), e));\n          });\n          return a;\n        },\n            y = function y(a, b) {\n          var d = a.indexOf(\"<\");\n          a = a.substring(d, a.indexOf(\">\") - d);\n          d = a.indexOf(b + \"=\");\n          if (-1 !== d && (d = d + b.length + 1, b = a.charAt(d), '\"' === b || \"'\" === b)) return a = a.substring(d + 1), a.substring(0, a.indexOf(b));\n        },\n            G = /<br.*?>/g;\n\n        var v = [u, L, x, B, J, I, n].join();\n\n        if (v !== a.textCache) {\n          for (a.textCache = v; f--;) {\n            b.removeChild(l[f]);\n          }\n\n          z || J || L || n || -1 !== u.indexOf(\" \") && (!x || G.test(u)) ? (t && t.appendChild(b), z ? (u = d.styledMode ? u.replace(/<(b|strong)>/g, '<span class=\"highcharts-strong\">').replace(/<(i|em)>/g, '<span class=\"highcharts-emphasized\">') : u.replace(/<(b|strong)>/g, '<span style=\"font-weight:bold\">').replace(/<(i|em)>/g, '<span style=\"font-style:italic\">'), u = u.replace(/<a/g, \"<span\").replace(/<\\/(b|strong|i|em|a)>/g, \"</span>\").split(G)) : u = [u], u = u.filter(function (a) {\n            return \"\" !== a;\n          }), u.forEach(function (u, z) {\n            var l = 0,\n                t = 0;\n            u = u.replace(/^\\s+|\\s+$/g, \"\").replace(/<span/g, \"|||<span\").replace(/<\\/span>/g, \"</span>|||\");\n            var B = u.split(\"|||\");\n            B.forEach(function (u) {\n              if (\"\" !== u || 1 === B.length) {\n                var k = {},\n                    J = r.createElementNS(d.SVG_NS, \"tspan\"),\n                    m,\n                    O;\n                (m = y(u, \"class\")) && H(J, \"class\", m);\n                if (m = y(u, \"style\")) m = m.replace(/(;| |^)color([ :])/, \"$1fill$2\"), H(J, \"style\", m);\n                (O = y(u, \"href\")) && !e && (H(J, \"onclick\", 'location.href=\"' + O + '\"'), H(J, \"class\", \"highcharts-anchor\"), d.styledMode || h(J, {\n                  cursor: \"pointer\"\n                }));\n                u = p(u.replace(/<[a-zA-Z\\/](.|\\n)*?>/g, \"\") || \" \");\n\n                if (\" \" !== u) {\n                  J.appendChild(r.createTextNode(u));\n                  l ? k.dx = 0 : z && null !== g && (k.x = g);\n                  H(J, k);\n                  b.appendChild(J);\n                  !l && F && (!M && e && h(J, {\n                    display: \"block\"\n                  }), H(J, \"dy\", q(J)));\n\n                  if (n) {\n                    var f = u.replace(/([^\\^])-/g, \"$1- \").split(\" \");\n                    k = !x && (1 < B.length || z || 1 < f.length);\n                    O = 0;\n                    var w = q(J);\n                    if (L) c = d.truncate(a, J, u, void 0, 0, Math.max(0, n - parseInt(I || 12, 10)), function (a, b) {\n                      return a.substring(0, b) + \"\\u2026\";\n                    });else if (k) for (; f.length;) {\n                      f.length && !x && 0 < O && (J = r.createElementNS(T, \"tspan\"), H(J, {\n                        dy: w,\n                        x: g\n                      }), m && H(J, \"style\", m), J.appendChild(r.createTextNode(f.join(\" \").replace(/- /g, \"-\"))), b.appendChild(J)), d.truncate(a, J, null, f, 0 === O ? t : 0, n, function (a, b) {\n                        return f.slice(0, b).join(\" \").replace(/- /g, \"-\");\n                      }), t = a.actualWidth, O++;\n                    }\n                  }\n\n                  l++;\n                }\n              }\n            });\n            F = F || b.childNodes.length;\n          }), L && c && a.attr(\"title\", p(a.textStr, [\"&lt;\", \"&gt;\"])), t && t.removeChild(b), J && a.applyTextOutline && a.applyTextOutline(J)) : b.appendChild(r.createTextNode(p(u)));\n        }\n      },\n      getContrast: function getContrast(b) {\n        b = a(b).rgba;\n        b[0] *= 1;\n        b[1] *= 1.2;\n        b[2] *= .5;\n        return 459 < b[0] + b[1] + b[2] ? \"#000000\" : \"#FFFFFF\";\n      },\n      button: function button(a, b, d, u, z, h, l, c, g, r) {\n        var n = this.label(a, b, d, g, null, null, r, null, \"button\"),\n            B = 0,\n            k = this.styledMode;\n        n.attr(I({\n          padding: 8,\n          r: 2\n        }, z));\n\n        if (!k) {\n          z = I({\n            fill: \"#f7f7f7\",\n            stroke: \"#cccccc\",\n            \"stroke-width\": 1,\n            style: {\n              color: \"#333333\",\n              cursor: \"pointer\",\n              fontWeight: \"normal\"\n            }\n          }, z);\n          var J = z.style;\n          delete z.style;\n          h = I(z, {\n            fill: \"#e6e6e6\"\n          }, h);\n          var M = h.style;\n          delete h.style;\n          l = I(z, {\n            fill: \"#e6ebf5\",\n            style: {\n              color: \"#000000\",\n              fontWeight: \"bold\"\n            }\n          }, l);\n          var L = l.style;\n          delete l.style;\n          c = I(z, {\n            style: {\n              color: \"#cccccc\"\n            }\n          }, c);\n          var x = c.style;\n          delete c.style;\n        }\n\n        e(n.element, t ? \"mouseover\" : \"mouseenter\", function () {\n          3 !== B && n.setState(1);\n        });\n        e(n.element, t ? \"mouseout\" : \"mouseleave\", function () {\n          3 !== B && n.setState(B);\n        });\n\n        n.setState = function (a) {\n          1 !== a && (n.state = B = a);\n          n.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass(\"highcharts-button-\" + [\"normal\", \"hover\", \"pressed\", \"disabled\"][a || 0]);\n          k || n.attr([z, h, l, c][a || 0]).css([J, M, L, x][a || 0]);\n        };\n\n        k || n.attr(z).css(p({\n          cursor: \"default\"\n        }, J));\n        return n.on(\"click\", function (a) {\n          3 !== B && u.call(n, a);\n        });\n      },\n      crispLine: function crispLine(a, b) {\n        a[1] === a[4] && (a[1] = a[4] = Math.round(a[1]) - b % 2 / 2);\n        a[2] === a[5] && (a[2] = a[5] = Math.round(a[2]) + b % 2 / 2);\n        return a;\n      },\n      path: function path(a) {\n        var b = this.styledMode ? {} : {\n          fill: \"none\"\n        };\n        y(a) ? b.d = a : v(a) && p(b, a);\n        return this.createElement(\"path\").attr(b);\n      },\n      circle: function circle(a, b, d) {\n        a = v(a) ? a : void 0 === a ? {} : {\n          x: a,\n          y: b,\n          r: d\n        };\n        b = this.createElement(\"circle\");\n\n        b.xSetter = b.ySetter = function (a, b, d) {\n          d.setAttribute(\"c\" + b, a);\n        };\n\n        return b.attr(a);\n      },\n      arc: function arc(a, b, d, e, u, z) {\n        v(a) ? (e = a, b = e.y, d = e.r, a = e.x) : e = {\n          innerR: e,\n          start: u,\n          end: z\n        };\n        a = this.symbol(\"arc\", a, b, d, d, e);\n        a.r = d;\n        return a;\n      },\n      rect: function rect(a, b, d, e, u, z) {\n        u = v(a) ? a.r : u;\n        var h = this.createElement(\"rect\");\n        a = v(a) ? a : void 0 === a ? {} : {\n          x: a,\n          y: b,\n          width: Math.max(d, 0),\n          height: Math.max(e, 0)\n        };\n        this.styledMode || (void 0 !== z && (a.strokeWidth = z, a = h.crisp(a)), a.fill = \"none\");\n        u && (a.r = u);\n\n        h.rSetter = function (a, b, d) {\n          h.r = a;\n          H(d, {\n            rx: a,\n            ry: a\n          });\n        };\n\n        h.rGetter = function () {\n          return h.r;\n        };\n\n        return h.attr(a);\n      },\n      setSize: function setSize(a, b, d) {\n        var e = this.alignedObjects,\n            u = e.length;\n        this.width = a;\n        this.height = b;\n\n        for (this.boxWrapper.animate({\n          width: a,\n          height: b\n        }, {\n          step: function step() {\n            this.attr({\n              viewBox: \"0 0 \" + this.attr(\"width\") + \" \" + this.attr(\"height\")\n            });\n          },\n          duration: m(d, !0) ? void 0 : 0\n        }); u--;) {\n          e[u].align();\n        }\n      },\n      g: function g(a) {\n        var b = this.createElement(\"g\");\n        return a ? b.attr({\n          \"class\": \"highcharts-\" + a\n        }) : b;\n      },\n      image: function image(a, b, d, u, z, h) {\n        var l = {\n          preserveAspectRatio: \"none\"\n        },\n            c = function c(a, b) {\n          a.setAttributeNS ? a.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", b) : a.setAttribute(\"hc-svg-href\", b);\n        },\n            t = function t(b) {\n          c(g.element, a);\n          h.call(g, b);\n        };\n\n        1 < arguments.length && p(l, {\n          x: b,\n          y: d,\n          width: u,\n          height: z\n        });\n        var g = this.createElement(\"image\").attr(l);\n        h ? (c(g.element, \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"), l = new R.Image(), e(l, \"load\", t), l.src = a, l.complete && t({})) : c(g.element, a);\n        return g;\n      },\n      symbol: function symbol(a, b, e, u, z, l) {\n        var c = this,\n            g = /^url\\((.*?)\\)$/,\n            t = g.test(a),\n            B = !t && (this.symbols[a] ? a : \"circle\"),\n            k = B && this.symbols[B],\n            M = D(b) && k && k.call(this.symbols, Math.round(b), Math.round(e), u, z, l);\n\n        if (k) {\n          var L = this.path(M);\n          c.styledMode || L.attr(\"fill\", \"none\");\n          p(L, {\n            symbolName: B,\n            x: b,\n            y: e,\n            width: u,\n            height: z\n          });\n          l && p(L, l);\n        } else if (t) {\n          var x = a.match(g)[1];\n          L = this.image(x);\n          L.imgwidth = m(Q[x] && Q[x].width, l && l.width);\n          L.imgheight = m(Q[x] && Q[x].height, l && l.height);\n\n          var J = function J() {\n            L.attr({\n              width: L.width,\n              height: L.height\n            });\n          };\n\n          [\"width\", \"height\"].forEach(function (a) {\n            L[a + \"Setter\"] = function (a, b) {\n              var d = {},\n                  e = this[\"img\" + b],\n                  u = \"width\" === b ? \"translateX\" : \"translateY\";\n              this[b] = a;\n              D(e) && (l && \"within\" === l.backgroundSize && this.width && this.height && (e = Math.round(e * Math.min(this.width / this.imgwidth, this.height / this.imgheight))), this.element && this.element.setAttribute(b, e), this.alignByTranslate || (d[u] = ((this[b] || 0) - e) / 2, this.attr(d)));\n            };\n          });\n          D(b) && L.attr({\n            x: b,\n            y: e\n          });\n          L.isImg = !0;\n          D(L.imgwidth) && D(L.imgheight) ? J() : (L.attr({\n            width: 0,\n            height: 0\n          }), n(\"img\", {\n            onload: function onload() {\n              var a = d[c.chartIndex];\n              0 === this.width && (h(this, {\n                position: \"absolute\",\n                top: \"-999em\"\n              }), r.body.appendChild(this));\n              Q[x] = {\n                width: this.width,\n                height: this.height\n              };\n              L.imgwidth = this.width;\n              L.imgheight = this.height;\n              L.element && J();\n              this.parentNode && this.parentNode.removeChild(this);\n              c.imgCount--;\n              if (!c.imgCount && a && a.onload) a.onload();\n            },\n            src: x\n          }), this.imgCount++);\n        }\n\n        return L;\n      },\n      symbols: {\n        circle: function circle(a, b, d, e) {\n          return this.arc(a + d / 2, b + e / 2, d / 2, e / 2, {\n            start: .5 * Math.PI,\n            end: 2.5 * Math.PI,\n            open: !1\n          });\n        },\n        square: function square(a, b, d, e) {\n          return [\"M\", a, b, \"L\", a + d, b, a + d, b + e, a, b + e, \"Z\"];\n        },\n        triangle: function triangle(a, b, d, e) {\n          return [\"M\", a + d / 2, b, \"L\", a + d, b + e, a, b + e, \"Z\"];\n        },\n        \"triangle-down\": function triangleDown(a, b, d, e) {\n          return [\"M\", a, b, \"L\", a + d, b, a + d / 2, b + e, \"Z\"];\n        },\n        diamond: function diamond(a, b, d, e) {\n          return [\"M\", a + d / 2, b, \"L\", a + d, b + e / 2, a + d / 2, b + e, a, b + e / 2, \"Z\"];\n        },\n        arc: function arc(a, b, d, e, u) {\n          var z = u.start,\n              h = u.r || d,\n              l = u.r || e || d,\n              c = u.end - .001;\n          d = u.innerR;\n          e = m(u.open, .001 > Math.abs(u.end - u.start - 2 * Math.PI));\n          var g = Math.cos(z),\n              t = Math.sin(z),\n              r = Math.cos(c);\n          c = Math.sin(c);\n          z = .001 > u.end - z - Math.PI ? 0 : 1;\n          u = [\"M\", a + h * g, b + l * t, \"A\", h, l, 0, z, m(u.clockwise, 1), a + h * r, b + l * c];\n          D(d) && u.push(e ? \"M\" : \"L\", a + d * r, b + d * c, \"A\", d, d, 0, z, 0, a + d * g, b + d * t);\n          u.push(e ? \"\" : \"Z\");\n          return u;\n        },\n        callout: function callout(a, b, d, e, u) {\n          var z = Math.min(u && u.r || 0, d, e),\n              h = z + 6,\n              l = u && u.anchorX;\n          u = u && u.anchorY;\n          var c = [\"M\", a + z, b, \"L\", a + d - z, b, \"C\", a + d, b, a + d, b, a + d, b + z, \"L\", a + d, b + e - z, \"C\", a + d, b + e, a + d, b + e, a + d - z, b + e, \"L\", a + z, b + e, \"C\", a, b + e, a, b + e, a, b + e - z, \"L\", a, b + z, \"C\", a, b, a, b, a + z, b];\n          l && l > d ? u > b + h && u < b + e - h ? c.splice(13, 3, \"L\", a + d, u - 6, a + d + 6, u, a + d, u + 6, a + d, b + e - z) : c.splice(13, 3, \"L\", a + d, e / 2, l, u, a + d, e / 2, a + d, b + e - z) : l && 0 > l ? u > b + h && u < b + e - h ? c.splice(33, 3, \"L\", a, u + 6, a - 6, u, a, u - 6, a, b + z) : c.splice(33, 3, \"L\", a, e / 2, l, u, a, e / 2, a, b + z) : u && u > e && l > a + h && l < a + d - h ? c.splice(23, 3, \"L\", l + 6, b + e, l, b + e + 6, l - 6, b + e, a + z, b + e) : u && 0 > u && l > a + h && l < a + d - h && c.splice(3, 3, \"L\", l - 6, b, l, b - 6, l + 6, b, d - z, b);\n          return c;\n        }\n      },\n      clipRect: function clipRect(a, b, d, e) {\n        var u = c.uniqueKey() + \"-\",\n            z = this.createElement(\"clipPath\").attr({\n          id: u\n        }).add(this.defs);\n        a = this.rect(a, b, d, e, 0).add(z);\n        a.id = u;\n        a.clipPath = z;\n        a.count = 0;\n        return a;\n      },\n      text: function text(a, b, d, e) {\n        var u = {};\n        if (e && (this.allowHTML || !this.forExport)) return this.html(a, b, d);\n        u.x = Math.round(b || 0);\n        d && (u.y = Math.round(d));\n        D(a) && (u.text = a);\n        a = this.createElement(\"text\").attr(u);\n        e || (a.xSetter = function (a, b, d) {\n          var e = d.getElementsByTagName(\"tspan\"),\n              u = d.getAttribute(b),\n              z;\n\n          for (z = 0; z < e.length; z++) {\n            var h = e[z];\n            h.getAttribute(b) === u && h.setAttribute(b, a);\n          }\n\n          d.setAttribute(b, a);\n        });\n        return a;\n      },\n      fontMetrics: function fontMetrics(a, b) {\n        a = !this.styledMode && /px/.test(a) || !R.getComputedStyle ? a || b && b.style && b.style.fontSize || this.style && this.style.fontSize : b && N.prototype.getStyle.call(b, \"font-size\");\n        a = /px/.test(a) ? w(a) : 12;\n        b = 24 > a ? a + 3 : Math.round(1.2 * a);\n        return {\n          h: b,\n          b: Math.round(.8 * b),\n          f: a\n        };\n      },\n      rotCorr: function rotCorr(a, b, d) {\n        var e = a;\n        b && d && (e = Math.max(e * Math.cos(b * F), 4));\n        return {\n          x: -a / 3 * Math.sin(b * F),\n          y: e\n        };\n      },\n      label: function label(a, b, d, e, z, h, l, c, g) {\n        var t = this,\n            r = t.styledMode,\n            n = t.g(\"button\" !== g && \"label\"),\n            B = n.text = t.text(\"\", 0, 0, l).attr({\n          zIndex: 1\n        }),\n            k,\n            L,\n            M = 0,\n            x = 3,\n            m = 0,\n            F,\n            J,\n            f,\n            w,\n            q,\n            O = {},\n            T,\n            y,\n            v = /^url\\((.*?)\\)$/.test(e),\n            W = r || v,\n            Q = function Q() {\n          return r ? k.strokeWidth() % 2 / 2 : (T ? parseInt(T, 10) : 0) % 2 / 2;\n        };\n\n        g && n.addClass(\"highcharts-\" + g);\n\n        var A = function A() {\n          var a = B.element.style,\n              b = {};\n          L = (void 0 === F || void 0 === J || q) && D(B.textStr) && B.getBBox();\n          n.width = (F || L.width || 0) + 2 * x + m;\n          n.height = (J || L.height || 0) + 2 * x;\n          y = x + Math.min(t.fontMetrics(a && a.fontSize, B).b, L ? L.height : Infinity);\n          W && (k || (n.box = k = t.symbols[e] || v ? t.symbol(e) : t.rect(), k.addClass((\"button\" === g ? \"\" : \"highcharts-label-box\") + (g ? \" highcharts-\" + g + \"-box\" : \"\")), k.add(n), a = Q(), b.x = a, b.y = (c ? -y : 0) + a), b.width = Math.round(n.width), b.height = Math.round(n.height), k.attr(p(b, O)), O = {});\n        };\n\n        var R = function R() {\n          var a = m + x;\n          var b = c ? 0 : y;\n          D(F) && L && (\"center\" === q || \"right\" === q) && (a += {\n            center: .5,\n            right: 1\n          }[q] * (F - L.width));\n          if (a !== B.x || b !== B.y) B.attr(\"x\", a), B.hasBoxWidthChanged && (L = B.getBBox(!0), A()), void 0 !== b && B.attr(\"y\", b);\n          B.x = a;\n          B.y = b;\n        };\n\n        var E = function E(a, b) {\n          k ? k.attr(a, b) : O[a] = b;\n        };\n\n        n.onAdd = function () {\n          B.add(n);\n          n.attr({\n            text: a || 0 === a ? a : \"\",\n            x: b,\n            y: d\n          });\n          k && D(z) && n.attr({\n            anchorX: z,\n            anchorY: h\n          });\n        };\n\n        n.widthSetter = function (a) {\n          F = G(a) ? a : null;\n        };\n\n        n.heightSetter = function (a) {\n          J = a;\n        };\n\n        n[\"text-alignSetter\"] = function (a) {\n          q = a;\n        };\n\n        n.paddingSetter = function (a) {\n          D(a) && a !== x && (x = n.padding = a, R());\n        };\n\n        n.paddingLeftSetter = function (a) {\n          D(a) && a !== m && (m = a, R());\n        };\n\n        n.alignSetter = function (a) {\n          a = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[a];\n          a !== M && (M = a, L && n.attr({\n            x: f\n          }));\n        };\n\n        n.textSetter = function (a) {\n          void 0 !== a && B.attr({\n            text: a\n          });\n          A();\n          R();\n        };\n\n        n[\"stroke-widthSetter\"] = function (a, b) {\n          a && (W = !0);\n          T = this[\"stroke-width\"] = a;\n          E(b, a);\n        };\n\n        r ? n.rSetter = function (a, b) {\n          E(b, a);\n        } : n.strokeSetter = n.fillSetter = n.rSetter = function (a, b) {\n          \"r\" !== b && (\"fill\" === b && a && (W = !0), n[b] = a);\n          E(b, a);\n        };\n\n        n.anchorXSetter = function (a, b) {\n          z = n.anchorX = a;\n          E(b, Math.round(a) - Q() - f);\n        };\n\n        n.anchorYSetter = function (a, b) {\n          h = n.anchorY = a;\n          E(b, a - w);\n        };\n\n        n.xSetter = function (a) {\n          n.x = a;\n          M && (a -= M * ((F || L.width) + 2 * x), n[\"forceAnimate:x\"] = !0);\n          f = Math.round(a);\n          n.attr(\"translateX\", f);\n        };\n\n        n.ySetter = function (a) {\n          w = n.y = Math.round(a);\n          n.attr(\"translateY\", w);\n        };\n\n        var S = n.css;\n        l = {\n          css: function css(a) {\n            if (a) {\n              var b = {};\n              a = I(a);\n              n.textProps.forEach(function (d) {\n                void 0 !== a[d] && (b[d] = a[d], delete a[d]);\n              });\n              B.css(b);\n              \"width\" in b && A();\n              \"fontSize\" in b && (A(), R());\n            }\n\n            return S.call(n, a);\n          },\n          getBBox: function getBBox() {\n            return {\n              width: L.width + 2 * x,\n              height: L.height + 2 * x,\n              x: L.x - x,\n              y: L.y - x\n            };\n          },\n          destroy: function destroy() {\n            u(n.element, \"mouseenter\");\n            u(n.element, \"mouseleave\");\n            B && (B = B.destroy());\n            k && (k = k.destroy());\n            N.prototype.destroy.call(n);\n            n = t = A = R = E = null;\n          }\n        };\n        r || (l.shadow = function (a) {\n          a && (A(), k && k.shadow(a));\n          return n;\n        });\n        return p(n, l);\n      }\n    });\n    c.Renderer = f;\n  });\n  K(C, \"parts/Html.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var H = f.attr,\n        D = f.defined,\n        A = f.extend,\n        E = f.pick,\n        p = f.pInt,\n        y = c.createElement,\n        G = c.css,\n        v = c.isFirefox,\n        q = c.isMS,\n        k = c.isWebKit,\n        m = c.SVGElement;\n    f = c.SVGRenderer;\n    var w = c.win;\n    A(m.prototype, {\n      htmlCss: function htmlCss(c) {\n        var e = \"SPAN\" === this.element.tagName && c && \"width\" in c,\n            b = E(e && c.width, void 0);\n\n        if (e) {\n          delete c.width;\n          this.textWidth = b;\n          var d = !0;\n        }\n\n        c && \"ellipsis\" === c.textOverflow && (c.whiteSpace = \"nowrap\", c.overflow = \"hidden\");\n        this.styles = A(this.styles, c);\n        G(this.element, c);\n        d && this.htmlUpdateTransform();\n        return this;\n      },\n      htmlGetBBox: function htmlGetBBox() {\n        var c = this.element;\n        return {\n          x: c.offsetLeft,\n          y: c.offsetTop,\n          width: c.offsetWidth,\n          height: c.offsetHeight\n        };\n      },\n      htmlUpdateTransform: function htmlUpdateTransform() {\n        if (this.added) {\n          var c = this.renderer,\n              e = this.element,\n              b = this.translateX || 0,\n              d = this.translateY || 0,\n              a = this.x || 0,\n              h = this.y || 0,\n              n = this.textAlign || \"left\",\n              k = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[n],\n              r = this.styles,\n              x = r && r.whiteSpace;\n          G(e, {\n            marginLeft: b,\n            marginTop: d\n          });\n          !c.styledMode && this.shadows && this.shadows.forEach(function (a) {\n            G(a, {\n              marginLeft: b + 1,\n              marginTop: d + 1\n            });\n          });\n          this.inverted && [].forEach.call(e.childNodes, function (a) {\n            c.invertChild(a, e);\n          });\n\n          if (\"SPAN\" === e.tagName) {\n            r = this.rotation;\n            var l = this.textWidth && p(this.textWidth),\n                t = [r, n, e.innerHTML, this.textWidth, this.textAlign].join(),\n                B;\n            (B = l !== this.oldTextWidth) && !(B = l > this.oldTextWidth) && ((B = this.textPxLength) || (G(e, {\n              width: \"\",\n              whiteSpace: x || \"nowrap\"\n            }), B = e.offsetWidth), B = B > l);\n            B && (/[ \\-]/.test(e.textContent || e.innerText) || \"ellipsis\" === e.style.textOverflow) ? (G(e, {\n              width: l + \"px\",\n              display: \"block\",\n              whiteSpace: x || \"normal\"\n            }), this.oldTextWidth = l, this.hasBoxWidthChanged = !0) : this.hasBoxWidthChanged = !1;\n            t !== this.cTT && (x = c.fontMetrics(e.style.fontSize, e).b, !D(r) || r === (this.oldRotation || 0) && n === this.oldAlign || this.setSpanRotation(r, k, x), this.getSpanCorrection(!D(r) && this.textPxLength || e.offsetWidth, x, k, r, n));\n            G(e, {\n              left: a + (this.xCorr || 0) + \"px\",\n              top: h + (this.yCorr || 0) + \"px\"\n            });\n            this.cTT = t;\n            this.oldRotation = r;\n            this.oldAlign = n;\n          }\n        } else this.alignOnAdd = !0;\n      },\n      setSpanRotation: function setSpanRotation(c, e, b) {\n        var d = {},\n            a = this.renderer.getTransformKey();\n        d[a] = d.transform = \"rotate(\" + c + \"deg)\";\n        d[a + (v ? \"Origin\" : \"-origin\")] = d.transformOrigin = 100 * e + \"% \" + b + \"px\";\n        G(this.element, d);\n      },\n      getSpanCorrection: function getSpanCorrection(c, e, b) {\n        this.xCorr = -c * b;\n        this.yCorr = -e;\n      }\n    });\n    A(f.prototype, {\n      getTransformKey: function getTransformKey() {\n        return q && !/Edge/.test(w.navigator.userAgent) ? \"-ms-transform\" : k ? \"-webkit-transform\" : v ? \"MozTransform\" : w.opera ? \"-o-transform\" : \"\";\n      },\n      html: function html(c, e, b) {\n        var d = this.createElement(\"span\"),\n            a = d.element,\n            h = d.renderer,\n            n = h.isSVG,\n            g = function g(a, b) {\n          [\"opacity\", \"visibility\"].forEach(function (d) {\n            a[d + \"Setter\"] = function (e, h, l) {\n              var z = a.div ? a.div.style : b;\n              m.prototype[d + \"Setter\"].call(this, e, h, l);\n              z && (z[h] = e);\n            };\n          });\n          a.addedSetters = !0;\n        };\n\n        d.textSetter = function (b) {\n          b !== a.innerHTML && (delete this.bBox, delete this.oldTextWidth);\n          this.textStr = b;\n          a.innerHTML = E(b, \"\");\n          d.doTransform = !0;\n        };\n\n        n && g(d, d.element.style);\n\n        d.xSetter = d.ySetter = d.alignSetter = d.rotationSetter = function (a, b) {\n          \"align\" === b && (b = \"textAlign\");\n          d[b] = a;\n          d.doTransform = !0;\n        };\n\n        d.afterSetters = function () {\n          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);\n        };\n\n        d.attr({\n          text: c,\n          x: Math.round(e),\n          y: Math.round(b)\n        }).css({\n          position: \"absolute\"\n        });\n        h.styledMode || d.css({\n          fontFamily: this.style.fontFamily,\n          fontSize: this.style.fontSize\n        });\n        a.style.whiteSpace = \"nowrap\";\n        d.css = d.htmlCss;\n        n && (d.add = function (b) {\n          var e = h.box.parentNode,\n              l = [];\n\n          if (this.parentGroup = b) {\n            var c = b.div;\n\n            if (!c) {\n              for (; b;) {\n                l.push(b), b = b.parentGroup;\n              }\n\n              l.reverse().forEach(function (a) {\n                function b(b, d) {\n                  a[d] = b;\n                  \"translateX\" === d ? u.left = b + \"px\" : u.top = b + \"px\";\n                  a.doTransform = !0;\n                }\n\n                var z = H(a.element, \"class\");\n                c = a.div = a.div || y(\"div\", z ? {\n                  className: z\n                } : void 0, {\n                  position: \"absolute\",\n                  left: (a.translateX || 0) + \"px\",\n                  top: (a.translateY || 0) + \"px\",\n                  display: a.display,\n                  opacity: a.opacity,\n                  pointerEvents: a.styles && a.styles.pointerEvents\n                }, c || e);\n                var u = c.style;\n                A(a, {\n                  classSetter: function (a) {\n                    return function (b) {\n                      this.element.setAttribute(\"class\", b);\n                      a.className = b;\n                    };\n                  }(c),\n                  on: function on() {\n                    l[0].div && d.on.apply({\n                      element: l[0].div\n                    }, arguments);\n                    return a;\n                  },\n                  translateXSetter: b,\n                  translateYSetter: b\n                });\n                a.addedSetters || g(a);\n              });\n            }\n          } else c = e;\n\n          c.appendChild(a);\n          d.added = !0;\n          d.alignOnAdd && d.htmlUpdateTransform();\n          return d;\n        });\n        return d;\n      }\n    });\n  });\n  K(C, \"parts/Time.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var H = f.defined,\n        D = f.extend,\n        A = f.isObject,\n        E = f.objectEach,\n        p = f.pick,\n        y = f.splat,\n        G = c.merge,\n        v = c.timeUnits,\n        q = c.win;\n\n    c.Time = function (c) {\n      this.update(c, !1);\n    };\n\n    c.Time.prototype = {\n      defaultOptions: {\n        Date: void 0,\n        getTimezoneOffset: void 0,\n        timezone: void 0,\n        timezoneOffset: 0,\n        useUTC: !0\n      },\n      update: function update(c) {\n        var k = p(c && c.useUTC, !0),\n            f = this;\n        this.options = c = G(!0, this.options || {}, c);\n        this.Date = c.Date || q.Date || Date;\n        this.timezoneOffset = (this.useUTC = k) && c.timezoneOffset;\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        (this.variableTimezone = !(k && !c.getTimezoneOffset && !c.timezone)) || this.timezoneOffset ? (this.get = function (c, e) {\n          var b = e.getTime(),\n              d = b - f.getTimezoneOffset(e);\n          e.setTime(d);\n          c = e[\"getUTC\" + c]();\n          e.setTime(b);\n          return c;\n        }, this.set = function (c, e, b) {\n          if (\"Milliseconds\" === c || \"Seconds\" === c || \"Minutes\" === c && 0 === e.getTimezoneOffset() % 60) e[\"set\" + c](b);else {\n            var d = f.getTimezoneOffset(e);\n            d = e.getTime() - d;\n            e.setTime(d);\n            e[\"setUTC\" + c](b);\n            c = f.getTimezoneOffset(e);\n            d = e.getTime() + c;\n            e.setTime(d);\n          }\n        }) : k ? (this.get = function (c, e) {\n          return e[\"getUTC\" + c]();\n        }, this.set = function (c, e, b) {\n          return e[\"setUTC\" + c](b);\n        }) : (this.get = function (c, e) {\n          return e[\"get\" + c]();\n        }, this.set = function (c, e, b) {\n          return e[\"set\" + c](b);\n        });\n      },\n      makeTime: function makeTime(k, m, f, g, e, b) {\n        if (this.useUTC) {\n          var d = this.Date.UTC.apply(0, arguments);\n          var a = this.getTimezoneOffset(d);\n          d += a;\n          var h = this.getTimezoneOffset(d);\n          a !== h ? d += h - a : a - 36E5 !== this.getTimezoneOffset(d - 36E5) || c.isSafari || (d -= 36E5);\n        } else d = new this.Date(k, m, p(f, 1), p(g, 0), p(e, 0), p(b, 0)).getTime();\n\n        return d;\n      },\n      timezoneOffsetFunction: function timezoneOffsetFunction() {\n        var k = this,\n            m = this.options,\n            f = q.moment;\n        if (!this.useUTC) return function (c) {\n          return 6E4 * new Date(c).getTimezoneOffset();\n        };\n\n        if (m.timezone) {\n          if (f) return function (c) {\n            return 6E4 * -f.tz(c, m.timezone).utcOffset();\n          };\n          c.error(25);\n        }\n\n        return this.useUTC && m.getTimezoneOffset ? function (c) {\n          return 6E4 * m.getTimezoneOffset(c);\n        } : function () {\n          return 6E4 * (k.timezoneOffset || 0);\n        };\n      },\n      dateFormat: function dateFormat(k, m, f) {\n        if (!H(m) || isNaN(m)) return c.defaultOptions.lang.invalidDate || \"\";\n        k = p(k, \"%Y-%m-%d %H:%M:%S\");\n        var g = this,\n            e = new this.Date(m),\n            b = this.get(\"Hours\", e),\n            d = this.get(\"Day\", e),\n            a = this.get(\"Date\", e),\n            h = this.get(\"Month\", e),\n            n = this.get(\"FullYear\", e),\n            F = c.defaultOptions.lang,\n            r = F.weekdays,\n            x = F.shortWeekdays,\n            l = c.pad;\n        e = D({\n          a: x ? x[d] : r[d].substr(0, 3),\n          A: r[d],\n          d: l(a),\n          e: l(a, 2, \" \"),\n          w: d,\n          b: F.shortMonths[h],\n          B: F.months[h],\n          m: l(h + 1),\n          o: h + 1,\n          y: n.toString().substr(2, 2),\n          Y: n,\n          H: l(b),\n          k: b,\n          I: l(b % 12 || 12),\n          l: b % 12 || 12,\n          M: l(g.get(\"Minutes\", e)),\n          p: 12 > b ? \"AM\" : \"PM\",\n          P: 12 > b ? \"am\" : \"pm\",\n          S: l(e.getSeconds()),\n          L: l(Math.floor(m % 1E3), 3)\n        }, c.dateFormats);\n        E(e, function (a, b) {\n          for (; -1 !== k.indexOf(\"%\" + b);) {\n            k = k.replace(\"%\" + b, \"function\" === typeof a ? a.call(g, m) : a);\n          }\n        });\n        return f ? k.substr(0, 1).toUpperCase() + k.substr(1) : k;\n      },\n      resolveDTLFormat: function resolveDTLFormat(c) {\n        return A(c, !0) ? c : (c = y(c), {\n          main: c[0],\n          from: c[1],\n          to: c[2]\n        });\n      },\n      getTimeTicks: function getTimeTicks(c, m, f, g) {\n        var e = this,\n            b = [],\n            d = {};\n        var a = new e.Date(m);\n        var h = c.unitRange,\n            n = c.count || 1,\n            k;\n        g = p(g, 1);\n\n        if (H(m)) {\n          e.set(\"Milliseconds\", a, h >= v.second ? 0 : n * Math.floor(e.get(\"Milliseconds\", a) / n));\n          h >= v.second && e.set(\"Seconds\", a, h >= v.minute ? 0 : n * Math.floor(e.get(\"Seconds\", a) / n));\n          h >= v.minute && e.set(\"Minutes\", a, h >= v.hour ? 0 : n * Math.floor(e.get(\"Minutes\", a) / n));\n          h >= v.hour && e.set(\"Hours\", a, h >= v.day ? 0 : n * Math.floor(e.get(\"Hours\", a) / n));\n          h >= v.day && e.set(\"Date\", a, h >= v.month ? 1 : Math.max(1, n * Math.floor(e.get(\"Date\", a) / n)));\n\n          if (h >= v.month) {\n            e.set(\"Month\", a, h >= v.year ? 0 : n * Math.floor(e.get(\"Month\", a) / n));\n            var r = e.get(\"FullYear\", a);\n          }\n\n          h >= v.year && e.set(\"FullYear\", a, r - r % n);\n          h === v.week && (r = e.get(\"Day\", a), e.set(\"Date\", a, e.get(\"Date\", a) - r + g + (r < g ? -7 : 0)));\n          r = e.get(\"FullYear\", a);\n          g = e.get(\"Month\", a);\n          var x = e.get(\"Date\", a),\n              l = e.get(\"Hours\", a);\n          m = a.getTime();\n          e.variableTimezone && (k = f - m > 4 * v.month || e.getTimezoneOffset(m) !== e.getTimezoneOffset(f));\n          m = a.getTime();\n\n          for (a = 1; m < f;) {\n            b.push(m), m = h === v.year ? e.makeTime(r + a * n, 0) : h === v.month ? e.makeTime(r, g + a * n) : !k || h !== v.day && h !== v.week ? k && h === v.hour && 1 < n ? e.makeTime(r, g, x, l + a * n) : m + h * n : e.makeTime(r, g, x + a * n * (h === v.day ? 1 : 7)), a++;\n          }\n\n          b.push(m);\n          h <= v.hour && 1E4 > b.length && b.forEach(function (a) {\n            0 === a % 18E5 && \"000000000\" === e.dateFormat(\"%H%M%S%L\", a) && (d[a] = \"day\");\n          });\n        }\n\n        b.info = D(c, {\n          higherRanks: d,\n          totalRange: h * n\n        });\n        return b;\n      }\n    };\n  });\n  K(C, \"parts/Options.js\", [C[\"parts/Globals.js\"]], function (c) {\n    var f = c.color,\n        H = c.merge;\n    c.defaultOptions = {\n      colors: \"#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1\".split(\" \"),\n      symbols: [\"circle\", \"diamond\", \"square\", \"triangle\", \"triangle-down\"],\n      lang: {\n        loading: \"Loading...\",\n        months: \"January February March April May June July August September October November December\".split(\" \"),\n        shortMonths: \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"),\n        weekdays: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\n        decimalPoint: \".\",\n        numericSymbols: \"kMGTPE\".split(\"\"),\n        resetZoom: \"Reset zoom\",\n        resetZoomTitle: \"Reset zoom level 1:1\",\n        thousandsSep: \" \"\n      },\n      global: {},\n      time: c.Time.prototype.defaultOptions,\n      chart: {\n        styledMode: !1,\n        borderRadius: 0,\n        colorCount: 10,\n        defaultSeriesType: \"line\",\n        ignoreHiddenSeries: !0,\n        spacing: [10, 10, 15, 10],\n        resetZoomButton: {\n          theme: {\n            zIndex: 6\n          },\n          position: {\n            align: \"right\",\n            x: -10,\n            y: 10\n          }\n        },\n        width: null,\n        height: null,\n        borderColor: \"#335cad\",\n        backgroundColor: \"#ffffff\",\n        plotBorderColor: \"#cccccc\"\n      },\n      title: {\n        text: \"Chart title\",\n        align: \"center\",\n        margin: 15,\n        widthAdjust: -44\n      },\n      subtitle: {\n        text: \"\",\n        align: \"center\",\n        widthAdjust: -44\n      },\n      caption: {\n        margin: 15,\n        text: \"\",\n        align: \"left\",\n        verticalAlign: \"bottom\"\n      },\n      plotOptions: {},\n      labels: {\n        style: {\n          position: \"absolute\",\n          color: \"#333333\"\n        }\n      },\n      legend: {\n        enabled: !0,\n        align: \"center\",\n        alignColumns: !0,\n        layout: \"horizontal\",\n        labelFormatter: function labelFormatter() {\n          return this.name;\n        },\n        borderColor: \"#999999\",\n        borderRadius: 0,\n        navigation: {\n          activeColor: \"#003399\",\n          inactiveColor: \"#cccccc\"\n        },\n        itemStyle: {\n          color: \"#333333\",\n          cursor: \"pointer\",\n          fontSize: \"12px\",\n          fontWeight: \"bold\",\n          textOverflow: \"ellipsis\"\n        },\n        itemHoverStyle: {\n          color: \"#000000\"\n        },\n        itemHiddenStyle: {\n          color: \"#cccccc\"\n        },\n        shadow: !1,\n        itemCheckboxStyle: {\n          position: \"absolute\",\n          width: \"13px\",\n          height: \"13px\"\n        },\n        squareSymbol: !0,\n        symbolPadding: 5,\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0,\n        title: {\n          style: {\n            fontWeight: \"bold\"\n          }\n        }\n      },\n      loading: {\n        labelStyle: {\n          fontWeight: \"bold\",\n          position: \"relative\",\n          top: \"45%\"\n        },\n        style: {\n          position: \"absolute\",\n          backgroundColor: \"#ffffff\",\n          opacity: .5,\n          textAlign: \"center\"\n        }\n      },\n      tooltip: {\n        enabled: !0,\n        animation: c.svg,\n        borderRadius: 3,\n        dateTimeLabelFormats: {\n          millisecond: \"%A, %b %e, %H:%M:%S.%L\",\n          second: \"%A, %b %e, %H:%M:%S\",\n          minute: \"%A, %b %e, %H:%M\",\n          hour: \"%A, %b %e, %H:%M\",\n          day: \"%A, %b %e, %Y\",\n          week: \"Week from %A, %b %e, %Y\",\n          month: \"%B %Y\",\n          year: \"%Y\"\n        },\n        footerFormat: \"\",\n        padding: 8,\n        snap: c.isTouchDevice ? 25 : 10,\n        headerFormat: '<span style=\"font-size: 10px\">{point.key}</span><br/>',\n        pointFormat: \"<span style=\\\"color:{point.color}\\\">\\u25CF</span> {series.name}: <b>{point.y}</b><br/>\",\n        backgroundColor: f(\"#f7f7f7\").setOpacity(.85).get(),\n        borderWidth: 1,\n        shadow: !0,\n        style: {\n          color: \"#333333\",\n          cursor: \"default\",\n          fontSize: \"12px\",\n          pointerEvents: \"none\",\n          whiteSpace: \"nowrap\"\n        }\n      },\n      credits: {\n        enabled: !0,\n        href: \"https://www.highcharts.com?credits\",\n        position: {\n          align: \"right\",\n          x: -10,\n          verticalAlign: \"bottom\",\n          y: -5\n        },\n        style: {\n          cursor: \"pointer\",\n          color: \"#999999\",\n          fontSize: \"9px\"\n        },\n        text: \"Highcharts.com\"\n      }\n    };\n\n    c.setOptions = function (f) {\n      c.defaultOptions = H(!0, c.defaultOptions, f);\n      (f.time || f.global) && c.time.update(H(c.defaultOptions.global, c.defaultOptions.time, f.global, f.time));\n      return c.defaultOptions;\n    };\n\n    c.getOptions = function () {\n      return c.defaultOptions;\n    };\n\n    c.defaultPlotOptions = c.defaultOptions.plotOptions;\n    c.time = new c.Time(H(c.defaultOptions.global, c.defaultOptions.time));\n\n    c.dateFormat = function (f, A, E) {\n      return c.time.dateFormat(f, A, E);\n    };\n\n    \"\";\n  });\n  K(C, \"parts/Tick.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var H = f.defined,\n        D = f.destroyObjectProperties,\n        A = f.extend,\n        E = f.isNumber,\n        p = f.pick,\n        y = c.correctFloat,\n        G = c.fireEvent,\n        v = c.merge,\n        q = c.deg2rad;\n\n    c.Tick = function (c, m, f, g, e) {\n      this.axis = c;\n      this.pos = m;\n      this.type = f || \"\";\n      this.isNewLabel = this.isNew = !0;\n      this.parameters = e || {};\n      this.tickmarkOffset = this.parameters.tickmarkOffset;\n      this.options = this.parameters.options;\n      f || g || this.addLabel();\n    };\n\n    c.Tick.prototype = {\n      addLabel: function addLabel() {\n        var c = this,\n            m = c.axis,\n            f = m.options,\n            g = m.chart,\n            e = m.categories,\n            b = m.names,\n            d = c.pos,\n            a = p(c.options && c.options.labels, f.labels),\n            h = m.tickPositions,\n            n = d === h[0],\n            F = d === h[h.length - 1];\n        e = this.parameters.category || (e ? p(e[d], b[d], d) : d);\n        var r = c.label;\n        h = h.info;\n        var x, l;\n\n        if (m.isDatetimeAxis && h) {\n          var t = g.time.resolveDTLFormat(f.dateTimeLabelFormats[!f.grid && h.higherRanks[d] || h.unitName]);\n          var B = t.main;\n        }\n\n        c.isFirst = n;\n        c.isLast = F;\n        c.formatCtx = {\n          axis: m,\n          chart: g,\n          isFirst: n,\n          isLast: F,\n          dateTimeLabelFormat: B,\n          tickPositionInfo: h,\n          value: m.isLog ? y(m.lin2log(e)) : e,\n          pos: d\n        };\n        f = m.labelFormatter.call(c.formatCtx, this.formatCtx);\n        if (l = t && t.list) c.shortenLabel = function () {\n          for (x = 0; x < l.length; x++) {\n            if (r.attr({\n              text: m.labelFormatter.call(A(c.formatCtx, {\n                dateTimeLabelFormat: l[x]\n              }))\n            }), r.getBBox().width < m.getSlotWidth(c) - 2 * p(a.padding, 5)) return;\n          }\n\n          r.attr({\n            text: \"\"\n          });\n        };\n        if (H(r)) r && r.textStr !== f && (!r.textWidth || a.style && a.style.width || r.styles.width || r.css({\n          width: null\n        }), r.attr({\n          text: f\n        }), r.textPxLength = r.getBBox().width);else {\n          if (c.label = r = H(f) && a.enabled ? g.renderer.text(f, 0, 0, a.useHTML).add(m.labelGroup) : null) g.styledMode || r.css(v(a.style)), r.textPxLength = r.getBBox().width;\n          c.rotation = 0;\n        }\n      },\n      getLabelSize: function getLabelSize() {\n        return this.label ? this.label.getBBox()[this.axis.horiz ? \"height\" : \"width\"] : 0;\n      },\n      handleOverflow: function handleOverflow(c) {\n        var k = this.axis,\n            f = k.options.labels,\n            g = c.x,\n            e = k.chart.chartWidth,\n            b = k.chart.spacing,\n            d = p(k.labelLeft, Math.min(k.pos, b[3]));\n        b = p(k.labelRight, Math.max(k.isRadial ? 0 : k.pos + k.len, e - b[1]));\n        var a = this.label,\n            h = this.rotation,\n            n = {\n          left: 0,\n          center: .5,\n          right: 1\n        }[k.labelAlign || a.attr(\"align\")],\n            F = a.getBBox().width,\n            r = k.getSlotWidth(this),\n            x = r,\n            l = 1,\n            t,\n            B = {};\n        if (h || \"justify\" !== p(f.overflow, \"justify\")) 0 > h && g - n * F < d ? t = Math.round(g / Math.cos(h * q) - d) : 0 < h && g + n * F > b && (t = Math.round((e - g) / Math.cos(h * q)));else if (e = g + (1 - n) * F, g - n * F < d ? x = c.x + x * (1 - n) - d : e > b && (x = b - c.x + x * n, l = -1), x = Math.min(r, x), x < r && \"center\" === k.labelAlign && (c.x += l * (r - x - n * (r - Math.min(F, x)))), F > x || k.autoRotation && (a.styles || {}).width) t = x;\n        t && (this.shortenLabel ? this.shortenLabel() : (B.width = Math.floor(t), (f.style || {}).textOverflow || (B.textOverflow = \"ellipsis\"), a.css(B)));\n      },\n      getPosition: function getPosition(k, m, f, g) {\n        var e = this.axis,\n            b = e.chart,\n            d = g && b.oldChartHeight || b.chartHeight;\n        k = {\n          x: k ? c.correctFloat(e.translate(m + f, null, null, g) + e.transB) : e.left + e.offset + (e.opposite ? (g && b.oldChartWidth || b.chartWidth) - e.right - e.left : 0),\n          y: k ? d - e.bottom + e.offset - (e.opposite ? e.height : 0) : c.correctFloat(d - e.translate(m + f, null, null, g) - e.transB)\n        };\n        k.y = Math.max(Math.min(k.y, 1E5), -1E5);\n        G(this, \"afterGetPosition\", {\n          pos: k\n        });\n        return k;\n      },\n      getLabelPosition: function getLabelPosition(c, m, f, g, e, b, d, a) {\n        var h = this.axis,\n            n = h.transA,\n            k = h.isLinked && h.linkedParent ? h.linkedParent.reversed : h.reversed,\n            r = h.staggerLines,\n            x = h.tickRotCorr || {\n          x: 0,\n          y: 0\n        },\n            l = e.y,\n            t = g || h.reserveSpaceDefault ? 0 : -h.labelOffset * (\"center\" === h.labelAlign ? .5 : 1),\n            B = {};\n        H(l) || (l = 0 === h.side ? f.rotation ? -8 : -f.getBBox().height : 2 === h.side ? x.y + 8 : Math.cos(f.rotation * q) * (x.y - f.getBBox(!1, 0).height / 2));\n        c = c + e.x + t + x.x - (b && g ? b * n * (k ? -1 : 1) : 0);\n        m = m + l - (b && !g ? b * n * (k ? 1 : -1) : 0);\n        r && (f = d / (a || 1) % r, h.opposite && (f = r - f - 1), m += h.labelOffset / r * f);\n        B.x = c;\n        B.y = Math.round(m);\n        G(this, \"afterGetLabelPosition\", {\n          pos: B,\n          tickmarkOffset: b,\n          index: d\n        });\n        return B;\n      },\n      getMarkPath: function getMarkPath(c, m, f, g, e, b) {\n        return b.crispLine([\"M\", c, m, \"L\", c + (e ? 0 : -f), m + (e ? f : 0)], g);\n      },\n      renderGridLine: function renderGridLine(c, m, f) {\n        var g = this.axis,\n            e = g.options,\n            b = this.gridLine,\n            d = {},\n            a = this.pos,\n            h = this.type,\n            n = p(this.tickmarkOffset, g.tickmarkOffset),\n            k = g.chart.renderer,\n            r = h ? h + \"Grid\" : \"grid\",\n            x = e[r + \"LineWidth\"],\n            l = e[r + \"LineColor\"];\n        e = e[r + \"LineDashStyle\"];\n        b || (g.chart.styledMode || (d.stroke = l, d[\"stroke-width\"] = x, e && (d.dashstyle = e)), h || (d.zIndex = 1), c && (m = 0), this.gridLine = b = k.path().attr(d).addClass(\"highcharts-\" + (h ? h + \"-\" : \"\") + \"grid-line\").add(g.gridGroup));\n        if (b && (f = g.getPlotLinePath({\n          value: a + n,\n          lineWidth: b.strokeWidth() * f,\n          force: \"pass\",\n          old: c\n        }))) b[c || this.isNew ? \"attr\" : \"animate\"]({\n          d: f,\n          opacity: m\n        });\n      },\n      renderMark: function renderMark(c, m, f) {\n        var g = this.axis,\n            e = g.options,\n            b = g.chart.renderer,\n            d = this.type,\n            a = d ? d + \"Tick\" : \"tick\",\n            h = g.tickSize(a),\n            n = this.mark,\n            k = !n,\n            r = c.x;\n        c = c.y;\n        var x = p(e[a + \"Width\"], !d && g.isXAxis ? 1 : 0);\n        e = e[a + \"Color\"];\n        h && (g.opposite && (h[0] = -h[0]), k && (this.mark = n = b.path().addClass(\"highcharts-\" + (d ? d + \"-\" : \"\") + \"tick\").add(g.axisGroup), g.chart.styledMode || n.attr({\n          stroke: e,\n          \"stroke-width\": x\n        })), n[k ? \"attr\" : \"animate\"]({\n          d: this.getMarkPath(r, c, h[0], n.strokeWidth() * f, g.horiz, b),\n          opacity: m\n        }));\n      },\n      renderLabel: function renderLabel(c, m, f, g) {\n        var e = this.axis,\n            b = e.horiz,\n            d = e.options,\n            a = this.label,\n            h = d.labels,\n            n = h.step;\n        e = p(this.tickmarkOffset, e.tickmarkOffset);\n        var k = !0,\n            r = c.x;\n        c = c.y;\n        a && E(r) && (a.xy = c = this.getLabelPosition(r, c, a, b, h, e, g, n), this.isFirst && !this.isLast && !p(d.showFirstLabel, 1) || this.isLast && !this.isFirst && !p(d.showLastLabel, 1) ? k = !1 : !b || h.step || h.rotation || m || 0 === f || this.handleOverflow(c), n && g % n && (k = !1), k && E(c.y) ? (c.opacity = f, a[this.isNewLabel ? \"attr\" : \"animate\"](c), this.isNewLabel = !1) : (a.attr(\"y\", -9999), this.isNewLabel = !0));\n      },\n      render: function render(k, f, q) {\n        var g = this.axis,\n            e = g.horiz,\n            b = this.pos,\n            d = p(this.tickmarkOffset, g.tickmarkOffset);\n        b = this.getPosition(e, b, d, f);\n        d = b.x;\n        var a = b.y;\n        g = e && d === g.pos + g.len || !e && a === g.pos ? -1 : 1;\n        q = p(q, 1);\n        this.isActive = !0;\n        this.renderGridLine(f, q, g);\n        this.renderMark(b, q, g);\n        this.renderLabel(b, f, q, k);\n        this.isNew = !1;\n        c.fireEvent(this, \"afterRender\");\n      },\n      destroy: function destroy() {\n        D(this, this.axis);\n      }\n    };\n  });\n  K(C, \"parts/Axis.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var H = f.arrayMax,\n        D = f.arrayMin,\n        A = f.defined,\n        E = f.destroyObjectProperties,\n        p = f.extend,\n        y = f.isArray,\n        G = f.isNumber,\n        v = f.isString,\n        q = f.objectEach,\n        k = f.pick,\n        m = f.splat,\n        w = f.syncTimeout,\n        g = c.addEvent,\n        e = c.animObject,\n        b = c.color,\n        d = c.correctFloat,\n        a = c.defaultOptions,\n        h = c.deg2rad,\n        n = c.fireEvent,\n        F = c.format,\n        r = c.getMagnitude,\n        x = c.merge,\n        l = c.normalizeTickInterval,\n        t = c.removeEvent,\n        B = c.seriesTypes,\n        I = c.Tick;\n\n    f = function f() {\n      this.init.apply(this, arguments);\n    };\n\n    p(f.prototype, {\n      defaultOptions: {\n        dateTimeLabelFormats: {\n          millisecond: {\n            main: \"%H:%M:%S.%L\",\n            range: !1\n          },\n          second: {\n            main: \"%H:%M:%S\",\n            range: !1\n          },\n          minute: {\n            main: \"%H:%M\",\n            range: !1\n          },\n          hour: {\n            main: \"%H:%M\",\n            range: !1\n          },\n          day: {\n            main: \"%e. %b\"\n          },\n          week: {\n            main: \"%e. %b\"\n          },\n          month: {\n            main: \"%b '%y\"\n          },\n          year: {\n            main: \"%Y\"\n          }\n        },\n        endOnTick: !1,\n        labels: {\n          enabled: !0,\n          indentation: 10,\n          x: 0,\n          style: {\n            color: \"#666666\",\n            cursor: \"default\",\n            fontSize: \"11px\"\n          }\n        },\n        maxPadding: .01,\n        minorTickLength: 2,\n        minorTickPosition: \"outside\",\n        minPadding: .01,\n        showEmpty: !0,\n        startOfWeek: 1,\n        startOnTick: !1,\n        tickLength: 10,\n        tickPixelInterval: 100,\n        tickmarkPlacement: \"between\",\n        tickPosition: \"outside\",\n        title: {\n          align: \"middle\",\n          style: {\n            color: \"#666666\"\n          }\n        },\n        type: \"linear\",\n        minorGridLineColor: \"#f2f2f2\",\n        minorGridLineWidth: 1,\n        minorTickColor: \"#999999\",\n        lineColor: \"#ccd6eb\",\n        lineWidth: 1,\n        gridLineColor: \"#e6e6e6\",\n        tickColor: \"#ccd6eb\"\n      },\n      defaultYAxisOptions: {\n        endOnTick: !0,\n        maxPadding: .05,\n        minPadding: .05,\n        tickPixelInterval: 72,\n        showLastLabel: !0,\n        labels: {\n          x: -8\n        },\n        startOnTick: !0,\n        title: {\n          rotation: 270,\n          text: \"Values\"\n        },\n        stackLabels: {\n          allowOverlap: !1,\n          enabled: !1,\n          crop: !0,\n          overflow: \"justify\",\n          formatter: function formatter() {\n            return c.numberFormat(this.total, -1);\n          },\n          style: {\n            color: \"#000000\",\n            fontSize: \"11px\",\n            fontWeight: \"bold\",\n            textOutline: \"1px contrast\"\n          }\n        },\n        gridLineWidth: 1,\n        lineWidth: 0\n      },\n      defaultLeftAxisOptions: {\n        labels: {\n          x: -15\n        },\n        title: {\n          rotation: 270\n        }\n      },\n      defaultRightAxisOptions: {\n        labels: {\n          x: 15\n        },\n        title: {\n          rotation: 90\n        }\n      },\n      defaultBottomAxisOptions: {\n        labels: {\n          autoRotation: [-45],\n          x: 0\n        },\n        margin: 15,\n        title: {\n          rotation: 0\n        }\n      },\n      defaultTopAxisOptions: {\n        labels: {\n          autoRotation: [-45],\n          x: 0\n        },\n        margin: 15,\n        title: {\n          rotation: 0\n        }\n      },\n      init: function init(a, b) {\n        var d = b.isX,\n            e = this;\n        e.chart = a;\n        e.horiz = a.inverted && !e.isZAxis ? !d : d;\n        e.isXAxis = d;\n        e.coll = e.coll || (d ? \"xAxis\" : \"yAxis\");\n        n(this, \"init\", {\n          userOptions: b\n        });\n        e.opposite = b.opposite;\n        e.side = b.side || (e.horiz ? e.opposite ? 0 : 2 : e.opposite ? 1 : 3);\n        e.setOptions(b);\n        var u = this.options,\n            z = u.type;\n        e.labelFormatter = u.labels.formatter || e.defaultLabelFormatter;\n        e.userOptions = b;\n        e.minPixelPadding = 0;\n        e.reversed = u.reversed;\n        e.visible = !1 !== u.visible;\n        e.zoomEnabled = !1 !== u.zoomEnabled;\n        e.hasNames = \"category\" === z || !0 === u.categories;\n        e.categories = u.categories || e.hasNames;\n        e.names || (e.names = [], e.names.keys = {});\n        e.plotLinesAndBandsGroups = {};\n        e.isLog = \"logarithmic\" === z;\n        e.isDatetimeAxis = \"datetime\" === z;\n        e.positiveValuesOnly = e.isLog && !e.allowNegativeLog;\n        e.isLinked = A(u.linkedTo);\n        e.ticks = {};\n        e.labelEdge = [];\n        e.minorTicks = {};\n        e.plotLinesAndBands = [];\n        e.alternateBands = {};\n        e.len = 0;\n        e.minRange = e.userMinRange = u.minRange || u.maxZoom;\n        e.range = u.range;\n        e.offset = u.offset || 0;\n        e.stacks = {};\n        e.oldStacks = {};\n        e.stacksTouched = 0;\n        e.max = null;\n        e.min = null;\n        e.crosshair = k(u.crosshair, m(a.options.tooltip.crosshairs)[d ? 0 : 1], !1);\n        b = e.options.events;\n        -1 === a.axes.indexOf(e) && (d ? a.axes.splice(a.xAxis.length, 0, e) : a.axes.push(e), a[e.coll].push(e));\n        e.series = e.series || [];\n        a.inverted && !e.isZAxis && d && void 0 === e.reversed && (e.reversed = !0);\n        q(b, function (a, b) {\n          c.isFunction(a) && g(e, b, a);\n        });\n        e.lin2log = u.linearToLogConverter || e.lin2log;\n        e.isLog && (e.val2lin = e.log2lin, e.lin2val = e.lin2log);\n        n(this, \"afterInit\");\n      },\n      setOptions: function setOptions(b) {\n        this.options = x(this.defaultOptions, \"yAxis\" === this.coll && this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side], x(a[this.coll], b));\n        n(this, \"afterSetOptions\", {\n          userOptions: b\n        });\n      },\n      defaultLabelFormatter: function defaultLabelFormatter() {\n        var b = this.axis,\n            d = this.value,\n            e = b.chart.time,\n            h = b.categories,\n            l = this.dateTimeLabelFormat,\n            n = a.lang,\n            t = n.numericSymbols;\n        n = n.numericSymbolMagnitude || 1E3;\n        var g = t && t.length,\n            r = b.options.labels.format;\n        b = b.isLog ? Math.abs(d) : b.tickInterval;\n        if (r) var B = F(r, this, e);else if (h) B = d;else if (l) B = e.dateFormat(l, d);else if (g && 1E3 <= b) for (; g-- && void 0 === B;) {\n          e = Math.pow(n, g + 1), b >= e && 0 === 10 * d % e && null !== t[g] && 0 !== d && (B = c.numberFormat(d / e, -1) + t[g]);\n        }\n        void 0 === B && (B = 1E4 <= Math.abs(d) ? c.numberFormat(d, -1) : c.numberFormat(d, -1, void 0, \"\"));\n        return B;\n      },\n      getSeriesExtremes: function getSeriesExtremes() {\n        var a = this,\n            b = a.chart,\n            d;\n        n(this, \"getSeriesExtremes\", null, function () {\n          a.hasVisibleSeries = !1;\n          a.dataMin = a.dataMax = a.threshold = null;\n          a.softThreshold = !a.isXAxis;\n          a.buildStacks && a.buildStacks();\n          a.series.forEach(function (e) {\n            if (e.visible || !b.options.chart.ignoreHiddenSeries) {\n              var u = e.options,\n                  c = u.threshold;\n              a.hasVisibleSeries = !0;\n              a.positiveValuesOnly && 0 >= c && (c = null);\n\n              if (a.isXAxis) {\n                if (u = e.xData, u.length) {\n                  d = e.getXExtremes(u);\n                  var z = d.min;\n                  var h = d.max;\n                  G(z) || z instanceof Date || (u = u.filter(G), d = e.getXExtremes(u), z = d.min, h = d.max);\n                  u.length && (a.dataMin = Math.min(k(a.dataMin, z), z), a.dataMax = Math.max(k(a.dataMax, h), h));\n                }\n              } else if (e.getExtremes(), h = e.dataMax, z = e.dataMin, A(z) && A(h) && (a.dataMin = Math.min(k(a.dataMin, z), z), a.dataMax = Math.max(k(a.dataMax, h), h)), A(c) && (a.threshold = c), !u.softThreshold || a.positiveValuesOnly) a.softThreshold = !1;\n            }\n          });\n        });\n        n(this, \"afterGetSeriesExtremes\");\n      },\n      translate: function translate(a, b, d, e, c, h) {\n        var u = this.linkedParent || this,\n            z = 1,\n            l = 0,\n            n = e ? u.oldTransA : u.transA;\n        e = e ? u.oldMin : u.min;\n        var t = u.minPixelPadding;\n        c = (u.isOrdinal || u.isBroken || u.isLog && c) && u.lin2val;\n        n || (n = u.transA);\n        d && (z *= -1, l = u.len);\n        u.reversed && (z *= -1, l -= z * (u.sector || u.len));\n        b ? (a = (a * z + l - t) / n + e, c && (a = u.lin2val(a))) : (c && (a = u.val2lin(a)), a = G(e) ? z * (a - e) * n + l + z * t + (G(h) ? n * h : 0) : void 0);\n        return a;\n      },\n      toPixels: function toPixels(a, b) {\n        return this.translate(a, !1, !this.horiz, null, !0) + (b ? 0 : this.pos);\n      },\n      toValue: function toValue(a, b) {\n        return this.translate(a - (b ? 0 : this.pos), !0, !this.horiz, null, !0);\n      },\n      getPlotLinePath: function getPlotLinePath(a) {\n        var b = this,\n            d = b.chart,\n            e = b.left,\n            c = b.top,\n            h = a.old,\n            z = a.value,\n            l = a.translatedValue,\n            t = a.lineWidth,\n            g = a.force,\n            r,\n            B,\n            x,\n            I,\n            f = h && d.oldChartHeight || d.chartHeight,\n            m = h && d.oldChartWidth || d.chartWidth,\n            F,\n            q = b.transB,\n            w = function w(a, b, d) {\n          if (\"pass\" !== g && a < b || a > d) g ? a = Math.min(Math.max(b, a), d) : F = !0;\n          return a;\n        };\n\n        a = {\n          value: z,\n          lineWidth: t,\n          old: h,\n          force: g,\n          acrossPanes: a.acrossPanes,\n          translatedValue: l\n        };\n        n(this, \"getPlotLinePath\", a, function (a) {\n          l = k(l, b.translate(z, null, null, h));\n          l = Math.min(Math.max(-1E5, l), 1E5);\n          r = x = Math.round(l + q);\n          B = I = Math.round(f - l - q);\n          G(l) ? b.horiz ? (B = c, I = f - b.bottom, r = x = w(r, e, e + b.width)) : (r = e, x = m - b.right, B = I = w(B, c, c + b.height)) : (F = !0, g = !1);\n          a.path = F && !g ? null : d.renderer.crispLine([\"M\", r, B, \"L\", x, I], t || 1);\n        });\n        return a.path;\n      },\n      getLinearTickPositions: function getLinearTickPositions(a, b, e) {\n        var u = d(Math.floor(b / a) * a);\n        e = d(Math.ceil(e / a) * a);\n        var c = [],\n            h;\n        d(u + a) === u && (h = 20);\n        if (this.single) return [b];\n\n        for (b = u; b <= e;) {\n          c.push(b);\n          b = d(b + a, h);\n          if (b === z) break;\n          var z = b;\n        }\n\n        return c;\n      },\n      getMinorTickInterval: function getMinorTickInterval() {\n        var a = this.options;\n        return !0 === a.minorTicks ? k(a.minorTickInterval, \"auto\") : !1 === a.minorTicks ? null : a.minorTickInterval;\n      },\n      getMinorTickPositions: function getMinorTickPositions() {\n        var a = this,\n            b = a.options,\n            d = a.tickPositions,\n            e = a.minorTickInterval,\n            c = [],\n            h = a.pointRangePadding || 0,\n            l = a.min - h;\n        h = a.max + h;\n        var n = h - l;\n        if (n && n / e < a.len / 3) if (a.isLog) this.paddedTicks.forEach(function (b, d, u) {\n          d && c.push.apply(c, a.getLogTickPositions(e, u[d - 1], u[d], !0));\n        });else if (a.isDatetimeAxis && \"auto\" === this.getMinorTickInterval()) c = c.concat(a.getTimeTicks(a.normalizeTimeTickInterval(e), l, h, b.startOfWeek));else for (b = l + (d[0] - l) % e; b <= h && b !== c[0]; b += e) {\n          c.push(b);\n        }\n        0 !== c.length && a.trimTicks(c);\n        return c;\n      },\n      adjustForMinRange: function adjustForMinRange() {\n        var a = this.options,\n            b = this.min,\n            d = this.max,\n            e,\n            c,\n            h,\n            l,\n            n;\n        this.isXAxis && void 0 === this.minRange && !this.isLog && (A(a.min) || A(a.max) ? this.minRange = null : (this.series.forEach(function (a) {\n          l = a.xData;\n\n          for (c = n = a.xIncrement ? 1 : l.length - 1; 0 < c; c--) {\n            if (h = l[c] - l[c - 1], void 0 === e || h < e) e = h;\n          }\n        }), this.minRange = Math.min(5 * e, this.dataMax - this.dataMin)));\n\n        if (d - b < this.minRange) {\n          var t = this.dataMax - this.dataMin >= this.minRange;\n          var g = this.minRange;\n          var r = (g - d + b) / 2;\n          r = [b - r, k(a.min, b - r)];\n          t && (r[2] = this.isLog ? this.log2lin(this.dataMin) : this.dataMin);\n          b = H(r);\n          d = [b + g, k(a.max, b + g)];\n          t && (d[2] = this.isLog ? this.log2lin(this.dataMax) : this.dataMax);\n          d = D(d);\n          d - b < g && (r[0] = d - g, r[1] = k(a.min, d - g), b = H(r));\n        }\n\n        this.min = b;\n        this.max = d;\n      },\n      getClosest: function getClosest() {\n        var a;\n        this.categories ? a = 1 : this.series.forEach(function (b) {\n          var d = b.closestPointRange,\n              e = b.visible || !b.chart.options.chart.ignoreHiddenSeries;\n          !b.noSharedTooltip && A(d) && e && (a = A(a) ? Math.min(a, d) : d);\n        });\n        return a;\n      },\n      nameToX: function nameToX(a) {\n        var b = y(this.categories),\n            d = b ? this.categories : this.names,\n            e = a.options.x;\n        a.series.requireSorting = !1;\n        A(e) || (e = !1 === this.options.uniqueNames ? a.series.autoIncrement() : b ? d.indexOf(a.name) : k(d.keys[a.name], -1));\n\n        if (-1 === e) {\n          if (!b) var c = d.length;\n        } else c = e;\n\n        void 0 !== c && (this.names[c] = a.name, this.names.keys[a.name] = c);\n        return c;\n      },\n      updateNames: function updateNames() {\n        var a = this,\n            b = this.names;\n        0 < b.length && (Object.keys(b.keys).forEach(function (a) {\n          delete b.keys[a];\n        }), b.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (b) {\n          b.xIncrement = null;\n          if (!b.points || b.isDirtyData) a.max = Math.max(a.max, b.xData.length - 1), b.processData(), b.generatePoints();\n          b.data.forEach(function (d, e) {\n            if (d && d.options && void 0 !== d.name) {\n              var u = a.nameToX(d);\n              void 0 !== u && u !== d.x && (d.x = u, b.xData[e] = u);\n            }\n          });\n        }));\n      },\n      setAxisTranslation: function setAxisTranslation(a) {\n        var b = this,\n            d = b.max - b.min,\n            e = b.axisPointRange || 0,\n            c = 0,\n            h = 0,\n            l = b.linkedParent,\n            z = !!b.categories,\n            t = b.transA,\n            g = b.isXAxis;\n\n        if (g || z || e) {\n          var r = b.getClosest();\n          l ? (c = l.minPointOffset, h = l.pointRangePadding) : b.series.forEach(function (a) {\n            var d = z ? 1 : g ? k(a.options.pointRange, r, 0) : b.axisPointRange || 0,\n                u = a.options.pointPlacement;\n            e = Math.max(e, d);\n            if (!b.single || z) a = B.xrange && a instanceof B.xrange ? !g : g, c = Math.max(c, a && v(u) ? 0 : d / 2), h = Math.max(h, a && \"on\" === u ? 0 : d);\n          });\n          l = b.ordinalSlope && r ? b.ordinalSlope / r : 1;\n          b.minPointOffset = c *= l;\n          b.pointRangePadding = h *= l;\n          b.pointRange = Math.min(e, b.single && z ? 1 : d);\n          g && (b.closestPointRange = r);\n        }\n\n        a && (b.oldTransA = t);\n        b.translationSlope = b.transA = t = b.staticScale || b.len / (d + h || 1);\n        b.transB = b.horiz ? b.left : b.bottom;\n        b.minPixelPadding = t * c;\n        n(this, \"afterSetAxisTranslation\");\n      },\n      minFromRange: function minFromRange() {\n        return this.max - this.range;\n      },\n      setTickInterval: function setTickInterval(a) {\n        var b = this,\n            e = b.chart,\n            h = b.options,\n            z = b.isLog,\n            t = b.isDatetimeAxis,\n            g = b.isXAxis,\n            B = b.isLinked,\n            x = h.maxPadding,\n            I = h.minPadding,\n            f = h.tickInterval,\n            F = h.tickPixelInterval,\n            m = b.categories,\n            q = G(b.threshold) ? b.threshold : null,\n            w = b.softThreshold;\n        t || m || B || this.getTickAmount();\n        var p = k(b.userMin, h.min);\n        var y = k(b.userMax, h.max);\n\n        if (B) {\n          b.linkedParent = e[b.coll][h.linkedTo];\n          var v = b.linkedParent.getExtremes();\n          b.min = k(v.min, v.dataMin);\n          b.max = k(v.max, v.dataMax);\n          h.type !== b.linkedParent.options.type && c.error(11, 1, e);\n        } else {\n          if (!w && A(q)) if (b.dataMin >= q) v = q, I = 0;else if (b.dataMax <= q) {\n            var E = q;\n            x = 0;\n          }\n          b.min = k(p, v, b.dataMin);\n          b.max = k(y, E, b.dataMax);\n        }\n\n        z && (b.positiveValuesOnly && !a && 0 >= Math.min(b.min, k(b.dataMin, b.min)) && c.error(10, 1, e), b.min = d(b.log2lin(b.min), 16), b.max = d(b.log2lin(b.max), 16));\n        b.range && A(b.max) && (b.userMin = b.min = p = Math.max(b.dataMin, b.minFromRange()), b.userMax = y = b.max, b.range = null);\n        n(b, \"foundExtremes\");\n        b.beforePadding && b.beforePadding();\n        b.adjustForMinRange();\n        !(m || b.axisPointRange || b.usePercentage || B) && A(b.min) && A(b.max) && (e = b.max - b.min) && (!A(p) && I && (b.min -= e * I), !A(y) && x && (b.max += e * x));\n        G(h.softMin) && !G(b.userMin) && h.softMin < b.min && (b.min = p = h.softMin);\n        G(h.softMax) && !G(b.userMax) && h.softMax > b.max && (b.max = y = h.softMax);\n        G(h.floor) && (b.min = Math.min(Math.max(b.min, h.floor), Number.MAX_VALUE));\n        G(h.ceiling) && (b.max = Math.max(Math.min(b.max, h.ceiling), k(b.userMax, -Number.MAX_VALUE)));\n        w && A(b.dataMin) && (q = q || 0, !A(p) && b.min < q && b.dataMin >= q ? b.min = b.options.minRange ? Math.min(q, b.max - b.minRange) : q : !A(y) && b.max > q && b.dataMax <= q && (b.max = b.options.minRange ? Math.max(q, b.min + b.minRange) : q));\n        b.tickInterval = b.min === b.max || void 0 === b.min || void 0 === b.max ? 1 : B && !f && F === b.linkedParent.options.tickPixelInterval ? f = b.linkedParent.tickInterval : k(f, this.tickAmount ? (b.max - b.min) / Math.max(this.tickAmount - 1, 1) : void 0, m ? 1 : (b.max - b.min) * F / Math.max(b.len, F));\n        g && !a && b.series.forEach(function (a) {\n          a.processData(b.min !== b.oldMin || b.max !== b.oldMax);\n        });\n        b.setAxisTranslation(!0);\n        b.beforeSetTickPositions && b.beforeSetTickPositions();\n        b.postProcessTickInterval && (b.tickInterval = b.postProcessTickInterval(b.tickInterval));\n        b.pointRange && !f && (b.tickInterval = Math.max(b.pointRange, b.tickInterval));\n        a = k(h.minTickInterval, b.isDatetimeAxis && b.closestPointRange);\n        !f && b.tickInterval < a && (b.tickInterval = a);\n        t || z || f || (b.tickInterval = l(b.tickInterval, null, r(b.tickInterval), k(h.allowDecimals, !(.5 < b.tickInterval && 5 > b.tickInterval && 1E3 < b.max && 9999 > b.max)), !!this.tickAmount));\n        this.tickAmount || (b.tickInterval = b.unsquish());\n        this.setTickPositions();\n      },\n      setTickPositions: function setTickPositions() {\n        var a = this.options,\n            b = a.tickPositions;\n        var d = this.getMinorTickInterval();\n        var e = a.tickPositioner,\n            h = a.startOnTick,\n            l = a.endOnTick;\n        this.tickmarkOffset = this.categories && \"between\" === a.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;\n        this.minorTickInterval = \"auto\" === d && this.tickInterval ? this.tickInterval / 5 : d;\n        this.single = this.min === this.max && A(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== a.allowDecimals);\n        this.tickPositions = d = b && b.slice();\n        !d && (!this.ordinalPositions && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200) ? (d = [this.min, this.max], c.error(19, !1, this.chart)) : d = this.isDatetimeAxis ? this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval, a.units), this.min, this.max, a.startOfWeek, this.ordinalPositions, this.closestPointRange, !0) : this.isLog ? this.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max), d.length > this.len && (d = [d[0], d.pop()], d[0] === d[1] && (d.length = 1)), this.tickPositions = d, e && (e = e.apply(this, [this.min, this.max]))) && (this.tickPositions = d = e);\n        this.paddedTicks = d.slice(0);\n        this.trimTicks(d, h, l);\n        this.isLinked || (this.single && 2 > d.length && !this.categories && (this.min -= .5, this.max += .5), b || e || this.adjustTickAmount());\n        n(this, \"afterSetTickPositions\");\n      },\n      trimTicks: function trimTicks(a, b, d) {\n        var e = a[0],\n            c = a[a.length - 1],\n            h = this.minPointOffset || 0;\n        n(this, \"trimTicks\");\n\n        if (!this.isLinked) {\n          if (b && -Infinity !== e) this.min = e;else for (; this.min - h > a[0];) {\n            a.shift();\n          }\n          if (d) this.max = c;else for (; this.max + h < a[a.length - 1];) {\n            a.pop();\n          }\n          0 === a.length && A(e) && !this.options.tickPositions && a.push((c + e) / 2);\n        }\n      },\n      alignToOthers: function alignToOthers() {\n        var a = {},\n            b,\n            d = this.options;\n        !1 === this.chart.options.chart.alignTicks || !1 === d.alignTicks || !1 === d.startOnTick || !1 === d.endOnTick || this.isLog || this.chart[this.coll].forEach(function (d) {\n          var e = d.options;\n          e = [d.horiz ? e.left : e.top, e.width, e.height, e.pane].join();\n          d.series.length && (a[e] ? b = !0 : a[e] = 1);\n        });\n        return b;\n      },\n      getTickAmount: function getTickAmount() {\n        var a = this.options,\n            b = a.tickAmount,\n            d = a.tickPixelInterval;\n        !A(a.tickInterval) && this.len < d && !this.isRadial && !this.isLog && a.startOnTick && a.endOnTick && (b = 2);\n        !b && this.alignToOthers() && (b = Math.ceil(this.len / d) + 1);\n        4 > b && (this.finalTickAmt = b, b = 5);\n        this.tickAmount = b;\n      },\n      adjustTickAmount: function adjustTickAmount() {\n        var a = this.options,\n            b = this.tickInterval,\n            e = this.tickPositions,\n            c = this.tickAmount,\n            h = this.finalTickAmt,\n            l = e && e.length,\n            n = k(this.threshold, this.softThreshold ? 0 : null),\n            t;\n\n        if (this.hasData()) {\n          if (l < c) {\n            for (t = this.min; e.length < c;) {\n              e.length % 2 || t === n ? e.push(d(e[e.length - 1] + b)) : e.unshift(d(e[0] - b));\n            }\n\n            this.transA *= (l - 1) / (c - 1);\n            this.min = a.startOnTick ? e[0] : Math.min(this.min, e[0]);\n            this.max = a.endOnTick ? e[e.length - 1] : Math.max(this.max, e[e.length - 1]);\n          } else l > c && (this.tickInterval *= 2, this.setTickPositions());\n\n          if (A(h)) {\n            for (b = a = e.length; b--;) {\n              (3 === h && 1 === b % 2 || 2 >= h && 0 < b && b < a - 1) && e.splice(b, 1);\n            }\n\n            this.finalTickAmt = void 0;\n          }\n        }\n      },\n      setScale: function setScale() {\n        var a = this.series.some(function (a) {\n          return a.isDirtyData || a.isDirty || a.xAxis && a.xAxis.isDirty;\n        }),\n            b;\n        this.oldMin = this.min;\n        this.oldMax = this.max;\n        this.oldAxisLength = this.len;\n        this.setAxisSize();\n        (b = this.len !== this.oldAxisLength) || a || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax || this.alignToOthers() ? (this.resetStacks && this.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.oldUserMin = this.userMin, this.oldUserMax = this.userMax, this.isDirty || (this.isDirty = b || this.min !== this.oldMin || this.max !== this.oldMax)) : this.cleanStacks && this.cleanStacks();\n        n(this, \"afterSetScale\");\n      },\n      setExtremes: function setExtremes(a, b, d, e, c) {\n        var h = this,\n            l = h.chart;\n        d = k(d, !0);\n        h.series.forEach(function (a) {\n          delete a.kdTree;\n        });\n        c = p(c, {\n          min: a,\n          max: b\n        });\n        n(h, \"setExtremes\", c, function () {\n          h.userMin = a;\n          h.userMax = b;\n          h.eventArgs = c;\n          d && l.redraw(e);\n        });\n      },\n      zoom: function zoom(a, b) {\n        var d = this.dataMin,\n            e = this.dataMax,\n            c = this.options,\n            h = Math.min(d, k(c.min, d)),\n            l = Math.max(e, k(c.max, e));\n        a = {\n          newMin: a,\n          newMax: b\n        };\n        n(this, \"zoom\", a, function (a) {\n          var b = a.newMin,\n              c = a.newMax;\n          if (b !== this.min || c !== this.max) this.allowZoomOutside || (A(d) && (b < h && (b = h), b > l && (b = l)), A(e) && (c < h && (c = h), c > l && (c = l))), this.displayBtn = void 0 !== b || void 0 !== c, this.setExtremes(b, c, !1, void 0, {\n            trigger: \"zoom\"\n          });\n          a.zoomed = !0;\n        });\n        return a.zoomed;\n      },\n      setAxisSize: function setAxisSize() {\n        var a = this.chart,\n            b = this.options,\n            d = b.offsets || [0, 0, 0, 0],\n            e = this.horiz,\n            h = this.width = Math.round(c.relativeLength(k(b.width, a.plotWidth - d[3] + d[1]), a.plotWidth)),\n            l = this.height = Math.round(c.relativeLength(k(b.height, a.plotHeight - d[0] + d[2]), a.plotHeight)),\n            n = this.top = Math.round(c.relativeLength(k(b.top, a.plotTop + d[0]), a.plotHeight, a.plotTop));\n        b = this.left = Math.round(c.relativeLength(k(b.left, a.plotLeft + d[3]), a.plotWidth, a.plotLeft));\n        this.bottom = a.chartHeight - l - n;\n        this.right = a.chartWidth - h - b;\n        this.len = Math.max(e ? h : l, 0);\n        this.pos = e ? b : n;\n      },\n      getExtremes: function getExtremes() {\n        var a = this.isLog;\n        return {\n          min: a ? d(this.lin2log(this.min)) : this.min,\n          max: a ? d(this.lin2log(this.max)) : this.max,\n          dataMin: this.dataMin,\n          dataMax: this.dataMax,\n          userMin: this.userMin,\n          userMax: this.userMax\n        };\n      },\n      getThreshold: function getThreshold(a) {\n        var b = this.isLog,\n            d = b ? this.lin2log(this.min) : this.min;\n        b = b ? this.lin2log(this.max) : this.max;\n        null === a || -Infinity === a ? a = d : Infinity === a ? a = b : d > a ? a = d : b < a && (a = b);\n        return this.translate(a, 0, 1, 0, 1);\n      },\n      autoLabelAlign: function autoLabelAlign(a) {\n        var b = (k(a, 0) - 90 * this.side + 720) % 360;\n        a = {\n          align: \"center\"\n        };\n        n(this, \"autoLabelAlign\", a, function (a) {\n          15 < b && 165 > b ? a.align = \"right\" : 195 < b && 345 > b && (a.align = \"left\");\n        });\n        return a.align;\n      },\n      tickSize: function tickSize(a) {\n        var b = this.options,\n            d = b[a + \"Length\"],\n            e = k(b[a + \"Width\"], \"tick\" === a && this.isXAxis && !this.categories ? 1 : 0);\n\n        if (e && d) {\n          \"inside\" === b[a + \"Position\"] && (d = -d);\n          var c = [d, e];\n        }\n\n        a = {\n          tickSize: c\n        };\n        n(this, \"afterTickSize\", a);\n        return a.tickSize;\n      },\n      labelMetrics: function labelMetrics() {\n        var a = this.tickPositions && this.tickPositions[0] || 0;\n        return this.chart.renderer.fontMetrics(this.options.labels.style && this.options.labels.style.fontSize, this.ticks[a] && this.ticks[a].label);\n      },\n      unsquish: function unsquish() {\n        var a = this.options.labels,\n            b = this.horiz,\n            e = this.tickInterval,\n            c = e,\n            l = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / e),\n            n,\n            t = a.rotation,\n            g = this.labelMetrics(),\n            r,\n            B = Number.MAX_VALUE,\n            x,\n            I = this.max - this.min,\n            f = function f(a) {\n          var b = a / (l || 1);\n          b = 1 < b ? Math.ceil(b) : 1;\n          b * e > I && Infinity !== a && Infinity !== l && I && (b = Math.ceil(I / e));\n          return d(b * e);\n        };\n\n        b ? (x = !a.staggerLines && !a.step && (A(t) ? [t] : l < k(a.autoRotationLimit, 80) && a.autoRotation)) && x.forEach(function (a) {\n          if (a === t || a && -90 <= a && 90 >= a) {\n            r = f(Math.abs(g.h / Math.sin(h * a)));\n            var b = r + Math.abs(a / 360);\n            b < B && (B = b, n = a, c = r);\n          }\n        }) : a.step || (c = f(g.h));\n        this.autoRotation = x;\n        this.labelRotation = k(n, t);\n        return c;\n      },\n      getSlotWidth: function getSlotWidth(a) {\n        var b = this.chart,\n            d = this.horiz,\n            e = this.options.labels,\n            c = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n            h = b.margin[3];\n        return a && a.slotWidth || d && 2 > (e.step || 0) && !e.rotation && (this.staggerLines || 1) * this.len / c || !d && (e.style && parseInt(e.style.width, 10) || h && h - b.spacing[3] || .33 * b.chartWidth);\n      },\n      renderUnsquish: function renderUnsquish() {\n        var a = this.chart,\n            b = a.renderer,\n            d = this.tickPositions,\n            e = this.ticks,\n            c = this.options.labels,\n            h = c && c.style || {},\n            l = this.horiz,\n            n = this.getSlotWidth(),\n            t = Math.max(1, Math.round(n - 2 * (c.padding || 5))),\n            g = {},\n            r = this.labelMetrics(),\n            B = c.style && c.style.textOverflow,\n            k = 0;\n        v(c.rotation) || (g.rotation = c.rotation || 0);\n        d.forEach(function (a) {\n          (a = e[a]) && a.label && a.label.textPxLength > k && (k = a.label.textPxLength);\n        });\n        this.maxLabelLength = k;\n        if (this.autoRotation) k > t && k > r.h ? g.rotation = this.labelRotation : this.labelRotation = 0;else if (n) {\n          var x = t;\n\n          if (!B) {\n            var I = \"clip\";\n\n            for (t = d.length; !l && t--;) {\n              var f = d[t];\n              if (f = e[f].label) f.styles && \"ellipsis\" === f.styles.textOverflow ? f.css({\n                textOverflow: \"clip\"\n              }) : f.textPxLength > n && f.css({\n                width: n + \"px\"\n              }), f.getBBox().height > this.len / d.length - (r.h - r.f) && (f.specificTextOverflow = \"ellipsis\");\n            }\n          }\n        }\n        g.rotation && (x = k > .5 * a.chartHeight ? .33 * a.chartHeight : k, B || (I = \"ellipsis\"));\n        if (this.labelAlign = c.align || this.autoLabelAlign(this.labelRotation)) g.align = this.labelAlign;\n        d.forEach(function (a) {\n          var b = (a = e[a]) && a.label,\n              d = h.width,\n              c = {};\n          b && (b.attr(g), a.shortenLabel ? a.shortenLabel() : x && !d && \"nowrap\" !== h.whiteSpace && (x < b.textPxLength || \"SPAN\" === b.element.tagName) ? (c.width = x, B || (c.textOverflow = b.specificTextOverflow || I), b.css(c)) : b.styles && b.styles.width && !c.width && !d && b.css({\n            width: null\n          }), delete b.specificTextOverflow, a.rotation = g.rotation);\n        }, this);\n        this.tickRotCorr = b.rotCorr(r.b, this.labelRotation || 0, 0 !== this.side);\n      },\n      hasData: function hasData() {\n        return this.series.some(function (a) {\n          return a.hasData();\n        }) || this.options.showEmpty && A(this.min) && A(this.max);\n      },\n      addTitle: function addTitle(a) {\n        var b = this.chart.renderer,\n            d = this.horiz,\n            e = this.opposite,\n            c = this.options.title,\n            h,\n            l = this.chart.styledMode;\n        this.axisTitle || ((h = c.textAlign) || (h = (d ? {\n          low: \"left\",\n          middle: \"center\",\n          high: \"right\"\n        } : {\n          low: e ? \"right\" : \"left\",\n          middle: \"center\",\n          high: e ? \"left\" : \"right\"\n        })[c.align]), this.axisTitle = b.text(c.text, 0, 0, c.useHTML).attr({\n          zIndex: 7,\n          rotation: c.rotation || 0,\n          align: h\n        }).addClass(\"highcharts-axis-title\"), l || this.axisTitle.css(x(c.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);\n        l || c.style.width || this.isRadial || this.axisTitle.css({\n          width: this.len\n        });\n        this.axisTitle[a ? \"show\" : \"hide\"](a);\n      },\n      generateTick: function generateTick(a) {\n        var b = this.ticks;\n        b[a] ? b[a].addLabel() : b[a] = new I(this, a);\n      },\n      getOffset: function getOffset() {\n        var a = this,\n            b = a.chart,\n            d = b.renderer,\n            e = a.options,\n            c = a.tickPositions,\n            h = a.ticks,\n            l = a.horiz,\n            t = a.side,\n            g = b.inverted && !a.isZAxis ? [1, 0, 3, 2][t] : t,\n            r,\n            B = 0,\n            x = 0,\n            I = e.title,\n            f = e.labels,\n            F = 0,\n            m = b.axisOffset;\n        b = b.clipOffset;\n        var w = [-1, 1, 1, -1][t],\n            p = e.className,\n            y = a.axisParent;\n        var v = a.hasData();\n        a.showAxis = r = v || k(e.showEmpty, !0);\n        a.staggerLines = a.horiz && f.staggerLines;\n        a.axisGroup || (a.gridGroup = d.g(\"grid\").attr({\n          zIndex: e.gridZIndex || 1\n        }).addClass(\"highcharts-\" + this.coll.toLowerCase() + \"-grid \" + (p || \"\")).add(y), a.axisGroup = d.g(\"axis\").attr({\n          zIndex: e.zIndex || 2\n        }).addClass(\"highcharts-\" + this.coll.toLowerCase() + \" \" + (p || \"\")).add(y), a.labelGroup = d.g(\"axis-labels\").attr({\n          zIndex: f.zIndex || 7\n        }).addClass(\"highcharts-\" + a.coll.toLowerCase() + \"-labels \" + (p || \"\")).add(y));\n        v || a.isLinked ? (c.forEach(function (b, d) {\n          a.generateTick(b, d);\n        }), a.renderUnsquish(), a.reserveSpaceDefault = 0 === t || 2 === t || {\n          1: \"left\",\n          3: \"right\"\n        }[t] === a.labelAlign, k(f.reserveSpace, \"center\" === a.labelAlign ? !0 : null, a.reserveSpaceDefault) && c.forEach(function (a) {\n          F = Math.max(h[a].getLabelSize(), F);\n        }), a.staggerLines && (F *= a.staggerLines), a.labelOffset = F * (a.opposite ? -1 : 1)) : q(h, function (a, b) {\n          a.destroy();\n          delete h[b];\n        });\n\n        if (I && I.text && !1 !== I.enabled && (a.addTitle(r), r && !1 !== I.reserveSpace)) {\n          a.titleOffset = B = a.axisTitle.getBBox()[l ? \"height\" : \"width\"];\n          var G = I.offset;\n          x = A(G) ? 0 : k(I.margin, l ? 5 : 10);\n        }\n\n        a.renderLine();\n        a.offset = w * k(e.offset, m[t] ? m[t] + (e.margin || 0) : 0);\n        a.tickRotCorr = a.tickRotCorr || {\n          x: 0,\n          y: 0\n        };\n        d = 0 === t ? -a.labelMetrics().h : 2 === t ? a.tickRotCorr.y : 0;\n        x = Math.abs(F) + x;\n        F && (x = x - d + w * (l ? k(f.y, a.tickRotCorr.y + 8 * w) : f.x));\n        a.axisTitleMargin = k(G, x);\n        a.getMaxLabelDimensions && (a.maxLabelDimensions = a.getMaxLabelDimensions(h, c));\n        l = this.tickSize(\"tick\");\n        m[t] = Math.max(m[t], a.axisTitleMargin + B + w * a.offset, x, c && c.length && l ? l[0] + w * a.offset : 0);\n        e = e.offset ? 0 : 2 * Math.floor(a.axisLine.strokeWidth() / 2);\n        b[g] = Math.max(b[g], e);\n        n(this, \"afterGetOffset\");\n      },\n      getLinePath: function getLinePath(a) {\n        var b = this.chart,\n            d = this.opposite,\n            e = this.offset,\n            c = this.horiz,\n            h = this.left + (d ? this.width : 0) + e;\n        e = b.chartHeight - this.bottom - (d ? this.height : 0) + e;\n        d && (a *= -1);\n        return b.renderer.crispLine([\"M\", c ? this.left : h, c ? e : this.top, \"L\", c ? b.chartWidth - this.right : h, c ? e : b.chartHeight - this.bottom], a);\n      },\n      renderLine: function renderLine() {\n        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass(\"highcharts-axis-line\").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({\n          stroke: this.options.lineColor,\n          \"stroke-width\": this.options.lineWidth,\n          zIndex: 7\n        }));\n      },\n      getTitlePosition: function getTitlePosition() {\n        var a = this.horiz,\n            b = this.left,\n            d = this.top,\n            e = this.len,\n            c = this.options.title,\n            h = a ? b : d,\n            l = this.opposite,\n            t = this.offset,\n            g = c.x || 0,\n            r = c.y || 0,\n            B = this.axisTitle,\n            k = this.chart.renderer.fontMetrics(c.style && c.style.fontSize, B);\n        B = Math.max(B.getBBox(null, 0).height - k.h - 1, 0);\n        e = {\n          low: h + (a ? 0 : e),\n          middle: h + e / 2,\n          high: h + (a ? e : 0)\n        }[c.align];\n        b = (a ? d + this.height : b) + (a ? 1 : -1) * (l ? -1 : 1) * this.axisTitleMargin + [-B, B, k.f, -B][this.side];\n        a = {\n          x: a ? e + g : b + (l ? this.width : 0) + t + g,\n          y: a ? b + r - (l ? this.height : 0) + t : e + r\n        };\n        n(this, \"afterGetTitlePosition\", {\n          titlePosition: a\n        });\n        return a;\n      },\n      renderMinorTick: function renderMinorTick(a) {\n        var b = this.chart.hasRendered && G(this.oldMin),\n            d = this.minorTicks;\n        d[a] || (d[a] = new I(this, a, \"minor\"));\n        b && d[a].isNew && d[a].render(null, !0);\n        d[a].render(null, !1, 1);\n      },\n      renderTick: function renderTick(a, b) {\n        var d = this.isLinked,\n            e = this.ticks,\n            c = this.chart.hasRendered && G(this.oldMin);\n        if (!d || a >= this.min && a <= this.max) e[a] || (e[a] = new I(this, a)), c && e[a].isNew && e[a].render(b, !0, -1), e[a].render(b);\n      },\n      render: function render() {\n        var a = this,\n            b = a.chart,\n            d = a.options,\n            h = a.isLog,\n            l = a.isLinked,\n            t = a.tickPositions,\n            g = a.axisTitle,\n            r = a.ticks,\n            B = a.minorTicks,\n            k = a.alternateBands,\n            x = d.stackLabels,\n            f = d.alternateGridColor,\n            F = a.tickmarkOffset,\n            m = a.axisLine,\n            p = a.showAxis,\n            y = e(b.renderer.globalAnimation),\n            v,\n            A;\n        a.labelEdge.length = 0;\n        a.overlap = !1;\n        [r, B, k].forEach(function (a) {\n          q(a, function (a) {\n            a.isActive = !1;\n          });\n        });\n        if (a.hasData() || l) a.minorTickInterval && !a.categories && a.getMinorTickPositions().forEach(function (b) {\n          a.renderMinorTick(b);\n        }), t.length && (t.forEach(function (b, d) {\n          a.renderTick(b, d);\n        }), F && (0 === a.min || a.single) && (r[-1] || (r[-1] = new I(a, -1, null, !0)), r[-1].render(-1))), f && t.forEach(function (d, e) {\n          A = void 0 !== t[e + 1] ? t[e + 1] + F : a.max - F;\n          0 === e % 2 && d < a.max && A <= a.max + (b.polar ? -F : F) && (k[d] || (k[d] = new c.PlotLineOrBand(a)), v = d + F, k[d].options = {\n            from: h ? a.lin2log(v) : v,\n            to: h ? a.lin2log(A) : A,\n            color: f\n          }, k[d].render(), k[d].isActive = !0);\n        }), a._addedPlotLB || ((d.plotLines || []).concat(d.plotBands || []).forEach(function (b) {\n          a.addPlotBandOrLine(b);\n        }), a._addedPlotLB = !0);\n        [r, B, k].forEach(function (a) {\n          var d,\n              e = [],\n              c = y.duration;\n          q(a, function (a, b) {\n            a.isActive || (a.render(b, !1, 0), a.isActive = !1, e.push(b));\n          });\n          w(function () {\n            for (d = e.length; d--;) {\n              a[e[d]] && !a[e[d]].isActive && (a[e[d]].destroy(), delete a[e[d]]);\n            }\n          }, a !== k && b.hasRendered && c ? c : 0);\n        });\n        m && (m[m.isPlaced ? \"animate\" : \"attr\"]({\n          d: this.getLinePath(m.strokeWidth())\n        }), m.isPlaced = !0, m[p ? \"show\" : \"hide\"](p));\n        g && p && (d = a.getTitlePosition(), G(d.y) ? (g[g.isNew ? \"attr\" : \"animate\"](d), g.isNew = !1) : (g.attr(\"y\", -9999), g.isNew = !0));\n        x && x.enabled && a.renderStackTotals();\n        a.isDirty = !1;\n        n(this, \"afterRender\");\n      },\n      redraw: function redraw() {\n        this.visible && (this.render(), this.plotLinesAndBands.forEach(function (a) {\n          a.render();\n        }));\n        this.series.forEach(function (a) {\n          a.isDirty = !0;\n        });\n      },\n      keepProps: \"extKey hcEvents names series userMax userMin\".split(\" \"),\n      destroy: function destroy(a) {\n        var b = this,\n            d = b.stacks,\n            e = b.plotLinesAndBands,\n            c;\n        n(this, \"destroy\", {\n          keepEvents: a\n        });\n        a || t(b);\n        q(d, function (a, b) {\n          E(a);\n          d[b] = null;\n        });\n        [b.ticks, b.minorTicks, b.alternateBands].forEach(function (a) {\n          E(a);\n        });\n        if (e) for (a = e.length; a--;) {\n          e[a].destroy();\n        }\n        \"stackTotalGroup axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar\".split(\" \").forEach(function (a) {\n          b[a] && (b[a] = b[a].destroy());\n        });\n\n        for (c in b.plotLinesAndBandsGroups) {\n          b.plotLinesAndBandsGroups[c] = b.plotLinesAndBandsGroups[c].destroy();\n        }\n\n        q(b, function (a, d) {\n          -1 === b.keepProps.indexOf(d) && delete b[d];\n        });\n      },\n      drawCrosshair: function drawCrosshair(a, d) {\n        var e,\n            c = this.crosshair,\n            h = k(c.snap, !0),\n            l,\n            t = this.cross;\n        n(this, \"drawCrosshair\", {\n          e: a,\n          point: d\n        });\n        a || (a = this.cross && this.cross.e);\n\n        if (this.crosshair && !1 !== (A(d) || !h)) {\n          h ? A(d) && (l = k(\"colorAxis\" !== this.coll ? d.crosshairPos : null, this.isXAxis ? d.plotX : this.len - d.plotY)) : l = a && (this.horiz ? a.chartX - this.pos : this.len - a.chartY + this.pos);\n          A(l) && (e = this.getPlotLinePath({\n            value: d && (this.isXAxis ? d.x : k(d.stackY, d.y)),\n            translatedValue: l\n          }) || null);\n\n          if (!A(e)) {\n            this.hideCrosshair();\n            return;\n          }\n\n          h = this.categories && !this.isRadial;\n          t || (this.cross = t = this.chart.renderer.path().addClass(\"highcharts-crosshair highcharts-crosshair-\" + (h ? \"category \" : \"thin \") + c.className).attr({\n            zIndex: k(c.zIndex, 2)\n          }).add(), this.chart.styledMode || (t.attr({\n            stroke: c.color || (h ? b(\"#ccd6eb\").setOpacity(.25).get() : \"#cccccc\"),\n            \"stroke-width\": k(c.width, 1)\n          }).css({\n            \"pointer-events\": \"none\"\n          }), c.dashStyle && t.attr({\n            dashstyle: c.dashStyle\n          })));\n          t.show().attr({\n            d: e\n          });\n          h && !c.width && t.attr({\n            \"stroke-width\": this.transA\n          });\n          this.cross.e = a;\n        } else this.hideCrosshair();\n\n        n(this, \"afterDrawCrosshair\", {\n          e: a,\n          point: d\n        });\n      },\n      hideCrosshair: function hideCrosshair() {\n        this.cross && this.cross.hide();\n        n(this, \"afterHideCrosshair\");\n      }\n    });\n    return c.Axis = f;\n  });\n  K(C, \"parts/DateTimeAxis.js\", [C[\"parts/Globals.js\"]], function (c) {\n    var f = c.Axis,\n        H = c.getMagnitude,\n        D = c.normalizeTickInterval,\n        A = c.timeUnits;\n\n    f.prototype.getTimeTicks = function () {\n      return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);\n    };\n\n    f.prototype.normalizeTimeTickInterval = function (c, f) {\n      var y = f || [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2]], [\"week\", [1, 2]], [\"month\", [1, 2, 3, 4, 6]], [\"year\", null]];\n      f = y[y.length - 1];\n      var p = A[f[0]],\n          v = f[1],\n          q;\n\n      for (q = 0; q < y.length && !(f = y[q], p = A[f[0]], v = f[1], y[q + 1] && c <= (p * v[v.length - 1] + A[y[q + 1][0]]) / 2); q++) {\n        ;\n      }\n\n      p === A.year && c < 5 * p && (v = [1, 2, 5]);\n      c = D(c / p, v, \"year\" === f[0] ? Math.max(H(c / p), 1) : 1);\n      return {\n        unitRange: p,\n        count: c,\n        unitName: f[0]\n      };\n    };\n  });\n  K(C, \"parts/LogarithmicAxis.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var H = f.pick;\n    f = c.Axis;\n    var D = c.getMagnitude,\n        A = c.normalizeTickInterval;\n\n    f.prototype.getLogTickPositions = function (c, f, y, G) {\n      var p = this.options,\n          q = this.len,\n          k = [];\n      G || (this._minorAutoInterval = null);\n      if (.5 <= c) c = Math.round(c), k = this.getLinearTickPositions(c, f, y);else if (.08 <= c) {\n        q = Math.floor(f);\n        var m, w;\n\n        for (p = .3 < c ? [1, 2, 4] : .15 < c ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; q < y + 1 && !w; q++) {\n          var g = p.length;\n\n          for (m = 0; m < g && !w; m++) {\n            var e = this.log2lin(this.lin2log(q) * p[m]);\n            e > f && (!G || b <= y) && void 0 !== b && k.push(b);\n            b > y && (w = !0);\n            var b = e;\n          }\n        }\n      } else f = this.lin2log(f), y = this.lin2log(y), c = G ? this.getMinorTickInterval() : p.tickInterval, c = H(\"auto\" === c ? null : c, this._minorAutoInterval, p.tickPixelInterval / (G ? 5 : 1) * (y - f) / ((G ? q / this.tickPositions.length : q) || 1)), c = A(c, null, D(c)), k = this.getLinearTickPositions(c, f, y).map(this.log2lin), G || (this._minorAutoInterval = c / 5);\n      G || (this.tickInterval = c);\n      return k;\n    };\n\n    f.prototype.log2lin = function (c) {\n      return Math.log(c) / Math.LN10;\n    };\n\n    f.prototype.lin2log = function (c) {\n      return Math.pow(10, c);\n    };\n  });\n  K(C, \"parts/PlotLineOrBand.js\", [C[\"parts/Globals.js\"], C[\"parts/Axis.js\"], C[\"parts/Utilities.js\"]], function (c, f, H) {\n    var D = H.arrayMax,\n        A = H.arrayMin,\n        E = H.defined,\n        p = H.destroyObjectProperties,\n        y = H.erase,\n        G = H.extend,\n        v = H.objectEach,\n        q = H.pick,\n        k = c.merge;\n\n    c.PlotLineOrBand = function (c, k) {\n      this.axis = c;\n      k && (this.options = k, this.id = k.id);\n    };\n\n    c.PlotLineOrBand.prototype = {\n      render: function render() {\n        c.fireEvent(this, \"render\");\n        var f = this,\n            w = f.axis,\n            g = w.horiz,\n            e = f.options,\n            b = e.label,\n            d = f.label,\n            a = e.to,\n            h = e.from,\n            n = e.value,\n            F = E(h) && E(a),\n            r = E(n),\n            x = f.svgElem,\n            l = !x,\n            t = [],\n            B = e.color,\n            I = q(e.zIndex, 0),\n            z = e.events;\n        t = {\n          \"class\": \"highcharts-plot-\" + (F ? \"band \" : \"line \") + (e.className || \"\")\n        };\n        var u = {},\n            L = w.chart.renderer,\n            M = F ? \"bands\" : \"lines\";\n        w.isLog && (h = w.log2lin(h), a = w.log2lin(a), n = w.log2lin(n));\n        w.chart.styledMode || (r ? (t.stroke = B || \"#999999\", t[\"stroke-width\"] = q(e.width, 1), e.dashStyle && (t.dashstyle = e.dashStyle)) : F && (t.fill = B || \"#e6ebf5\", e.borderWidth && (t.stroke = e.borderColor, t[\"stroke-width\"] = e.borderWidth)));\n        u.zIndex = I;\n        M += \"-\" + I;\n        (B = w.plotLinesAndBandsGroups[M]) || (w.plotLinesAndBandsGroups[M] = B = L.g(\"plot-\" + M).attr(u).add());\n        l && (f.svgElem = x = L.path().attr(t).add(B));\n        if (r) t = w.getPlotLinePath({\n          value: n,\n          lineWidth: x.strokeWidth(),\n          acrossPanes: e.acrossPanes\n        });else if (F) t = w.getPlotBandPath(h, a, e);else return;\n        (l || !x.d) && t && t.length ? (x.attr({\n          d: t\n        }), z && v(z, function (a, b) {\n          x.on(b, function (a) {\n            z[b].apply(f, [a]);\n          });\n        })) : x && (t ? (x.show(!0), x.animate({\n          d: t\n        })) : x.d && (x.hide(), d && (f.label = d = d.destroy())));\n        b && (E(b.text) || E(b.formatter)) && t && t.length && 0 < w.width && 0 < w.height && !t.isFlat ? (b = k({\n          align: g && F && \"center\",\n          x: g ? !F && 4 : 10,\n          verticalAlign: !g && F && \"middle\",\n          y: g ? F ? 16 : 10 : F ? 6 : -4,\n          rotation: g && !F && 90\n        }, b), this.renderLabel(b, t, F, I)) : d && d.hide();\n        return f;\n      },\n      renderLabel: function renderLabel(c, k, g, e) {\n        var b = this.label,\n            d = this.axis.chart.renderer;\n        b || (b = {\n          align: c.textAlign || c.align,\n          rotation: c.rotation,\n          \"class\": \"highcharts-plot-\" + (g ? \"band\" : \"line\") + \"-label \" + (c.className || \"\")\n        }, b.zIndex = e, e = this.getLabelText(c), this.label = b = d.text(e, 0, 0, c.useHTML).attr(b).add(), this.axis.chart.styledMode || b.css(c.style));\n        d = k.xBounds || [k[1], k[4], g ? k[6] : k[1]];\n        k = k.yBounds || [k[2], k[5], g ? k[7] : k[2]];\n        g = A(d);\n        e = A(k);\n        b.align(c, !1, {\n          x: g,\n          y: e,\n          width: D(d) - g,\n          height: D(k) - e\n        });\n        b.show(!0);\n      },\n      getLabelText: function getLabelText(c) {\n        return E(c.formatter) ? c.formatter.call(this) : c.text;\n      },\n      destroy: function destroy() {\n        y(this.axis.plotLinesAndBands, this);\n        delete this.axis;\n        p(this);\n      }\n    };\n    G(f.prototype, {\n      getPlotBandPath: function getPlotBandPath(c, k) {\n        var g = this.getPlotLinePath({\n          value: k,\n          force: !0,\n          acrossPanes: this.options.acrossPanes\n        }),\n            e = this.getPlotLinePath({\n          value: c,\n          force: !0,\n          acrossPanes: this.options.acrossPanes\n        }),\n            b = [],\n            d = this.horiz,\n            a = 1;\n        c = c < this.min && k < this.min || c > this.max && k > this.max;\n\n        if (e && g) {\n          if (c) {\n            var h = e.toString() === g.toString();\n            a = 0;\n          }\n\n          for (c = 0; c < e.length; c += 6) {\n            d && g[c + 1] === e[c + 1] ? (g[c + 1] += a, g[c + 4] += a) : d || g[c + 2] !== e[c + 2] || (g[c + 2] += a, g[c + 5] += a), b.push(\"M\", e[c + 1], e[c + 2], \"L\", e[c + 4], e[c + 5], g[c + 4], g[c + 5], g[c + 1], g[c + 2], \"z\"), b.isFlat = h;\n          }\n        }\n\n        return b;\n      },\n      addPlotBand: function addPlotBand(c) {\n        return this.addPlotBandOrLine(c, \"plotBands\");\n      },\n      addPlotLine: function addPlotLine(c) {\n        return this.addPlotBandOrLine(c, \"plotLines\");\n      },\n      addPlotBandOrLine: function addPlotBandOrLine(k, f) {\n        var g = new c.PlotLineOrBand(this, k).render(),\n            e = this.userOptions;\n\n        if (g) {\n          if (f) {\n            var b = e[f] || [];\n            b.push(k);\n            e[f] = b;\n          }\n\n          this.plotLinesAndBands.push(g);\n        }\n\n        return g;\n      },\n      removePlotBandOrLine: function removePlotBandOrLine(c) {\n        for (var k = this.plotLinesAndBands, g = this.options, e = this.userOptions, b = k.length; b--;) {\n          k[b].id === c && k[b].destroy();\n        }\n\n        [g.plotLines || [], e.plotLines || [], g.plotBands || [], e.plotBands || []].forEach(function (d) {\n          for (b = d.length; b--;) {\n            d[b].id === c && y(d, d[b]);\n          }\n        });\n      },\n      removePlotBand: function removePlotBand(c) {\n        this.removePlotBandOrLine(c);\n      },\n      removePlotLine: function removePlotLine(c) {\n        this.removePlotBandOrLine(c);\n      }\n    });\n  });\n  K(C, \"parts/Tooltip.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var H = f.defined,\n        D = f.discardElement,\n        A = f.extend,\n        E = f.isNumber,\n        p = f.isString,\n        y = f.pick,\n        G = f.splat,\n        v = f.syncTimeout;\n    \"\";\n    var q = c.doc,\n        k = c.format,\n        m = c.merge,\n        w = c.timeUnits;\n\n    c.Tooltip = function () {\n      this.init.apply(this, arguments);\n    };\n\n    c.Tooltip.prototype = {\n      init: function init(c, e) {\n        this.chart = c;\n        this.options = e;\n        this.crosshairs = [];\n        this.now = {\n          x: 0,\n          y: 0\n        };\n        this.isHidden = !0;\n        this.split = e.split && !c.inverted;\n        this.shared = e.shared || this.split;\n        this.outside = y(e.outside, !(!c.scrollablePixelsX && !c.scrollablePixelsY));\n      },\n      cleanSplit: function cleanSplit(c) {\n        this.chart.series.forEach(function (e) {\n          var b = e && e.tt;\n          b && (!b.isActive || c ? e.tt = b.destroy() : b.isActive = !1);\n        });\n      },\n      applyFilter: function applyFilter() {\n        var c = this.chart;\n        c.renderer.definition({\n          tagName: \"filter\",\n          id: \"drop-shadow-\" + c.index,\n          opacity: .5,\n          children: [{\n            tagName: \"feGaussianBlur\",\n            \"in\": \"SourceAlpha\",\n            stdDeviation: 1\n          }, {\n            tagName: \"feOffset\",\n            dx: 1,\n            dy: 1\n          }, {\n            tagName: \"feComponentTransfer\",\n            children: [{\n              tagName: \"feFuncA\",\n              type: \"linear\",\n              slope: .3\n            }]\n          }, {\n            tagName: \"feMerge\",\n            children: [{\n              tagName: \"feMergeNode\"\n            }, {\n              tagName: \"feMergeNode\",\n              \"in\": \"SourceGraphic\"\n            }]\n          }]\n        });\n        c.renderer.definition({\n          tagName: \"style\",\n          textContent: \".highcharts-tooltip-\" + c.index + \"{filter:url(#drop-shadow-\" + c.index + \")}\"\n        });\n      },\n      getLabel: function getLabel() {\n        var g = this,\n            e = this.chart.renderer,\n            b = this.chart.styledMode,\n            d = this.options,\n            a = \"tooltip\" + (H(d.className) ? \" \" + d.className : \"\"),\n            h;\n\n        if (!this.label) {\n          this.outside && (this.container = h = c.doc.createElement(\"div\"), h.className = \"highcharts-tooltip-container\", c.css(h, {\n            position: \"absolute\",\n            top: \"1px\",\n            pointerEvents: d.style && d.style.pointerEvents,\n            zIndex: 3\n          }), c.doc.body.appendChild(h), this.renderer = e = new c.Renderer(h, 0, 0, {}, void 0, void 0, e.styledMode));\n          this.split ? this.label = e.g(a) : (this.label = e.label(\"\", 0, 0, d.shape || \"callout\", null, null, d.useHTML, null, a).attr({\n            padding: d.padding,\n            r: d.borderRadius\n          }), b || this.label.attr({\n            fill: d.backgroundColor,\n            \"stroke-width\": d.borderWidth\n          }).css(d.style).shadow(d.shadow));\n          b && (this.applyFilter(), this.label.addClass(\"highcharts-tooltip-\" + this.chart.index));\n\n          if (g.outside && !g.split) {\n            var n = {\n              x: this.label.xSetter,\n              y: this.label.ySetter\n            };\n\n            this.label.xSetter = function (a, b) {\n              n[b].call(this.label, g.distance);\n              h.style.left = a + \"px\";\n            };\n\n            this.label.ySetter = function (a, b) {\n              n[b].call(this.label, g.distance);\n              h.style.top = a + \"px\";\n            };\n          }\n\n          this.label.attr({\n            zIndex: 8\n          }).add();\n        }\n\n        return this.label;\n      },\n      update: function update(c) {\n        this.destroy();\n        m(!0, this.chart.options.tooltip.userOptions, c);\n        this.init(this.chart, m(!0, this.options, c));\n      },\n      destroy: function destroy() {\n        this.label && (this.label = this.label.destroy());\n        this.split && this.tt && (this.cleanSplit(this.chart, !0), this.tt = this.tt.destroy());\n        this.renderer && (this.renderer = this.renderer.destroy(), D(this.container));\n        c.clearTimeout(this.hideTimer);\n        c.clearTimeout(this.tooltipTimeout);\n      },\n      move: function move(g, e, b, d) {\n        var a = this,\n            h = a.now,\n            n = !1 !== a.options.animation && !a.isHidden && (1 < Math.abs(g - h.x) || 1 < Math.abs(e - h.y)),\n            k = a.followPointer || 1 < a.len;\n        A(h, {\n          x: n ? (2 * h.x + g) / 3 : g,\n          y: n ? (h.y + e) / 2 : e,\n          anchorX: k ? void 0 : n ? (2 * h.anchorX + b) / 3 : b,\n          anchorY: k ? void 0 : n ? (h.anchorY + d) / 2 : d\n        });\n        a.getLabel().attr(h);\n        n && (c.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {\n          a && a.move(g, e, b, d);\n        }, 32));\n      },\n      hide: function hide(g) {\n        var e = this;\n        c.clearTimeout(this.hideTimer);\n        g = y(g, this.options.hideDelay, 500);\n        this.isHidden || (this.hideTimer = v(function () {\n          e.getLabel()[g ? \"fadeOut\" : \"hide\"]();\n          e.isHidden = !0;\n        }, g));\n      },\n      getAnchor: function getAnchor(c, e) {\n        var b = this.chart,\n            d = b.pointer,\n            a = b.inverted,\n            h = b.plotTop,\n            n = b.plotLeft,\n            g = 0,\n            r = 0,\n            k,\n            l;\n        c = G(c);\n        this.followPointer && e ? (void 0 === e.chartX && (e = d.normalize(e)), c = [e.chartX - b.plotLeft, e.chartY - h]) : c[0].tooltipPos ? c = c[0].tooltipPos : (c.forEach(function (b) {\n          k = b.series.yAxis;\n          l = b.series.xAxis;\n          g += b.plotX + (!a && l ? l.left - n : 0);\n          r += (b.plotLow ? (b.plotLow + b.plotHigh) / 2 : b.plotY) + (!a && k ? k.top - h : 0);\n        }), g /= c.length, r /= c.length, c = [a ? b.plotWidth - r : g, this.shared && !a && 1 < c.length && e ? e.chartY - h : a ? b.plotHeight - g : r]);\n        return c.map(Math.round);\n      },\n      getPosition: function getPosition(c, e, b) {\n        var d = this.chart,\n            a = this.distance,\n            h = {},\n            n = d.inverted && b.h || 0,\n            g,\n            r = this.outside,\n            k = r ? q.documentElement.clientWidth - 2 * a : d.chartWidth,\n            l = r ? Math.max(q.body.scrollHeight, q.documentElement.scrollHeight, q.body.offsetHeight, q.documentElement.offsetHeight, q.documentElement.clientHeight) : d.chartHeight,\n            t = d.pointer.getChartPosition(),\n            B = d.containerScaling,\n            f = function f(a) {\n          return B ? a * B.scaleX : a;\n        },\n            z = function z(a) {\n          return B ? a * B.scaleY : a;\n        },\n            u = function u(h) {\n          var n = \"x\" === h;\n          return [h, n ? k : l, n ? c : e].concat(r ? [n ? f(c) : z(e), n ? t.left - a + f(b.plotX + d.plotLeft) : t.top - a + z(b.plotY + d.plotTop), 0, n ? k : l] : [n ? c : e, n ? b.plotX + d.plotLeft : b.plotY + d.plotTop, n ? d.plotLeft : d.plotTop, n ? d.plotLeft + d.plotWidth : d.plotTop + d.plotHeight]);\n        },\n            m = u(\"y\"),\n            M = u(\"x\"),\n            w = !this.followPointer && y(b.ttBelow, !d.inverted === !!b.negative),\n            p = function p(b, d, e, c, l, t, r) {\n          var g = \"y\" === b ? z(a) : f(a),\n              u = (e - c) / 2,\n              B = c < l - a,\n              k = l + a + c < d,\n              x = l - g - e + u;\n          l = l + g - u;\n          if (w && k) h[b] = l;else if (!w && B) h[b] = x;else if (B) h[b] = Math.min(r - c, 0 > x - n ? x : x - n);else if (k) h[b] = Math.max(t, l + n + e > d ? l : l + n);else return !1;\n        },\n            v = function v(b, d, e, c, l) {\n          var t;\n          l < a || l > d - a ? t = !1 : h[b] = l < e / 2 ? 1 : l > d - c / 2 ? d - c - 2 : l - e / 2;\n          return t;\n        },\n            A = function A(a) {\n          var b = m;\n          m = M;\n          M = b;\n          g = a;\n        },\n            J = function J() {\n          !1 !== p.apply(0, m) ? !1 !== v.apply(0, M) || g || (A(!0), J()) : g ? h.x = h.y = 0 : (A(!0), J());\n        };\n\n        (d.inverted || 1 < this.len) && A();\n        J();\n        return h;\n      },\n      defaultFormatter: function defaultFormatter(c) {\n        var e = this.points || G(this);\n        var b = [c.tooltipFooterHeaderFormatter(e[0])];\n        b = b.concat(c.bodyFormatter(e));\n        b.push(c.tooltipFooterHeaderFormatter(e[0], !0));\n        return b;\n      },\n      refresh: function refresh(g, e) {\n        var b = this.chart,\n            d = this.options,\n            a = g,\n            h = {},\n            n = [],\n            k = d.formatter || this.defaultFormatter;\n        h = this.shared;\n        var r = b.styledMode;\n\n        if (d.enabled) {\n          c.clearTimeout(this.hideTimer);\n          this.followPointer = G(a)[0].series.tooltipOptions.followPointer;\n          var x = this.getAnchor(a, e);\n          e = x[0];\n          var l = x[1];\n          !h || a.series && a.series.noSharedTooltip ? h = a.getLabelConfig() : (b.pointer.applyInactiveState(a), a.forEach(function (a) {\n            a.setState(\"hover\");\n            n.push(a.getLabelConfig());\n          }), h = {\n            x: a[0].category,\n            y: a[0].y\n          }, h.points = n, a = a[0]);\n          this.len = n.length;\n          b = k.call(h, this);\n          k = a.series;\n          this.distance = y(k.tooltipOptions.distance, 16);\n          !1 === b ? this.hide() : (this.split ? this.renderSplit(b, G(g)) : (g = this.getLabel(), d.style.width && !r || g.css({\n            width: this.chart.spacingBox.width\n          }), g.attr({\n            text: b && b.join ? b.join(\"\") : b\n          }), g.removeClass(/highcharts-color-[\\d]+/g).addClass(\"highcharts-color-\" + y(a.colorIndex, k.colorIndex)), r || g.attr({\n            stroke: d.borderColor || a.color || k.color || \"#666666\"\n          }), this.updatePosition({\n            plotX: e,\n            plotY: l,\n            negative: a.negative,\n            ttBelow: a.ttBelow,\n            h: x[2] || 0\n          })), this.isHidden && this.label && this.label.attr({\n            opacity: 1\n          }).show(), this.isHidden = !1);\n          c.fireEvent(this, \"refresh\");\n        }\n      },\n      renderSplit: function renderSplit(g, e) {\n        var b = this,\n            d = [],\n            a = this.chart,\n            h = a.renderer,\n            n = !0,\n            k = this.options,\n            r = 0,\n            x,\n            l = this.getLabel(),\n            t = a.plotTop;\n        p(g) && (g = [!1, g]);\n        g.slice(0, e.length + 1).forEach(function (c, g) {\n          if (!1 !== c && \"\" !== c) {\n            g = e[g - 1] || {\n              isHeader: !0,\n              plotX: e[0].plotX,\n              plotY: a.plotHeight\n            };\n            var u = g.series || b,\n                B = u.tt,\n                z = g.series || {},\n                f = \"highcharts-color-\" + y(g.colorIndex, z.colorIndex, \"none\");\n            B || (B = {\n              padding: k.padding,\n              r: k.borderRadius\n            }, a.styledMode || (B.fill = k.backgroundColor, B[\"stroke-width\"] = k.borderWidth), u.tt = B = h.label(null, null, null, (g.isHeader ? k.headerShape : k.shape) || \"callout\", null, null, k.useHTML).addClass(g.isHeader ? \"highcharts-tooltip-header \" : \"highcharts-tooltip-box \" + f).attr(B).add(l));\n            B.isActive = !0;\n            B.attr({\n              text: c\n            });\n            a.styledMode || B.css(k.style).shadow(k.shadow).attr({\n              stroke: k.borderColor || g.color || z.color || \"#333333\"\n            });\n            c = B.getBBox();\n            f = c.width + B.strokeWidth();\n            g.isHeader ? (r = c.height, a.xAxis[0].opposite && (x = !0, t -= r), c = Math.max(0, Math.min(g.plotX + a.plotLeft - f / 2, a.chartWidth + (a.scrollablePixelsX ? a.scrollablePixelsX - a.marginRight : 0) - f))) : c = g.plotX + a.plotLeft - y(k.distance, 16) - f;\n            0 > c && (n = !1);\n            g.isHeader ? z = x ? -r : a.plotHeight + r : (z = z.yAxis, z = z.pos - t + Math.max(0, Math.min(g.plotY || 0, z.len)));\n            d.push({\n              target: z,\n              rank: g.isHeader ? 1 : 0,\n              size: u.tt.getBBox().height + 1,\n              point: g,\n              x: c,\n              tt: B\n            });\n          }\n        });\n        this.cleanSplit();\n        k.positioner && d.forEach(function (a) {\n          var d = k.positioner.call(b, a.tt.getBBox().width, a.size, a.point);\n          a.x = d.x;\n          a.align = 0;\n          a.target = d.y;\n          a.rank = y(d.rank, a.rank);\n        });\n        c.distribute(d, a.plotHeight + r);\n        d.forEach(function (d) {\n          var e = d.point,\n              c = e.series,\n              h = c && c.yAxis;\n          d.tt.attr({\n            visibility: void 0 === d.pos ? \"hidden\" : \"inherit\",\n            x: n || e.isHeader || k.positioner ? d.x : e.plotX + a.plotLeft + b.distance,\n            y: d.pos + t,\n            anchorX: e.isHeader ? e.plotX + a.plotLeft : e.plotX + c.xAxis.pos,\n            anchorY: e.isHeader ? a.plotTop + a.plotHeight / 2 : h.pos + Math.max(0, Math.min(e.plotY, h.len))\n          });\n        });\n        var B = b.container;\n        g = b.renderer;\n\n        if (b.outside && B && g) {\n          var f = a.pointer.getChartPosition();\n          B.style.left = f.left + \"px\";\n          B.style.top = f.top + \"px\";\n          B = l.getBBox();\n          g.setSize(B.width + B.x, B.height + B.y, !1);\n        }\n      },\n      updatePosition: function updatePosition(g) {\n        var e = this.chart,\n            b = e.pointer,\n            d = this.getLabel(),\n            a = g.plotX + e.plotLeft,\n            h = g.plotY + e.plotTop;\n        b = b.getChartPosition();\n        g = (this.options.positioner || this.getPosition).call(this, d.width, d.height, g);\n\n        if (this.outside) {\n          var n = (this.options.borderWidth || 0) + 2 * this.distance;\n          this.renderer.setSize(d.width + n, d.height + n, !1);\n          if (e = e.containerScaling) c.css(this.container, {\n            transform: \"scale(\" + e.scaleX + \", \" + e.scaleY + \")\"\n          }), a *= e.scaleX, h *= e.scaleY;\n          a += b.left - g.x;\n          h += b.top - g.y;\n        }\n\n        this.move(Math.round(g.x), Math.round(g.y || 0), a, h);\n      },\n      getDateFormat: function getDateFormat(c, e, b, d) {\n        var a = this.chart.time,\n            h = a.dateFormat(\"%m-%d %H:%M:%S.%L\", e),\n            n = {\n          millisecond: 15,\n          second: 12,\n          minute: 9,\n          hour: 6,\n          day: 3\n        },\n            g = \"millisecond\";\n\n        for (r in w) {\n          if (c === w.week && +a.dateFormat(\"%w\", e) === b && \"00:00:00.000\" === h.substr(6)) {\n            var r = \"week\";\n            break;\n          }\n\n          if (w[r] > c) {\n            r = g;\n            break;\n          }\n\n          if (n[r] && h.substr(n[r]) !== \"01-01 00:00:00.000\".substr(n[r])) break;\n          \"week\" !== r && (g = r);\n        }\n\n        if (r) var k = a.resolveDTLFormat(d[r]).main;\n        return k;\n      },\n      getXDateFormat: function getXDateFormat(c, e, b) {\n        e = e.dateTimeLabelFormats;\n        var d = b && b.closestPointRange;\n        return (d ? this.getDateFormat(d, c.x, b.options.startOfWeek, e) : e.day) || e.year;\n      },\n      tooltipFooterHeaderFormatter: function tooltipFooterHeaderFormatter(g, e) {\n        var b = e ? \"footer\" : \"header\",\n            d = g.series,\n            a = d.tooltipOptions,\n            h = a.xDateFormat,\n            n = d.xAxis,\n            f = n && \"datetime\" === n.options.type && E(g.key),\n            r = a[b + \"Format\"];\n        e = {\n          isFooter: e,\n          labelConfig: g\n        };\n        c.fireEvent(this, \"headerFormatter\", e, function (b) {\n          f && !h && (h = this.getXDateFormat(g, a, n));\n          f && h && (g.point && g.point.tooltipDateKeys || [\"key\"]).forEach(function (a) {\n            r = r.replace(\"{point.\" + a + \"}\", \"{point.\" + a + \":\" + h + \"}\");\n          });\n          d.chart.styledMode && (r = this.styledModeFormat(r));\n          b.text = k(r, {\n            point: g,\n            series: d\n          }, this.chart.time);\n        });\n        return e.text;\n      },\n      bodyFormatter: function bodyFormatter(c) {\n        return c.map(function (e) {\n          var b = e.series.tooltipOptions;\n          return (b[(e.point.formatPrefix || \"point\") + \"Formatter\"] || e.point.tooltipFormatter).call(e.point, b[(e.point.formatPrefix || \"point\") + \"Format\"] || \"\");\n        });\n      },\n      styledModeFormat: function styledModeFormat(c) {\n        return c.replace('style=\"font-size: 10px\"', 'class=\"highcharts-header\"').replace(/style=\"color:{(point|series)\\.color}\"/g, 'class=\"highcharts-color-{$1.colorIndex}\"');\n      }\n    };\n  });\n  K(C, \"parts/Pointer.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var H = f.attr,\n        D = f.defined,\n        A = f.extend,\n        E = f.isNumber,\n        p = f.isObject,\n        y = f.objectEach,\n        G = f.pick,\n        v = f.splat,\n        q = c.addEvent,\n        k = c.charts,\n        m = c.color,\n        w = c.css,\n        g = c.find,\n        e = c.fireEvent,\n        b = c.offset,\n        d = c.Tooltip;\n\n    c.Pointer = function (a, b) {\n      this.init(a, b);\n    };\n\n    c.Pointer.prototype = {\n      init: function init(a, b) {\n        this.options = b;\n        this.chart = a;\n        this.runChartClick = b.chart.events && !!b.chart.events.click;\n        this.pinchDown = [];\n        this.lastValidTouch = {};\n        d && (a.tooltip = new d(a, b.tooltip), this.followTouchMove = G(b.tooltip.followTouchMove, !0));\n        this.setDOMEvents();\n      },\n      zoomOption: function zoomOption(a) {\n        var b = this.chart,\n            d = b.options.chart,\n            e = d.zoomType || \"\";\n        b = b.inverted;\n        /touch/.test(a.type) && (e = G(d.pinchType, e));\n        this.zoomX = a = /x/.test(e);\n        this.zoomY = e = /y/.test(e);\n        this.zoomHor = a && !b || e && b;\n        this.zoomVert = e && !b || a && b;\n        this.hasZoom = a || e;\n      },\n      getChartPosition: function getChartPosition() {\n        return this.chartPosition || (this.chartPosition = b(this.chart.container));\n      },\n      normalize: function normalize(a, b) {\n        var d = a.touches ? a.touches.length ? a.touches.item(0) : a.changedTouches[0] : a;\n        b || (b = this.getChartPosition());\n        var e = d.pageX - b.left;\n        b = d.pageY - b.top;\n        if (d = this.chart.containerScaling) e /= d.scaleX, b /= d.scaleY;\n        return A(a, {\n          chartX: Math.round(e),\n          chartY: Math.round(b)\n        });\n      },\n      getCoordinates: function getCoordinates(a) {\n        var b = {\n          xAxis: [],\n          yAxis: []\n        };\n        this.chart.axes.forEach(function (d) {\n          b[d.isXAxis ? \"xAxis\" : \"yAxis\"].push({\n            axis: d,\n            value: d.toValue(a[d.horiz ? \"chartX\" : \"chartY\"])\n          });\n        });\n        return b;\n      },\n      findNearestKDPoint: function findNearestKDPoint(a, b, d) {\n        var e;\n        a.forEach(function (a) {\n          var c = !(a.noSharedTooltip && b) && 0 > a.options.findNearestPointBy.indexOf(\"y\");\n          a = a.searchPoint(d, c);\n\n          if ((c = p(a, !0)) && !(c = !p(e, !0))) {\n            c = e.distX - a.distX;\n            var h = e.dist - a.dist,\n                t = (a.series.group && a.series.group.zIndex) - (e.series.group && e.series.group.zIndex);\n            c = 0 < (0 !== c && b ? c : 0 !== h ? h : 0 !== t ? t : e.series.index > a.series.index ? -1 : 1);\n          }\n\n          c && (e = a);\n        });\n        return e;\n      },\n      getPointFromEvent: function getPointFromEvent(a) {\n        a = a.target;\n\n        for (var b; a && !b;) {\n          b = a.point, a = a.parentNode;\n        }\n\n        return b;\n      },\n      getChartCoordinatesFromPoint: function getChartCoordinatesFromPoint(a, b) {\n        var d = a.series,\n            e = d.xAxis;\n        d = d.yAxis;\n        var c = G(a.clientX, a.plotX),\n            h = a.shapeArgs;\n        if (e && d) return b ? {\n          chartX: e.len + e.pos - c,\n          chartY: d.len + d.pos - a.plotY\n        } : {\n          chartX: c + e.pos,\n          chartY: a.plotY + d.pos\n        };\n        if (h && h.x && h.y) return {\n          chartX: h.x,\n          chartY: h.y\n        };\n      },\n      getHoverData: function getHoverData(a, b, d, e, c, k) {\n        var h,\n            t = [];\n        e = !(!e || !a);\n        var n = b && !b.stickyTracking ? [b] : d.filter(function (a) {\n          return a.visible && !(!c && a.directTouch) && G(a.options.enableMouseTracking, !0) && a.stickyTracking;\n        });\n        b = (h = e || !k ? a : this.findNearestKDPoint(n, c, k)) && h.series;\n        h && (c && !b.noSharedTooltip ? (n = d.filter(function (a) {\n          return a.visible && !(!c && a.directTouch) && G(a.options.enableMouseTracking, !0) && !a.noSharedTooltip;\n        }), n.forEach(function (a) {\n          var b = g(a.points, function (a) {\n            return a.x === h.x && !a.isNull;\n          });\n          p(b) && (a.chart.isBoosting && (b = a.getPoint(b)), t.push(b));\n        })) : t.push(h));\n        return {\n          hoverPoint: h,\n          hoverSeries: b,\n          hoverPoints: t\n        };\n      },\n      runPointActions: function runPointActions(a, b) {\n        var d = this.chart,\n            e = d.tooltip && d.tooltip.options.enabled ? d.tooltip : void 0,\n            h = e ? e.shared : !1,\n            g = b || d.hoverPoint,\n            l = g && g.series || d.hoverSeries;\n        l = this.getHoverData(g, l, d.series, (!a || \"touchmove\" !== a.type) && (!!b || l && l.directTouch && this.isDirectTouch), h, a);\n        g = l.hoverPoint;\n        var t = l.hoverPoints;\n        b = (l = l.hoverSeries) && l.tooltipOptions.followPointer;\n        h = h && l && !l.noSharedTooltip;\n\n        if (g && (g !== d.hoverPoint || e && e.isHidden)) {\n          (d.hoverPoints || []).forEach(function (a) {\n            -1 === t.indexOf(a) && a.setState();\n          });\n          if (d.hoverSeries !== l) l.onMouseOver();\n          this.applyInactiveState(t);\n          (t || []).forEach(function (a) {\n            a.setState(\"hover\");\n          });\n          d.hoverPoint && d.hoverPoint.firePointEvent(\"mouseOut\");\n          if (!g.series) return;\n          g.firePointEvent(\"mouseOver\");\n          d.hoverPoints = t;\n          d.hoverPoint = g;\n          e && e.refresh(h ? t : g, a);\n        } else b && e && !e.isHidden && (g = e.getAnchor([{}], a), e.updatePosition({\n          plotX: g[0],\n          plotY: g[1]\n        }));\n\n        this.unDocMouseMove || (this.unDocMouseMove = q(d.container.ownerDocument, \"mousemove\", function (a) {\n          var b = k[c.hoverChartIndex];\n          if (b) b.pointer.onDocumentMouseMove(a);\n        }));\n        d.axes.forEach(function (b) {\n          var d = G(b.crosshair.snap, !0),\n              e = d ? c.find(t, function (a) {\n            return a.series[b.coll] === b;\n          }) : void 0;\n          e || !d ? b.drawCrosshair(a, e) : b.hideCrosshair();\n        });\n      },\n      applyInactiveState: function applyInactiveState(a) {\n        var b = [],\n            d;\n        (a || []).forEach(function (a) {\n          d = a.series;\n          b.push(d);\n          d.linkedParent && b.push(d.linkedParent);\n          d.linkedSeries && (b = b.concat(d.linkedSeries));\n          d.navigatorSeries && b.push(d.navigatorSeries);\n        });\n        this.chart.series.forEach(function (a) {\n          -1 === b.indexOf(a) ? a.setState(\"inactive\", !0) : a.options.inactiveOtherPoints && a.setAllPointsToState(\"inactive\");\n        });\n      },\n      reset: function reset(a, b) {\n        var d = this.chart,\n            e = d.hoverSeries,\n            c = d.hoverPoint,\n            h = d.hoverPoints,\n            l = d.tooltip,\n            t = l && l.shared ? h : c;\n        a && t && v(t).forEach(function (b) {\n          b.series.isCartesian && void 0 === b.plotX && (a = !1);\n        });\n        if (a) l && t && v(t).length && (l.refresh(t), l.shared && h ? h.forEach(function (a) {\n          a.setState(a.state, !0);\n          a.series.isCartesian && (a.series.xAxis.crosshair && a.series.xAxis.drawCrosshair(null, a), a.series.yAxis.crosshair && a.series.yAxis.drawCrosshair(null, a));\n        }) : c && (c.setState(c.state, !0), d.axes.forEach(function (a) {\n          a.crosshair && a.drawCrosshair(null, c);\n        })));else {\n          if (c) c.onMouseOut();\n          h && h.forEach(function (a) {\n            a.setState();\n          });\n          if (e) e.onMouseOut();\n          l && l.hide(b);\n          this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());\n          d.axes.forEach(function (a) {\n            a.hideCrosshair();\n          });\n          this.hoverX = d.hoverPoints = d.hoverPoint = null;\n        }\n      },\n      scaleGroups: function scaleGroups(a, b) {\n        var d = this.chart,\n            e;\n        d.series.forEach(function (c) {\n          e = a || c.getPlotBox();\n          c.xAxis && c.xAxis.zoomEnabled && c.group && (c.group.attr(e), c.markerGroup && (c.markerGroup.attr(e), c.markerGroup.clip(b ? d.clipRect : null)), c.dataLabelsGroup && c.dataLabelsGroup.attr(e));\n        });\n        d.clipRect.attr(b || d.clipBox);\n      },\n      dragStart: function dragStart(a) {\n        var b = this.chart;\n        b.mouseIsDown = a.type;\n        b.cancelClick = !1;\n        b.mouseDownX = this.mouseDownX = a.chartX;\n        b.mouseDownY = this.mouseDownY = a.chartY;\n      },\n      drag: function drag(a) {\n        var b = this.chart,\n            d = b.options.chart,\n            e = a.chartX,\n            c = a.chartY,\n            g = this.zoomHor,\n            l = this.zoomVert,\n            t = b.plotLeft,\n            k = b.plotTop,\n            f = b.plotWidth,\n            z = b.plotHeight,\n            u = this.selectionMarker,\n            q = this.mouseDownX,\n            w = this.mouseDownY,\n            p = d.panKey && a[d.panKey + \"Key\"];\n        if (!u || !u.touch) if (e < t ? e = t : e > t + f && (e = t + f), c < k ? c = k : c > k + z && (c = k + z), this.hasDragged = Math.sqrt(Math.pow(q - e, 2) + Math.pow(w - c, 2)), 10 < this.hasDragged) {\n          var y = b.isInsidePlot(q - t, w - k);\n          b.hasCartesianSeries && (this.zoomX || this.zoomY) && y && !p && !u && (this.selectionMarker = u = b.renderer.rect(t, k, g ? 1 : f, l ? 1 : z, 0).attr({\n            \"class\": \"highcharts-selection-marker\",\n            zIndex: 7\n          }).add(), b.styledMode || u.attr({\n            fill: d.selectionMarkerFill || m(\"#335cad\").setOpacity(.25).get()\n          }));\n          u && g && (e -= q, u.attr({\n            width: Math.abs(e),\n            x: (0 < e ? 0 : e) + q\n          }));\n          u && l && (e = c - w, u.attr({\n            height: Math.abs(e),\n            y: (0 < e ? 0 : e) + w\n          }));\n          y && !u && d.panning && b.pan(a, d.panning);\n        }\n      },\n      drop: function drop(a) {\n        var b = this,\n            d = this.chart,\n            c = this.hasPinched;\n\n        if (this.selectionMarker) {\n          var g = {\n            originalEvent: a,\n            xAxis: [],\n            yAxis: []\n          },\n              k = this.selectionMarker,\n              l = k.attr ? k.attr(\"x\") : k.x,\n              t = k.attr ? k.attr(\"y\") : k.y,\n              B = k.attr ? k.attr(\"width\") : k.width,\n              f = k.attr ? k.attr(\"height\") : k.height,\n              z;\n          if (this.hasDragged || c) d.axes.forEach(function (d) {\n            if (d.zoomEnabled && D(d.min) && (c || b[{\n              xAxis: \"zoomX\",\n              yAxis: \"zoomY\"\n            }[d.coll]])) {\n              var e = d.horiz,\n                  h = \"touchend\" === a.type ? d.minPixelPadding : 0,\n                  k = d.toValue((e ? l : t) + h);\n              e = d.toValue((e ? l + B : t + f) - h);\n              g[d.coll].push({\n                axis: d,\n                min: Math.min(k, e),\n                max: Math.max(k, e)\n              });\n              z = !0;\n            }\n          }), z && e(d, \"selection\", g, function (a) {\n            d.zoom(A(a, c ? {\n              animation: !1\n            } : null));\n          });\n          E(d.index) && (this.selectionMarker = this.selectionMarker.destroy());\n          c && this.scaleGroups();\n        }\n\n        d && E(d.index) && (w(d.container, {\n          cursor: d._cursor\n        }), d.cancelClick = 10 < this.hasDragged, d.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);\n      },\n      onContainerMouseDown: function onContainerMouseDown(a) {\n        a = this.normalize(a);\n        2 !== a.button && (this.zoomOption(a), a.preventDefault && a.preventDefault(), this.dragStart(a));\n      },\n      onDocumentMouseUp: function onDocumentMouseUp(a) {\n        k[c.hoverChartIndex] && k[c.hoverChartIndex].pointer.drop(a);\n      },\n      onDocumentMouseMove: function onDocumentMouseMove(a) {\n        var b = this.chart,\n            d = this.chartPosition;\n        a = this.normalize(a, d);\n        !d || this.inClass(a.target, \"highcharts-tracker\") || b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) || this.reset();\n      },\n      onContainerMouseLeave: function onContainerMouseLeave(a) {\n        var b = k[c.hoverChartIndex];\n        b && (a.relatedTarget || a.toElement) && (b.pointer.reset(), b.pointer.chartPosition = void 0);\n      },\n      onContainerMouseMove: function onContainerMouseMove(a) {\n        var b = this.chart;\n        D(c.hoverChartIndex) && k[c.hoverChartIndex] && k[c.hoverChartIndex].mouseIsDown || (c.hoverChartIndex = b.index);\n        a = this.normalize(a);\n        a.preventDefault || (a.returnValue = !1);\n        \"mousedown\" === b.mouseIsDown && this.drag(a);\n        !this.inClass(a.target, \"highcharts-tracker\") && !b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) || b.openMenu || this.runPointActions(a);\n      },\n      inClass: function inClass(a, b) {\n        for (var d; a;) {\n          if (d = H(a, \"class\")) {\n            if (-1 !== d.indexOf(b)) return !0;\n            if (-1 !== d.indexOf(\"highcharts-container\")) return !1;\n          }\n\n          a = a.parentNode;\n        }\n      },\n      onTrackerMouseOut: function onTrackerMouseOut(a) {\n        var b = this.chart.hoverSeries;\n        a = a.relatedTarget || a.toElement;\n        this.isDirectTouch = !1;\n        if (!(!b || !a || b.stickyTracking || this.inClass(a, \"highcharts-tooltip\") || this.inClass(a, \"highcharts-series-\" + b.index) && this.inClass(a, \"highcharts-tracker\"))) b.onMouseOut();\n      },\n      onContainerClick: function onContainerClick(a) {\n        var b = this.chart,\n            d = b.hoverPoint,\n            c = b.plotLeft,\n            g = b.plotTop;\n        a = this.normalize(a);\n        b.cancelClick || (d && this.inClass(a.target, \"highcharts-tracker\") ? (e(d.series, \"click\", A(a, {\n          point: d\n        })), b.hoverPoint && d.firePointEvent(\"click\", a)) : (A(a, this.getCoordinates(a)), b.isInsidePlot(a.chartX - c, a.chartY - g) && e(b, \"click\", a)));\n      },\n      setDOMEvents: function setDOMEvents() {\n        var a = this,\n            b = a.chart.container,\n            d = b.ownerDocument;\n\n        b.onmousedown = function (b) {\n          a.onContainerMouseDown(b);\n        };\n\n        b.onmousemove = function (b) {\n          a.onContainerMouseMove(b);\n        };\n\n        b.onclick = function (b) {\n          a.onContainerClick(b);\n        };\n\n        this.unbindContainerMouseLeave = q(b, \"mouseleave\", a.onContainerMouseLeave);\n        c.unbindDocumentMouseUp || (c.unbindDocumentMouseUp = q(d, \"mouseup\", a.onDocumentMouseUp));\n        c.hasTouch && (q(b, \"touchstart\", function (b) {\n          a.onContainerTouchStart(b);\n        }), q(b, \"touchmove\", function (b) {\n          a.onContainerTouchMove(b);\n        }), c.unbindDocumentTouchEnd || (c.unbindDocumentTouchEnd = q(d, \"touchend\", a.onDocumentTouchEnd)));\n      },\n      destroy: function destroy() {\n        var a = this;\n        a.unDocMouseMove && a.unDocMouseMove();\n        this.unbindContainerMouseLeave();\n        c.chartCount || (c.unbindDocumentMouseUp && (c.unbindDocumentMouseUp = c.unbindDocumentMouseUp()), c.unbindDocumentTouchEnd && (c.unbindDocumentTouchEnd = c.unbindDocumentTouchEnd()));\n        clearInterval(a.tooltipTimeout);\n        y(a, function (b, d) {\n          a[d] = null;\n        });\n      }\n    };\n  });\n  K(C, \"parts/TouchPointer.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var H = f.extend,\n        D = f.pick,\n        A = c.charts,\n        E = c.noop;\n    H(c.Pointer.prototype, {\n      pinchTranslate: function pinchTranslate(c, f, A, v, q, k) {\n        this.zoomHor && this.pinchTranslateDirection(!0, c, f, A, v, q, k);\n        this.zoomVert && this.pinchTranslateDirection(!1, c, f, A, v, q, k);\n      },\n      pinchTranslateDirection: function pinchTranslateDirection(c, f, A, v, q, k, m, w) {\n        var g = this.chart,\n            e = c ? \"x\" : \"y\",\n            b = c ? \"X\" : \"Y\",\n            d = \"chart\" + b,\n            a = c ? \"width\" : \"height\",\n            h = g[\"plot\" + (c ? \"Left\" : \"Top\")],\n            n,\n            F,\n            r = w || 1,\n            x = g.inverted,\n            l = g.bounds[c ? \"h\" : \"v\"],\n            t = 1 === f.length,\n            B = f[0][d],\n            I = A[0][d],\n            z = !t && f[1][d],\n            u = !t && A[1][d];\n\n        A = function A() {\n          !t && 20 < Math.abs(B - z) && (r = w || Math.abs(I - u) / Math.abs(B - z));\n          F = (h - I) / r + B;\n          n = g[\"plot\" + (c ? \"Width\" : \"Height\")] / r;\n        };\n\n        A();\n        f = F;\n\n        if (f < l.min) {\n          f = l.min;\n          var L = !0;\n        } else f + n > l.max && (f = l.max - n, L = !0);\n\n        L ? (I -= .8 * (I - m[e][0]), t || (u -= .8 * (u - m[e][1])), A()) : m[e] = [I, u];\n        x || (k[e] = F - h, k[a] = n);\n        k = x ? 1 / r : r;\n        q[a] = n;\n        q[e] = f;\n        v[x ? c ? \"scaleY\" : \"scaleX\" : \"scale\" + b] = r;\n        v[\"translate\" + b] = k * h + (I - k * B);\n      },\n      pinch: function pinch(c) {\n        var f = this,\n            p = f.chart,\n            v = f.pinchDown,\n            q = c.touches,\n            k = q.length,\n            m = f.lastValidTouch,\n            w = f.hasZoom,\n            g = f.selectionMarker,\n            e = {},\n            b = 1 === k && (f.inClass(c.target, \"highcharts-tracker\") && p.runTrackerClick || f.runChartClick),\n            d = {};\n        1 < k && (f.initiated = !0);\n        w && f.initiated && !b && c.preventDefault();\n        [].map.call(q, function (a) {\n          return f.normalize(a);\n        });\n        \"touchstart\" === c.type ? ([].forEach.call(q, function (a, b) {\n          v[b] = {\n            chartX: a.chartX,\n            chartY: a.chartY\n          };\n        }), m.x = [v[0].chartX, v[1] && v[1].chartX], m.y = [v[0].chartY, v[1] && v[1].chartY], p.axes.forEach(function (a) {\n          if (a.zoomEnabled) {\n            var b = p.bounds[a.horiz ? \"h\" : \"v\"],\n                d = a.minPixelPadding,\n                e = a.toPixels(Math.min(D(a.options.min, a.dataMin), a.dataMin)),\n                c = a.toPixels(Math.max(D(a.options.max, a.dataMax), a.dataMax)),\n                g = Math.max(e, c);\n            b.min = Math.min(a.pos, Math.min(e, c) - d);\n            b.max = Math.max(a.pos + a.len, g + d);\n          }\n        }), f.res = !0) : f.followTouchMove && 1 === k ? this.runPointActions(f.normalize(c)) : v.length && (g || (f.selectionMarker = g = H({\n          destroy: E,\n          touch: !0\n        }, p.plotBox)), f.pinchTranslate(v, q, e, g, d, m), f.hasPinched = w, f.scaleGroups(e, d), f.res && (f.res = !1, this.reset(!1, 0)));\n      },\n      touch: function touch(f, y) {\n        var p = this.chart,\n            v;\n        if (p.index !== c.hoverChartIndex) this.onContainerMouseLeave({\n          relatedTarget: !0\n        });\n        c.hoverChartIndex = p.index;\n        if (1 === f.touches.length) {\n          if (f = this.normalize(f), (v = p.isInsidePlot(f.chartX - p.plotLeft, f.chartY - p.plotTop)) && !p.openMenu) {\n            y && this.runPointActions(f);\n\n            if (\"touchmove\" === f.type) {\n              y = this.pinchDown;\n              var q = y[0] ? 4 <= Math.sqrt(Math.pow(y[0].chartX - f.chartX, 2) + Math.pow(y[0].chartY - f.chartY, 2)) : !1;\n            }\n\n            D(q, !0) && this.pinch(f);\n          } else y && this.reset();\n        } else 2 === f.touches.length && this.pinch(f);\n      },\n      onContainerTouchStart: function onContainerTouchStart(c) {\n        this.zoomOption(c);\n        this.touch(c, !0);\n      },\n      onContainerTouchMove: function onContainerTouchMove(c) {\n        this.touch(c);\n      },\n      onDocumentTouchEnd: function onDocumentTouchEnd(f) {\n        A[c.hoverChartIndex] && A[c.hoverChartIndex].pointer.drop(f);\n      }\n    });\n  });\n  K(C, \"parts/MSPointer.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var H = f.extend,\n        D = f.objectEach,\n        A = c.addEvent,\n        E = c.charts,\n        p = c.css,\n        y = c.doc,\n        G = c.noop;\n    f = c.Pointer;\n    var v = c.removeEvent,\n        q = c.win,\n        k = c.wrap;\n\n    if (!c.hasTouch && (q.PointerEvent || q.MSPointerEvent)) {\n      var m = {},\n          w = !!q.PointerEvent,\n          g = function g() {\n        var b = [];\n\n        b.item = function (b) {\n          return this[b];\n        };\n\n        D(m, function (d) {\n          b.push({\n            pageX: d.pageX,\n            pageY: d.pageY,\n            target: d.target\n          });\n        });\n        return b;\n      },\n          e = function e(b, d, a, _e) {\n        \"touch\" !== b.pointerType && b.pointerType !== b.MSPOINTER_TYPE_TOUCH || !E[c.hoverChartIndex] || (_e(b), _e = E[c.hoverChartIndex].pointer, _e[d]({\n          type: a,\n          target: b.currentTarget,\n          preventDefault: G,\n          touches: g()\n        }));\n      };\n\n      H(f.prototype, {\n        onContainerPointerDown: function onContainerPointerDown(b) {\n          e(b, \"onContainerTouchStart\", \"touchstart\", function (b) {\n            m[b.pointerId] = {\n              pageX: b.pageX,\n              pageY: b.pageY,\n              target: b.currentTarget\n            };\n          });\n        },\n        onContainerPointerMove: function onContainerPointerMove(b) {\n          e(b, \"onContainerTouchMove\", \"touchmove\", function (b) {\n            m[b.pointerId] = {\n              pageX: b.pageX,\n              pageY: b.pageY\n            };\n            m[b.pointerId].target || (m[b.pointerId].target = b.currentTarget);\n          });\n        },\n        onDocumentPointerUp: function onDocumentPointerUp(b) {\n          e(b, \"onDocumentTouchEnd\", \"touchend\", function (b) {\n            delete m[b.pointerId];\n          });\n        },\n        batchMSEvents: function batchMSEvents(b) {\n          b(this.chart.container, w ? \"pointerdown\" : \"MSPointerDown\", this.onContainerPointerDown);\n          b(this.chart.container, w ? \"pointermove\" : \"MSPointerMove\", this.onContainerPointerMove);\n          b(y, w ? \"pointerup\" : \"MSPointerUp\", this.onDocumentPointerUp);\n        }\n      });\n      k(f.prototype, \"init\", function (b, d, a) {\n        b.call(this, d, a);\n        this.hasZoom && p(d.container, {\n          \"-ms-touch-action\": \"none\",\n          \"touch-action\": \"none\"\n        });\n      });\n      k(f.prototype, \"setDOMEvents\", function (b) {\n        b.apply(this);\n        (this.hasZoom || this.followTouchMove) && this.batchMSEvents(A);\n      });\n      k(f.prototype, \"destroy\", function (b) {\n        this.batchMSEvents(v);\n        b.call(this);\n      });\n    }\n  });\n  K(C, \"parts/Legend.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var H = f.defined,\n        D = f.discardElement,\n        A = f.isNumber,\n        E = f.pick,\n        p = f.setAnimation,\n        y = c.addEvent,\n        G = c.css,\n        v = c.fireEvent;\n    f = c.isFirefox;\n    var q = c.marginNames,\n        k = c.merge,\n        m = c.stableSort,\n        w = c.win,\n        g = c.wrap;\n\n    c.Legend = function (e, b) {\n      this.init(e, b);\n    };\n\n    c.Legend.prototype = {\n      init: function init(e, b) {\n        this.chart = e;\n        this.setOptions(b);\n        b.enabled && (this.render(), y(this.chart, \"endResize\", function () {\n          this.legend.positionCheckboxes();\n        }), this.proximate ? this.unchartrender = y(this.chart, \"render\", function () {\n          this.legend.proximatePositions();\n          this.legend.positionItems();\n        }) : this.unchartrender && this.unchartrender());\n      },\n      setOptions: function setOptions(e) {\n        var b = E(e.padding, 8);\n        this.options = e;\n        this.chart.styledMode || (this.itemStyle = e.itemStyle, this.itemHiddenStyle = k(this.itemStyle, e.itemHiddenStyle));\n        this.itemMarginTop = e.itemMarginTop || 0;\n        this.itemMarginBottom = e.itemMarginBottom || 0;\n        this.padding = b;\n        this.initialItemY = b - 5;\n        this.symbolWidth = E(e.symbolWidth, 16);\n        this.pages = [];\n        this.proximate = \"proximate\" === e.layout && !this.chart.inverted;\n      },\n      update: function update(e, b) {\n        var d = this.chart;\n        this.setOptions(k(!0, this.options, e));\n        this.destroy();\n        d.isDirtyLegend = d.isDirtyBox = !0;\n        E(b, !0) && d.redraw();\n        v(this, \"afterUpdate\");\n      },\n      colorizeItem: function colorizeItem(e, b) {\n        e.legendGroup[b ? \"removeClass\" : \"addClass\"](\"highcharts-legend-item-hidden\");\n\n        if (!this.chart.styledMode) {\n          var d = this.options,\n              a = e.legendItem,\n              c = e.legendLine,\n              g = e.legendSymbol,\n              k = this.itemHiddenStyle.color;\n          d = b ? d.itemStyle.color : k;\n          var r = b ? e.color || k : k,\n              f = e.options && e.options.marker,\n              l = {\n            fill: r\n          };\n          a && a.css({\n            fill: d,\n            color: d\n          });\n          c && c.attr({\n            stroke: r\n          });\n          g && (f && g.isMarker && (l = e.pointAttribs(), b || (l.stroke = l.fill = k)), g.attr(l));\n        }\n\n        v(this, \"afterColorizeItem\", {\n          item: e,\n          visible: b\n        });\n      },\n      positionItems: function positionItems() {\n        this.allItems.forEach(this.positionItem, this);\n        this.chart.isResizing || this.positionCheckboxes();\n      },\n      positionItem: function positionItem(e) {\n        var b = this.options,\n            d = b.symbolPadding;\n        b = !b.rtl;\n        var a = e._legendItemPos,\n            c = a[0];\n        a = a[1];\n        var g = e.checkbox;\n        if ((e = e.legendGroup) && e.element) e[H(e.translateY) ? \"animate\" : \"attr\"]({\n          translateX: b ? c : this.legendWidth - c - 2 * d - 4,\n          translateY: a\n        });\n        g && (g.x = c, g.y = a);\n      },\n      destroyItem: function destroyItem(e) {\n        var b = e.checkbox;\n        [\"legendItem\", \"legendLine\", \"legendSymbol\", \"legendGroup\"].forEach(function (b) {\n          e[b] && (e[b] = e[b].destroy());\n        });\n        b && D(e.checkbox);\n      },\n      destroy: function destroy() {\n        function e(b) {\n          this[b] && (this[b] = this[b].destroy());\n        }\n\n        this.getAllItems().forEach(function (b) {\n          [\"legendItem\", \"legendGroup\"].forEach(e, b);\n        });\n        \"clipRect up down pager nav box title group\".split(\" \").forEach(e, this);\n        this.display = null;\n      },\n      positionCheckboxes: function positionCheckboxes() {\n        var e = this.group && this.group.alignAttr,\n            b = this.clipHeight || this.legendHeight,\n            d = this.titleHeight;\n\n        if (e) {\n          var a = e.translateY;\n          this.allItems.forEach(function (c) {\n            var h = c.checkbox;\n\n            if (h) {\n              var g = a + d + h.y + (this.scrollOffset || 0) + 3;\n              G(h, {\n                left: e.translateX + c.checkboxOffset + h.x - 20 + \"px\",\n                top: g + \"px\",\n                display: this.proximate || g > a - 6 && g < a + b - 6 ? \"\" : \"none\"\n              });\n            }\n          }, this);\n        }\n      },\n      renderTitle: function renderTitle() {\n        var e = this.options,\n            b = this.padding,\n            d = e.title,\n            a = 0;\n        d.text && (this.title || (this.title = this.chart.renderer.label(d.text, b - 3, b - 4, null, null, null, e.useHTML, null, \"legend-title\").attr({\n          zIndex: 1\n        }), this.chart.styledMode || this.title.css(d.style), this.title.add(this.group)), d.width || this.title.css({\n          width: this.maxLegendWidth + \"px\"\n        }), e = this.title.getBBox(), a = e.height, this.offsetWidth = e.width, this.contentGroup.attr({\n          translateY: a\n        }));\n        this.titleHeight = a;\n      },\n      setText: function setText(e) {\n        var b = this.options;\n        e.legendItem.attr({\n          text: b.labelFormat ? c.format(b.labelFormat, e, this.chart.time) : b.labelFormatter.call(e)\n        });\n      },\n      renderItem: function renderItem(e) {\n        var b = this.chart,\n            d = b.renderer,\n            a = this.options,\n            c = this.symbolWidth,\n            g = a.symbolPadding,\n            f = this.itemStyle,\n            r = this.itemHiddenStyle,\n            x = \"horizontal\" === a.layout ? E(a.itemDistance, 20) : 0,\n            l = !a.rtl,\n            t = e.legendItem,\n            B = !e.series,\n            I = !B && e.series.drawLegendSymbol ? e.series : e,\n            z = I.options;\n        z = this.createCheckboxForItem && z && z.showCheckbox;\n        x = c + g + x + (z ? 20 : 0);\n        var u = a.useHTML,\n            m = e.options.className;\n        t || (e.legendGroup = d.g(\"legend-item\").addClass(\"highcharts-\" + I.type + \"-series highcharts-color-\" + e.colorIndex + (m ? \" \" + m : \"\") + (B ? \" highcharts-series-\" + e.index : \"\")).attr({\n          zIndex: 1\n        }).add(this.scrollGroup), e.legendItem = t = d.text(\"\", l ? c + g : -g, this.baseline || 0, u), b.styledMode || t.css(k(e.visible ? f : r)), t.attr({\n          align: l ? \"left\" : \"right\",\n          zIndex: 2\n        }).add(e.legendGroup), this.baseline || (this.fontMetrics = d.fontMetrics(b.styledMode ? 12 : f.fontSize, t), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, t.attr(\"y\", this.baseline)), this.symbolHeight = a.symbolHeight || this.fontMetrics.f, I.drawLegendSymbol(this, e), this.setItemEvents && this.setItemEvents(e, t, u));\n        z && !e.checkbox && this.createCheckboxForItem(e);\n        this.colorizeItem(e, e.visible);\n        !b.styledMode && f.width || t.css({\n          width: (a.itemWidth || this.widthOption || b.spacingBox.width) - x\n        });\n        this.setText(e);\n        b = t.getBBox();\n        e.itemWidth = e.checkboxOffset = a.itemWidth || e.legendItemWidth || b.width + x;\n        this.maxItemWidth = Math.max(this.maxItemWidth, e.itemWidth);\n        this.totalItemWidth += e.itemWidth;\n        this.itemHeight = e.itemHeight = Math.round(e.legendItemHeight || b.height || this.symbolHeight);\n      },\n      layoutItem: function layoutItem(e) {\n        var b = this.options,\n            d = this.padding,\n            a = \"horizontal\" === b.layout,\n            c = e.itemHeight,\n            g = this.itemMarginBottom,\n            k = this.itemMarginTop,\n            r = a ? E(b.itemDistance, 20) : 0,\n            f = this.maxLegendWidth;\n        b = b.alignColumns && this.totalItemWidth > f ? this.maxItemWidth : e.itemWidth;\n        a && this.itemX - d + b > f && (this.itemX = d, this.lastLineHeight && (this.itemY += k + this.lastLineHeight + g), this.lastLineHeight = 0);\n        this.lastItemY = k + this.itemY + g;\n        this.lastLineHeight = Math.max(c, this.lastLineHeight);\n        e._legendItemPos = [this.itemX, this.itemY];\n        a ? this.itemX += b : (this.itemY += k + c + g, this.lastLineHeight = c);\n        this.offsetWidth = this.widthOption || Math.max((a ? this.itemX - d - (e.checkbox ? 0 : r) : b) + d, this.offsetWidth);\n      },\n      getAllItems: function getAllItems() {\n        var e = [];\n        this.chart.series.forEach(function (b) {\n          var d = b && b.options;\n          b && E(d.showInLegend, H(d.linkedTo) ? !1 : void 0, !0) && (e = e.concat(b.legendItems || (\"point\" === d.legendType ? b.data : b)));\n        });\n        v(this, \"afterGetAllItems\", {\n          allItems: e\n        });\n        return e;\n      },\n      getAlignment: function getAlignment() {\n        var e = this.options;\n        return this.proximate ? e.align.charAt(0) + \"tv\" : e.floating ? \"\" : e.align.charAt(0) + e.verticalAlign.charAt(0) + e.layout.charAt(0);\n      },\n      adjustMargins: function adjustMargins(e, b) {\n        var d = this.chart,\n            a = this.options,\n            c = this.getAlignment();\n        c && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (h, g) {\n          h.test(c) && !H(e[g]) && (d[q[g]] = Math.max(d[q[g]], d.legend[(g + 1) % 2 ? \"legendHeight\" : \"legendWidth\"] + [1, -1, -1, 1][g] * a[g % 2 ? \"x\" : \"y\"] + E(a.margin, 12) + b[g] + (d.titleOffset[g] || 0)));\n        });\n      },\n      proximatePositions: function proximatePositions() {\n        var e = this.chart,\n            b = [],\n            d = \"left\" === this.options.align;\n        this.allItems.forEach(function (a) {\n          var h = d;\n\n          if (a.yAxis && a.points) {\n            a.xAxis.options.reversed && (h = !h);\n            var g = c.find(h ? a.points : a.points.slice(0).reverse(), function (a) {\n              return A(a.plotY);\n            });\n            h = this.itemMarginTop + a.legendItem.getBBox().height + this.itemMarginBottom;\n            var k = a.yAxis.top - e.plotTop;\n            a.visible ? (g = g ? g.plotY : a.yAxis.height, g += k - .3 * h) : g = k + a.yAxis.height;\n            b.push({\n              target: g,\n              size: h,\n              item: a\n            });\n          }\n        }, this);\n        c.distribute(b, e.plotHeight);\n        b.forEach(function (a) {\n          a.item._legendItemPos[1] = e.plotTop - e.spacing[0] + a.pos;\n        });\n      },\n      render: function render() {\n        var e = this.chart,\n            b = e.renderer,\n            d = this.group,\n            a,\n            h = this.box,\n            g = this.options,\n            f = this.padding;\n        this.itemX = f;\n        this.itemY = this.initialItemY;\n        this.lastItemY = this.offsetWidth = 0;\n        this.widthOption = c.relativeLength(g.width, e.spacingBox.width - f);\n        var r = e.spacingBox.width - 2 * f - g.x;\n        -1 < [\"rm\", \"lm\"].indexOf(this.getAlignment().substring(0, 2)) && (r /= 2);\n        this.maxLegendWidth = this.widthOption || r;\n        d || (this.group = d = b.g(\"legend\").attr({\n          zIndex: 7\n        }).add(), this.contentGroup = b.g().attr({\n          zIndex: 1\n        }).add(d), this.scrollGroup = b.g().add(this.contentGroup));\n        this.renderTitle();\n        r = this.getAllItems();\n        m(r, function (a, b) {\n          return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0);\n        });\n        g.reversed && r.reverse();\n        this.allItems = r;\n        this.display = a = !!r.length;\n        this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;\n        r.forEach(this.renderItem, this);\n        r.forEach(this.layoutItem, this);\n        r = (this.widthOption || this.offsetWidth) + f;\n        var x = this.lastItemY + this.lastLineHeight + this.titleHeight;\n        x = this.handleOverflow(x);\n        x += f;\n        h || (this.box = h = b.rect().addClass(\"highcharts-legend-box\").attr({\n          r: g.borderRadius\n        }).add(d), h.isNew = !0);\n        e.styledMode || h.attr({\n          stroke: g.borderColor,\n          \"stroke-width\": g.borderWidth || 0,\n          fill: g.backgroundColor || \"none\"\n        }).shadow(g.shadow);\n        0 < r && 0 < x && (h[h.isNew ? \"attr\" : \"animate\"](h.crisp.call({}, {\n          x: 0,\n          y: 0,\n          width: r,\n          height: x\n        }, h.strokeWidth())), h.isNew = !1);\n        h[a ? \"show\" : \"hide\"]();\n        e.styledMode && \"none\" === d.getStyle(\"display\") && (r = x = 0);\n        this.legendWidth = r;\n        this.legendHeight = x;\n        a && (b = e.spacingBox, h = b.y, /(lth|ct|rth)/.test(this.getAlignment()) && 0 < e.titleOffset[0] ? h += e.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < e.titleOffset[2] && (h -= e.titleOffset[2]), h !== b.y && (b = k(b, {\n          y: h\n        })), d.align(k(g, {\n          width: r,\n          height: x,\n          verticalAlign: this.proximate ? \"top\" : g.verticalAlign\n        }), !0, b));\n        this.proximate || this.positionItems();\n        v(this, \"afterRender\");\n      },\n      handleOverflow: function handleOverflow(e) {\n        var b = this,\n            d = this.chart,\n            a = d.renderer,\n            c = this.options,\n            g = c.y,\n            k = this.padding;\n        g = d.spacingBox.height + (\"top\" === c.verticalAlign ? -g : g) - k;\n\n        var f = c.maxHeight,\n            x,\n            l = this.clipRect,\n            t = c.navigation,\n            B = E(t.animation, !0),\n            I = t.arrowSize || 12,\n            z = this.nav,\n            u = this.pages,\n            m,\n            q = this.allItems,\n            w = function w(a) {\n          \"number\" === typeof a ? l.attr({\n            height: a\n          }) : l && (b.clipRect = l.destroy(), b.contentGroup.clip());\n          b.contentGroup.div && (b.contentGroup.div.style.clip = a ? \"rect(\" + k + \"px,9999px,\" + (k + a) + \"px,0)\" : \"auto\");\n        },\n            p = function p(e) {\n          b[e] = a.circle(0, 0, 1.3 * I).translate(I / 2, I / 2).add(z);\n          d.styledMode || b[e].attr(\"fill\", \"rgba(0,0,0,0.0001)\");\n          return b[e];\n        };\n\n        \"horizontal\" !== c.layout || \"middle\" === c.verticalAlign || c.floating || (g /= 2);\n        f && (g = Math.min(g, f));\n        u.length = 0;\n        e > g && !1 !== t.enabled ? (this.clipHeight = x = Math.max(g - 20 - this.titleHeight - k, 0), this.currentPage = E(this.currentPage, 1), this.fullHeight = e, q.forEach(function (a, b) {\n          var d = a._legendItemPos[1],\n              e = Math.round(a.legendItem.getBBox().height),\n              c = u.length;\n          if (!c || d - u[c - 1] > x && (m || d) !== u[c - 1]) u.push(m || d), c++;\n          a.pageIx = c - 1;\n          m && (q[b - 1].pageIx = c - 1);\n          b === q.length - 1 && d + e - u[c - 1] > x && d !== m && (u.push(d), a.pageIx = c);\n          d !== m && (m = d);\n        }), l || (l = b.clipRect = a.clipRect(0, k, 9999, 0), b.contentGroup.clip(l)), w(x), z || (this.nav = z = a.g().attr({\n          zIndex: 1\n        }).add(this.group), this.up = a.symbol(\"triangle\", 0, 0, I, I).add(z), p(\"upTracker\").on(\"click\", function () {\n          b.scroll(-1, B);\n        }), this.pager = a.text(\"\", 15, 10).addClass(\"highcharts-legend-navigation\"), d.styledMode || this.pager.css(t.style), this.pager.add(z), this.down = a.symbol(\"triangle-down\", 0, 0, I, I).add(z), p(\"downTracker\").on(\"click\", function () {\n          b.scroll(1, B);\n        })), b.scroll(0), e = g) : z && (w(), this.nav = z.destroy(), this.scrollGroup.attr({\n          translateY: 1\n        }), this.clipHeight = 0);\n        return e;\n      },\n      scroll: function scroll(e, b) {\n        var d = this.pages,\n            a = d.length,\n            c = this.currentPage + e;\n        e = this.clipHeight;\n        var g = this.options.navigation,\n            k = this.pager,\n            f = this.padding;\n        c > a && (c = a);\n        0 < c && (void 0 !== b && p(b, this.chart), this.nav.attr({\n          translateX: f,\n          translateY: e + this.padding + 7 + this.titleHeight,\n          visibility: \"visible\"\n        }), [this.up, this.upTracker].forEach(function (a) {\n          a.attr({\n            \"class\": 1 === c ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n          });\n        }), k.attr({\n          text: c + \"/\" + a\n        }), [this.down, this.downTracker].forEach(function (b) {\n          b.attr({\n            x: 18 + this.pager.getBBox().width,\n            \"class\": c === a ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n          });\n        }, this), this.chart.styledMode || (this.up.attr({\n          fill: 1 === c ? g.inactiveColor : g.activeColor\n        }), this.upTracker.css({\n          cursor: 1 === c ? \"default\" : \"pointer\"\n        }), this.down.attr({\n          fill: c === a ? g.inactiveColor : g.activeColor\n        }), this.downTracker.css({\n          cursor: c === a ? \"default\" : \"pointer\"\n        })), this.scrollOffset = -d[c - 1] + this.initialItemY, this.scrollGroup.animate({\n          translateY: this.scrollOffset\n        }), this.currentPage = c, this.positionCheckboxes());\n      }\n    };\n    c.LegendSymbolMixin = {\n      drawRectangle: function drawRectangle(e, b) {\n        var d = e.symbolHeight,\n            a = e.options.squareSymbol;\n        b.legendSymbol = this.chart.renderer.rect(a ? (e.symbolWidth - d) / 2 : 0, e.baseline - d + 1, a ? d : e.symbolWidth, d, E(e.options.symbolRadius, d / 2)).addClass(\"highcharts-point\").attr({\n          zIndex: 3\n        }).add(b.legendGroup);\n      },\n      drawLineMarker: function drawLineMarker(e) {\n        var b = this.options,\n            d = b.marker,\n            a = e.symbolWidth,\n            c = e.symbolHeight,\n            g = c / 2,\n            f = this.chart.renderer,\n            r = this.legendGroup;\n        e = e.baseline - Math.round(.3 * e.fontMetrics.b);\n        var x = {};\n        this.chart.styledMode || (x = {\n          \"stroke-width\": b.lineWidth || 0\n        }, b.dashStyle && (x.dashstyle = b.dashStyle));\n        this.legendLine = f.path([\"M\", 0, e, \"L\", a, e]).addClass(\"highcharts-graph\").attr(x).add(r);\n        d && !1 !== d.enabled && a && (b = Math.min(E(d.radius, g), g), 0 === this.symbol.indexOf(\"url\") && (d = k(d, {\n          width: c,\n          height: c\n        }), b = 0), this.legendSymbol = d = f.symbol(this.symbol, a / 2 - b, e - b, 2 * b, 2 * b, d).addClass(\"highcharts-point\").add(r), d.isMarker = !0);\n      }\n    };\n    (/Trident\\/7\\.0/.test(w.navigator && w.navigator.userAgent) || f) && g(c.Legend.prototype, \"positionItem\", function (e, b) {\n      var d = this,\n          a = function a() {\n        b._legendItemPos && e.call(d, b);\n      };\n\n      a();\n      d.bubbleLegend || setTimeout(a);\n    });\n  });\n  K(C, \"parts/Chart.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var H = f.attr,\n        D = f.defined,\n        A = f.discardElement,\n        E = f.erase,\n        p = f.extend,\n        y = f.isArray,\n        G = f.isNumber,\n        v = f.isObject,\n        q = f.isString,\n        k = f.objectEach,\n        m = f.pick,\n        w = f.pInt,\n        g = f.setAnimation,\n        e = f.splat,\n        b = f.syncTimeout,\n        d = c.addEvent,\n        a = c.animate,\n        h = c.animObject,\n        n = c.doc,\n        F = c.Axis,\n        r = c.createElement,\n        x = c.defaultOptions,\n        l = c.charts,\n        t = c.css,\n        B = c.find,\n        I = c.fireEvent,\n        z = c.Legend,\n        u = c.marginNames,\n        L = c.merge,\n        M = c.Pointer,\n        T = c.removeEvent,\n        Q = c.seriesTypes,\n        C = c.win,\n        N = c.Chart = function () {\n      this.getArgs.apply(this, arguments);\n    };\n\n    c.chart = function (a, b, d) {\n      return new N(a, b, d);\n    };\n\n    p(N.prototype, {\n      callbacks: [],\n      getArgs: function getArgs() {\n        var a = [].slice.call(arguments);\n        if (q(a[0]) || a[0].nodeName) this.renderTo = a.shift();\n        this.init(a[0], a[1]);\n      },\n      init: function init(a, b) {\n        var e,\n            h = a.series,\n            g = a.plotOptions || {};\n        I(this, \"init\", {\n          args: arguments\n        }, function () {\n          a.series = null;\n          e = L(x, a);\n          k(e.plotOptions, function (a, b) {\n            v(a) && (a.tooltip = g[b] && L(g[b].tooltip) || void 0);\n          });\n          e.tooltip.userOptions = a.chart && a.chart.forExport && a.tooltip.userOptions || a.tooltip;\n          e.series = a.series = h;\n          this.userOptions = a;\n          var t = e.chart,\n              u = t.events;\n          this.margin = [];\n          this.spacing = [];\n          this.bounds = {\n            h: {},\n            v: {}\n          };\n          this.labelCollectors = [];\n          this.callback = b;\n          this.isResizing = 0;\n          this.options = e;\n          this.axes = [];\n          this.series = [];\n          this.time = a.time && Object.keys(a.time).length ? new c.Time(a.time) : c.time;\n          this.styledMode = t.styledMode;\n          this.hasCartesianSeries = t.showAxes;\n          var f = this;\n          f.index = l.length;\n          l.push(f);\n          c.chartCount++;\n          u && k(u, function (a, b) {\n            c.isFunction(a) && d(f, b, a);\n          });\n          f.xAxis = [];\n          f.yAxis = [];\n          f.pointCount = f.colorCounter = f.symbolCounter = 0;\n          I(f, \"afterInit\");\n          f.firstRender();\n        });\n      },\n      initSeries: function initSeries(a) {\n        var b = this.options.chart;\n        b = a.type || b.type || b.defaultSeriesType;\n        var d = Q[b];\n        d || c.error(17, !0, this, {\n          missingModuleFor: b\n        });\n        b = new d();\n        b.init(this, a);\n        return b;\n      },\n      orderSeries: function orderSeries(a) {\n        var b = this.series;\n\n        for (a = a || 0; a < b.length; a++) {\n          b[a] && (b[a].index = a, b[a].name = b[a].getName());\n        }\n      },\n      isInsidePlot: function isInsidePlot(a, b, d) {\n        var e = d ? b : a;\n        a = d ? a : b;\n        return 0 <= e && e <= this.plotWidth && 0 <= a && a <= this.plotHeight;\n      },\n      redraw: function redraw(a) {\n        I(this, \"beforeRedraw\");\n        var b = this.axes,\n            d = this.series,\n            e = this.pointer,\n            c = this.legend,\n            l = this.userOptions.legend,\n            h = this.isDirtyLegend,\n            t = this.hasCartesianSeries,\n            k = this.isDirtyBox,\n            f = this.renderer,\n            u = f.isHidden(),\n            r = [];\n        this.setResponsive && this.setResponsive(!1);\n        g(a, this);\n        u && this.temporaryDisplay();\n        this.layOutTitles();\n\n        for (a = d.length; a--;) {\n          var B = d[a];\n\n          if (B.options.stacking) {\n            var n = !0;\n\n            if (B.isDirty) {\n              var z = !0;\n              break;\n            }\n          }\n        }\n\n        if (z) for (a = d.length; a--;) {\n          B = d[a], B.options.stacking && (B.isDirty = !0);\n        }\n        d.forEach(function (a) {\n          a.isDirty && (\"point\" === a.options.legendType ? (a.updateTotals && a.updateTotals(), h = !0) : l && (l.labelFormatter || l.labelFormat) && (h = !0));\n          a.isDirtyData && I(a, \"updatedData\");\n        });\n        h && c && c.options.enabled && (c.render(), this.isDirtyLegend = !1);\n        n && this.getStacks();\n        t && b.forEach(function (a) {\n          a.updateNames();\n          a.setScale();\n        });\n        this.getMargins();\n        t && (b.forEach(function (a) {\n          a.isDirty && (k = !0);\n        }), b.forEach(function (a) {\n          var b = a.min + \",\" + a.max;\n          a.extKey !== b && (a.extKey = b, r.push(function () {\n            I(a, \"afterSetExtremes\", p(a.eventArgs, a.getExtremes()));\n            delete a.eventArgs;\n          }));\n          (k || n) && a.redraw();\n        }));\n        k && this.drawChartBox();\n        I(this, \"predraw\");\n        d.forEach(function (a) {\n          (k || a.isDirty) && a.visible && a.redraw();\n          a.isDirtyData = !1;\n        });\n        e && e.reset(!0);\n        f.draw();\n        I(this, \"redraw\");\n        I(this, \"render\");\n        u && this.temporaryDisplay(!0);\n        r.forEach(function (a) {\n          a.call();\n        });\n      },\n      get: function get(a) {\n        function b(b) {\n          return b.id === a || b.options && b.options.id === a;\n        }\n\n        var d = this.series,\n            e;\n        var c = B(this.axes, b) || B(this.series, b);\n\n        for (e = 0; !c && e < d.length; e++) {\n          c = B(d[e].points || [], b);\n        }\n\n        return c;\n      },\n      getAxes: function getAxes() {\n        var a = this,\n            b = this.options,\n            d = b.xAxis = e(b.xAxis || {});\n        b = b.yAxis = e(b.yAxis || {});\n        I(this, \"getAxes\");\n        d.forEach(function (a, b) {\n          a.index = b;\n          a.isX = !0;\n        });\n        b.forEach(function (a, b) {\n          a.index = b;\n        });\n        d.concat(b).forEach(function (b) {\n          new F(a, b);\n        });\n        I(this, \"afterGetAxes\");\n      },\n      getSelectedPoints: function getSelectedPoints() {\n        var a = [];\n        this.series.forEach(function (b) {\n          a = a.concat((b[b.hasGroupedData ? \"points\" : \"data\"] || []).filter(function (a) {\n            return m(a.selectedStaging, a.selected);\n          }));\n        });\n        return a;\n      },\n      getSelectedSeries: function getSelectedSeries() {\n        return this.series.filter(function (a) {\n          return a.selected;\n        });\n      },\n      setTitle: function setTitle(a, b, d) {\n        this.applyDescription(\"title\", a);\n        this.applyDescription(\"subtitle\", b);\n        this.applyDescription(\"caption\", void 0);\n        this.layOutTitles(d);\n      },\n      applyDescription: function applyDescription(a, b) {\n        var d = this,\n            e = \"title\" === a ? {\n          color: \"#333333\",\n          fontSize: this.options.isStock ? \"16px\" : \"18px\"\n        } : {\n          color: \"#666666\"\n        };\n        e = this.options[a] = L(!this.styledMode && {\n          style: e\n        }, this.options[a], b);\n        var c = this[a];\n        c && b && (this[a] = c = c.destroy());\n        e && !c && (c = this.renderer.text(e.text, 0, 0, e.useHTML).attr({\n          align: e.align,\n          \"class\": \"highcharts-\" + a,\n          zIndex: e.zIndex || 4\n        }).add(), c.update = function (b) {\n          d[{\n            title: \"setTitle\",\n            subtitle: \"setSubtitle\",\n            caption: \"setCaption\"\n          }[a]](b);\n        }, this.styledMode || c.css(e.style), this[a] = c);\n      },\n      layOutTitles: function layOutTitles(a) {\n        var b = [0, 0, 0],\n            d = this.renderer,\n            e = this.spacingBox;\n        [\"title\", \"subtitle\", \"caption\"].forEach(function (a) {\n          var c = this[a],\n              l = this.options[a],\n              h = l.verticalAlign || \"top\";\n          a = \"title\" === a ? -3 : \"top\" === h ? b[0] + 2 : 0;\n\n          if (c) {\n            if (!this.styledMode) var g = l.style.fontSize;\n            g = d.fontMetrics(g, c).b;\n            c.css({\n              width: (l.width || e.width + (l.widthAdjust || 0)) + \"px\"\n            });\n            var t = Math.round(c.getBBox(l.useHTML).height);\n            c.align(p({\n              y: \"bottom\" === h ? g : a + g,\n              height: t\n            }, l), !1, \"spacingBox\");\n            l.floating || (\"top\" === h ? b[0] = Math.ceil(b[0] + t) : \"bottom\" === h && (b[2] = Math.ceil(b[2] + t)));\n          }\n        }, this);\n        b[0] && \"top\" === (this.options.title.verticalAlign || \"top\") && (b[0] += this.options.title.margin);\n        b[2] && \"bottom\" === this.options.caption.verticalAlign && (b[2] += this.options.caption.margin);\n        var c = !this.titleOffset || this.titleOffset.join(\",\") !== b.join(\",\");\n        this.titleOffset = b;\n        I(this, \"afterLayOutTitles\");\n        !this.isDirtyBox && c && (this.isDirtyBox = this.isDirtyLegend = c, this.hasRendered && m(a, !0) && this.isDirtyBox && this.redraw());\n      },\n      getChartSize: function getChartSize() {\n        var a = this.options.chart,\n            b = a.width;\n        a = a.height;\n        var d = this.renderTo;\n        D(b) || (this.containerWidth = c.getStyle(d, \"width\"));\n        D(a) || (this.containerHeight = c.getStyle(d, \"height\"));\n        this.chartWidth = Math.max(0, b || this.containerWidth || 600);\n        this.chartHeight = Math.max(0, c.relativeLength(a, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));\n      },\n      temporaryDisplay: function temporaryDisplay(a) {\n        var b = this.renderTo;\n        if (a) for (; b && b.style;) {\n          b.hcOrigStyle && (c.css(b, b.hcOrigStyle), delete b.hcOrigStyle), b.hcOrigDetached && (n.body.removeChild(b), b.hcOrigDetached = !1), b = b.parentNode;\n        } else for (; b && b.style;) {\n          n.body.contains(b) || b.parentNode || (b.hcOrigDetached = !0, n.body.appendChild(b));\n          if (\"none\" === c.getStyle(b, \"display\", !1) || b.hcOricDetached) b.hcOrigStyle = {\n            display: b.style.display,\n            height: b.style.height,\n            overflow: b.style.overflow\n          }, a = {\n            display: \"block\",\n            overflow: \"hidden\"\n          }, b !== this.renderTo && (a.height = 0), c.css(b, a), b.offsetWidth || b.style.setProperty(\"display\", \"block\", \"important\");\n          b = b.parentNode;\n          if (b === n.body) break;\n        }\n      },\n      setClassName: function setClassName(a) {\n        this.container.className = \"highcharts-container \" + (a || \"\");\n      },\n      getContainer: function getContainer() {\n        var a = this.options,\n            b = a.chart;\n        var d = this.renderTo;\n        var e = c.uniqueKey(),\n            h,\n            g;\n        d || (this.renderTo = d = b.renderTo);\n        q(d) && (this.renderTo = d = n.getElementById(d));\n        d || c.error(13, !0, this);\n        var k = w(H(d, \"data-highcharts-chart\"));\n        G(k) && l[k] && l[k].hasRendered && l[k].destroy();\n        H(d, \"data-highcharts-chart\", this.index);\n        d.innerHTML = \"\";\n        b.skipClone || d.offsetWidth || this.temporaryDisplay();\n        this.getChartSize();\n        k = this.chartWidth;\n        var f = this.chartHeight;\n        t(d, {\n          overflow: \"hidden\"\n        });\n        this.styledMode || (h = p({\n          position: \"relative\",\n          overflow: \"hidden\",\n          width: k + \"px\",\n          height: f + \"px\",\n          textAlign: \"left\",\n          lineHeight: \"normal\",\n          zIndex: 0,\n          \"-webkit-tap-highlight-color\": \"rgba(0,0,0,0)\"\n        }, b.style));\n        this.container = d = r(\"div\", {\n          id: e\n        }, h, d);\n        this._cursor = d.style.cursor;\n        this.renderer = new (c[b.renderer] || c.Renderer)(d, k, f, null, b.forExport, a.exporting && a.exporting.allowHTML, this.styledMode);\n        this.setClassName(b.className);\n        if (this.styledMode) for (g in a.defs) {\n          this.renderer.definition(a.defs[g]);\n        } else this.renderer.setStyle(b.style);\n        this.renderer.chartIndex = this.index;\n        I(this, \"afterGetContainer\");\n      },\n      getMargins: function getMargins(a) {\n        var b = this.spacing,\n            d = this.margin,\n            e = this.titleOffset;\n        this.resetMargins();\n        e[0] && !D(d[0]) && (this.plotTop = Math.max(this.plotTop, e[0] + b[0]));\n        e[2] && !D(d[2]) && (this.marginBottom = Math.max(this.marginBottom, e[2] + b[2]));\n        this.legend && this.legend.display && this.legend.adjustMargins(d, b);\n        I(this, \"getMargins\");\n        a || this.getAxisMargins();\n      },\n      getAxisMargins: function getAxisMargins() {\n        var a = this,\n            b = a.axisOffset = [0, 0, 0, 0],\n            d = a.colorAxis,\n            e = a.margin,\n            c = function c(a) {\n          a.forEach(function (a) {\n            a.visible && a.getOffset();\n          });\n        };\n\n        a.hasCartesianSeries ? c(a.axes) : d && d.length && c(d);\n        u.forEach(function (d, c) {\n          D(e[c]) || (a[d] += b[c]);\n        });\n        a.setChartSize();\n      },\n      reflow: function reflow(a) {\n        var d = this,\n            e = d.options.chart,\n            l = d.renderTo,\n            h = D(e.width) && D(e.height),\n            g = e.width || c.getStyle(l, \"width\");\n        e = e.height || c.getStyle(l, \"height\");\n        l = a ? a.target : C;\n\n        if (!h && !d.isPrinting && g && e && (l === C || l === n)) {\n          if (g !== d.containerWidth || e !== d.containerHeight) c.clearTimeout(d.reflowTimeout), d.reflowTimeout = b(function () {\n            d.container && d.setSize(void 0, void 0, !1);\n          }, a ? 100 : 0);\n          d.containerWidth = g;\n          d.containerHeight = e;\n        }\n      },\n      setReflow: function setReflow(a) {\n        var b = this;\n        !1 === a || this.unbindReflow ? !1 === a && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = d(C, \"resize\", function (a) {\n          b.options && b.reflow(a);\n        }), d(this, \"destroy\", this.unbindReflow));\n      },\n      setSize: function setSize(d, e, c) {\n        var l = this,\n            k = l.renderer;\n        l.isResizing += 1;\n        g(c, l);\n        l.oldChartHeight = l.chartHeight;\n        l.oldChartWidth = l.chartWidth;\n        void 0 !== d && (l.options.chart.width = d);\n        void 0 !== e && (l.options.chart.height = e);\n        l.getChartSize();\n\n        if (!l.styledMode) {\n          var f = k.globalAnimation;\n          (f ? a : t)(l.container, {\n            width: l.chartWidth + \"px\",\n            height: l.chartHeight + \"px\"\n          }, f);\n        }\n\n        l.setChartSize(!0);\n        k.setSize(l.chartWidth, l.chartHeight, c);\n        l.axes.forEach(function (a) {\n          a.isDirty = !0;\n          a.setScale();\n        });\n        l.isDirtyLegend = !0;\n        l.isDirtyBox = !0;\n        l.layOutTitles();\n        l.getMargins();\n        l.redraw(c);\n        l.oldChartHeight = null;\n        I(l, \"resize\");\n        b(function () {\n          l && I(l, \"endResize\", null, function () {\n            --l.isResizing;\n          });\n        }, h(f).duration || 0);\n      },\n      setChartSize: function setChartSize(a) {\n        var b = this.inverted,\n            d = this.renderer,\n            e = this.chartWidth,\n            c = this.chartHeight,\n            l = this.options.chart,\n            h = this.spacing,\n            g = this.clipOffset,\n            t,\n            k,\n            f,\n            u;\n        this.plotLeft = t = Math.round(this.plotLeft);\n        this.plotTop = k = Math.round(this.plotTop);\n        this.plotWidth = f = Math.max(0, Math.round(e - t - this.marginRight));\n        this.plotHeight = u = Math.max(0, Math.round(c - k - this.marginBottom));\n        this.plotSizeX = b ? u : f;\n        this.plotSizeY = b ? f : u;\n        this.plotBorderWidth = l.plotBorderWidth || 0;\n        this.spacingBox = d.spacingBox = {\n          x: h[3],\n          y: h[0],\n          width: e - h[3] - h[1],\n          height: c - h[0] - h[2]\n        };\n        this.plotBox = d.plotBox = {\n          x: t,\n          y: k,\n          width: f,\n          height: u\n        };\n        e = 2 * Math.floor(this.plotBorderWidth / 2);\n        b = Math.ceil(Math.max(e, g[3]) / 2);\n        d = Math.ceil(Math.max(e, g[0]) / 2);\n        this.clipBox = {\n          x: b,\n          y: d,\n          width: Math.floor(this.plotSizeX - Math.max(e, g[1]) / 2 - b),\n          height: Math.max(0, Math.floor(this.plotSizeY - Math.max(e, g[2]) / 2 - d))\n        };\n        a || this.axes.forEach(function (a) {\n          a.setAxisSize();\n          a.setAxisTranslation();\n        });\n        I(this, \"afterSetChartSize\", {\n          skipAxes: a\n        });\n      },\n      resetMargins: function resetMargins() {\n        I(this, \"resetMargins\");\n        var a = this,\n            b = a.options.chart;\n        [\"margin\", \"spacing\"].forEach(function (d) {\n          var e = b[d],\n              c = v(e) ? e : [e, e, e, e];\n          [\"Top\", \"Right\", \"Bottom\", \"Left\"].forEach(function (e, l) {\n            a[d][l] = m(b[d + e], c[l]);\n          });\n        });\n        u.forEach(function (b, d) {\n          a[b] = m(a.margin[d], a.spacing[d]);\n        });\n        a.axisOffset = [0, 0, 0, 0];\n        a.clipOffset = [0, 0, 0, 0];\n      },\n      drawChartBox: function drawChartBox() {\n        var a = this.options.chart,\n            b = this.renderer,\n            d = this.chartWidth,\n            e = this.chartHeight,\n            c = this.chartBackground,\n            l = this.plotBackground,\n            h = this.plotBorder,\n            g = this.styledMode,\n            t = this.plotBGImage,\n            k = a.backgroundColor,\n            f = a.plotBackgroundColor,\n            u = a.plotBackgroundImage,\n            r,\n            B = this.plotLeft,\n            n = this.plotTop,\n            z = this.plotWidth,\n            x = this.plotHeight,\n            m = this.plotBox,\n            q = this.clipRect,\n            L = this.clipBox,\n            w = \"animate\";\n        c || (this.chartBackground = c = b.rect().addClass(\"highcharts-background\").add(), w = \"attr\");\n        if (g) var F = r = c.strokeWidth();else {\n          F = a.borderWidth || 0;\n          r = F + (a.shadow ? 8 : 0);\n          k = {\n            fill: k || \"none\"\n          };\n          if (F || c[\"stroke-width\"]) k.stroke = a.borderColor, k[\"stroke-width\"] = F;\n          c.attr(k).shadow(a.shadow);\n        }\n        c[w]({\n          x: r / 2,\n          y: r / 2,\n          width: d - r - F % 2,\n          height: e - r - F % 2,\n          r: a.borderRadius\n        });\n        w = \"animate\";\n        l || (w = \"attr\", this.plotBackground = l = b.rect().addClass(\"highcharts-plot-background\").add());\n        l[w](m);\n        g || (l.attr({\n          fill: f || \"none\"\n        }).shadow(a.plotShadow), u && (t ? t.animate(m) : this.plotBGImage = b.image(u, B, n, z, x).add()));\n        q ? q.animate({\n          width: L.width,\n          height: L.height\n        }) : this.clipRect = b.clipRect(L);\n        w = \"animate\";\n        h || (w = \"attr\", this.plotBorder = h = b.rect().addClass(\"highcharts-plot-border\").attr({\n          zIndex: 1\n        }).add());\n        g || h.attr({\n          stroke: a.plotBorderColor,\n          \"stroke-width\": a.plotBorderWidth || 0,\n          fill: \"none\"\n        });\n        h[w](h.crisp({\n          x: B,\n          y: n,\n          width: z,\n          height: x\n        }, -h.strokeWidth()));\n        this.isDirtyBox = !1;\n        I(this, \"afterDrawChartBox\");\n      },\n      propFromSeries: function propFromSeries() {\n        var a = this,\n            b = a.options.chart,\n            d,\n            e = a.options.series,\n            c,\n            l;\n        [\"inverted\", \"angular\", \"polar\"].forEach(function (h) {\n          d = Q[b.type || b.defaultSeriesType];\n          l = b[h] || d && d.prototype[h];\n\n          for (c = e && e.length; !l && c--;) {\n            (d = Q[e[c].type]) && d.prototype[h] && (l = !0);\n          }\n\n          a[h] = l;\n        });\n      },\n      linkSeries: function linkSeries() {\n        var a = this,\n            b = a.series;\n        b.forEach(function (a) {\n          a.linkedSeries.length = 0;\n        });\n        b.forEach(function (b) {\n          var d = b.options.linkedTo;\n          q(d) && (d = \":previous\" === d ? a.series[b.index - 1] : a.get(d)) && d.linkedParent !== b && (d.linkedSeries.push(b), b.linkedParent = d, b.visible = m(b.options.visible, d.options.visible, b.visible));\n        });\n        I(this, \"afterLinkSeries\");\n      },\n      renderSeries: function renderSeries() {\n        this.series.forEach(function (a) {\n          a.translate();\n          a.render();\n        });\n      },\n      renderLabels: function renderLabels() {\n        var a = this,\n            b = a.options.labels;\n        b.items && b.items.forEach(function (d) {\n          var e = p(b.style, d.style),\n              c = w(e.left) + a.plotLeft,\n              l = w(e.top) + a.plotTop + 12;\n          delete e.left;\n          delete e.top;\n          a.renderer.text(d.html, c, l).attr({\n            zIndex: 2\n          }).css(e).add();\n        });\n      },\n      render: function render() {\n        var a = this.axes,\n            b = this.colorAxis,\n            d = this.renderer,\n            e = this.options,\n            c = 0,\n            l = function l(a) {\n          a.forEach(function (a) {\n            a.visible && a.render();\n          });\n        };\n\n        this.setTitle();\n        this.legend = new z(this, e.legend);\n        this.getStacks && this.getStacks();\n        this.getMargins(!0);\n        this.setChartSize();\n        e = this.plotWidth;\n        a.some(function (a) {\n          if (a.horiz && a.visible && a.options.labels.enabled && a.series.length) return c = 21, !0;\n        });\n        var h = this.plotHeight = Math.max(this.plotHeight - c, 0);\n        a.forEach(function (a) {\n          a.setScale();\n        });\n        this.getAxisMargins();\n        var g = 1.1 < e / this.plotWidth;\n        var t = 1.05 < h / this.plotHeight;\n        if (g || t) a.forEach(function (a) {\n          (a.horiz && g || !a.horiz && t) && a.setTickInterval(!0);\n        }), this.getMargins();\n        this.drawChartBox();\n        this.hasCartesianSeries ? l(a) : b && b.length && l(b);\n        this.seriesGroup || (this.seriesGroup = d.g(\"series-group\").attr({\n          zIndex: 3\n        }).add());\n        this.renderSeries();\n        this.renderLabels();\n        this.addCredits();\n        this.setResponsive && this.setResponsive();\n        this.updateContainerScaling();\n        this.hasRendered = !0;\n      },\n      addCredits: function addCredits(a) {\n        var b = this;\n        a = L(!0, this.options.credits, a);\n        a.enabled && !this.credits && (this.credits = this.renderer.text(a.text + (this.mapCredits || \"\"), 0, 0).addClass(\"highcharts-credits\").on(\"click\", function () {\n          a.href && (C.location.href = a.href);\n        }).attr({\n          align: a.position.align,\n          zIndex: 8\n        }), b.styledMode || this.credits.css(a.style), this.credits.add().align(a.position), this.credits.update = function (a) {\n          b.credits = b.credits.destroy();\n          b.addCredits(a);\n        });\n      },\n      updateContainerScaling: function updateContainerScaling() {\n        var a = this.container;\n\n        if (a.offsetWidth && a.offsetHeight && a.getBoundingClientRect) {\n          var b = a.getBoundingClientRect(),\n              d = b.width / a.offsetWidth;\n          a = b.height / a.offsetHeight;\n          1 !== d || 1 !== a ? this.containerScaling = {\n            scaleX: d,\n            scaleY: a\n          } : delete this.containerScaling;\n        }\n      },\n      destroy: function destroy() {\n        var a = this,\n            b = a.axes,\n            d = a.series,\n            e = a.container,\n            h,\n            g = e && e.parentNode;\n        I(a, \"destroy\");\n        a.renderer.forExport ? E(l, a) : l[a.index] = void 0;\n        c.chartCount--;\n        a.renderTo.removeAttribute(\"data-highcharts-chart\");\n        T(a);\n\n        for (h = b.length; h--;) {\n          b[h] = b[h].destroy();\n        }\n\n        this.scroller && this.scroller.destroy && this.scroller.destroy();\n\n        for (h = d.length; h--;) {\n          d[h] = d[h].destroy();\n        }\n\n        \"title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer\".split(\" \").forEach(function (b) {\n          var d = a[b];\n          d && d.destroy && (a[b] = d.destroy());\n        });\n        e && (e.innerHTML = \"\", T(e), g && A(e));\n        k(a, function (b, d) {\n          delete a[d];\n        });\n      },\n      firstRender: function firstRender() {\n        var a = this,\n            b = a.options;\n\n        if (!a.isReadyToRender || a.isReadyToRender()) {\n          a.getContainer();\n          a.resetMargins();\n          a.setChartSize();\n          a.propFromSeries();\n          a.getAxes();\n          (y(b.series) ? b.series : []).forEach(function (b) {\n            a.initSeries(b);\n          });\n          a.linkSeries();\n          I(a, \"beforeRender\");\n          M && (a.pointer = new M(a, b));\n          a.render();\n          if (!a.renderer.imgCount && a.onload) a.onload();\n          a.temporaryDisplay(!0);\n        }\n      },\n      onload: function onload() {\n        this.callbacks.concat([this.callback]).forEach(function (a) {\n          a && void 0 !== this.index && a.apply(this, [this]);\n        }, this);\n        I(this, \"load\");\n        I(this, \"render\");\n        D(this.index) && this.setReflow(this.options.chart.reflow);\n        this.onload = null;\n      }\n    });\n  });\n  K(C, \"parts/ScrollablePlotArea.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var H = f.pick,\n        D = c.addEvent;\n    f = c.Chart;\n    \"\";\n    D(f, \"afterSetChartSize\", function (f) {\n      var A = this.options.chart.scrollablePlotArea,\n          p = A && A.minWidth;\n      A = A && A.minHeight;\n\n      if (!this.renderer.forExport) {\n        if (p) {\n          if (this.scrollablePixelsX = p = Math.max(0, p - this.chartWidth)) {\n            this.plotWidth += p;\n            this.inverted ? (this.clipBox.height += p, this.plotBox.height += p) : (this.clipBox.width += p, this.plotBox.width += p);\n            var y = {\n              1: {\n                name: \"right\",\n                value: p\n              }\n            };\n          }\n        } else A && (this.scrollablePixelsY = p = Math.max(0, A - this.chartHeight)) && (this.plotHeight += p, this.inverted ? (this.clipBox.width += p, this.plotBox.width += p) : (this.clipBox.height += p, this.plotBox.height += p), y = {\n          2: {\n            name: \"bottom\",\n            value: p\n          }\n        });\n\n        y && !f.skipAxes && this.axes.forEach(function (f) {\n          y[f.side] ? f.getPlotLinePath = function () {\n            var p = y[f.side].name,\n                q = this[p];\n            this[p] = q - y[f.side].value;\n            var k = c.Axis.prototype.getPlotLinePath.apply(this, arguments);\n            this[p] = q;\n            return k;\n          } : (f.setAxisSize(), f.setAxisTranslation());\n        });\n      }\n    });\n    D(f, \"render\", function () {\n      this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();\n    });\n\n    f.prototype.setUpScrolling = function () {\n      var f = {\n        WebkitOverflowScrolling: \"touch\",\n        overflowX: \"hidden\",\n        overflowY: \"hidden\"\n      };\n      this.scrollablePixelsX && (f.overflowX = \"auto\");\n      this.scrollablePixelsY && (f.overflowY = \"auto\");\n      this.scrollingContainer = c.createElement(\"div\", {\n        className: \"highcharts-scrolling\"\n      }, f, this.renderTo);\n      this.innerContainer = c.createElement(\"div\", {\n        className: \"highcharts-inner-container\"\n      }, null, this.scrollingContainer);\n      this.innerContainer.appendChild(this.container);\n      this.setUpScrolling = null;\n    };\n\n    f.prototype.moveFixedElements = function () {\n      var c = this.container,\n          f = this.fixedRenderer,\n          p = \".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-scrollbar .highcharts-subtitle .highcharts-title\".split(\" \"),\n          y;\n      this.scrollablePixelsX && !this.inverted ? y = \".highcharts-yaxis\" : this.scrollablePixelsX && this.inverted ? y = \".highcharts-xaxis\" : this.scrollablePixelsY && !this.inverted ? y = \".highcharts-xaxis\" : this.scrollablePixelsY && this.inverted && (y = \".highcharts-yaxis\");\n      p.push(y, y + \"-labels\");\n      p.forEach(function (p) {\n        [].forEach.call(c.querySelectorAll(p), function (c) {\n          (c.namespaceURI === f.SVG_NS ? f.box : f.box.parentNode).appendChild(c);\n          c.style.pointerEvents = \"auto\";\n        });\n      });\n    };\n\n    f.prototype.applyFixed = function () {\n      var f,\n          E = !this.fixedDiv,\n          p = this.options.chart.scrollablePlotArea;\n      E ? (this.fixedDiv = c.createElement(\"div\", {\n        className: \"highcharts-fixed\"\n      }, {\n        position: \"absolute\",\n        overflow: \"hidden\",\n        pointerEvents: \"none\",\n        zIndex: 2\n      }, null, !0), this.renderTo.insertBefore(this.fixedDiv, this.renderTo.firstChild), this.renderTo.style.overflow = \"visible\", this.fixedRenderer = f = new c.Renderer(this.fixedDiv, this.chartWidth, this.chartHeight), this.scrollableMask = f.path().attr({\n        fill: c.color(this.options.chart.backgroundColor || \"#fff\").setOpacity(H(p.opacity, .85)).get(),\n        zIndex: -1\n      }).addClass(\"highcharts-scrollable-mask\").add(), this.moveFixedElements(), D(this, \"afterShowResetZoom\", this.moveFixedElements), D(this, \"afterLayOutTitles\", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);\n      f = this.chartWidth + (this.scrollablePixelsX || 0);\n      var y = this.chartHeight + (this.scrollablePixelsY || 0);\n      c.stop(this.container);\n      this.container.style.width = f + \"px\";\n      this.container.style.height = y + \"px\";\n      this.renderer.boxWrapper.attr({\n        width: f,\n        height: y,\n        viewBox: [0, 0, f, y].join(\" \")\n      });\n      this.chartBackground.attr({\n        width: f,\n        height: y\n      });\n      this.scrollablePixelsY && (this.scrollingContainer.style.height = this.chartHeight + \"px\");\n      E && (p.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * p.scrollPositionX), p.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * p.scrollPositionY));\n      y = this.axisOffset;\n      E = this.plotTop - y[0] - 1;\n      p = this.plotLeft - y[3] - 1;\n      f = this.plotTop + this.plotHeight + y[2] + 1;\n      y = this.plotLeft + this.plotWidth + y[1] + 1;\n      var G = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),\n          v = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);\n      E = this.scrollablePixelsX ? [\"M\", 0, E, \"L\", this.plotLeft - 1, E, \"L\", this.plotLeft - 1, f, \"L\", 0, f, \"Z\", \"M\", G, E, \"L\", this.chartWidth, E, \"L\", this.chartWidth, f, \"L\", G, f, \"Z\"] : this.scrollablePixelsY ? [\"M\", p, 0, \"L\", p, this.plotTop - 1, \"L\", y, this.plotTop - 1, \"L\", y, 0, \"Z\", \"M\", p, v, \"L\", p, this.chartHeight, \"L\", y, this.chartHeight, \"L\", y, v, \"Z\"] : [\"M\", 0, 0];\n      \"adjustHeight\" !== this.redrawTrigger && this.scrollableMask.attr({\n        d: E\n      });\n    };\n  });\n  K(C, \"parts/Point.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var H = f.defined,\n        D = f.erase,\n        A = f.extend,\n        E = f.isArray,\n        p = f.isNumber,\n        y = f.isObject,\n        G = f.pick,\n        v,\n        q = c.fireEvent,\n        k = c.format,\n        m = c.uniqueKey,\n        w = c.removeEvent;\n\n    c.Point = v = function v() {};\n\n    c.Point.prototype = {\n      init: function init(c, e, b) {\n        this.series = c;\n        this.applyOptions(e, b);\n        this.id = H(this.id) ? this.id : m();\n        this.resolveColor();\n        c.chart.pointCount++;\n        q(this, \"afterInit\");\n        return this;\n      },\n      resolveColor: function resolveColor() {\n        var c = this.series;\n        var e = c.chart.options.chart.colorCount;\n        var b = c.chart.styledMode;\n        b || this.options.color || (this.color = c.color);\n        c.options.colorByPoint ? (b || (e = c.options.colors || c.chart.options.colors, this.color = this.color || e[c.colorCounter], e = e.length), b = c.colorCounter, c.colorCounter++, c.colorCounter === e && (c.colorCounter = 0)) : b = c.colorIndex;\n        this.colorIndex = G(this.colorIndex, b);\n      },\n      applyOptions: function applyOptions(c, e) {\n        var b = this.series,\n            d = b.options.pointValKey || b.pointValKey;\n        c = v.prototype.optionsToObject.call(this, c);\n        A(this, c);\n        this.options = this.options ? A(this.options, c) : c;\n        c.group && delete this.group;\n        c.dataLabels && delete this.dataLabels;\n        d && (this.y = this[d]);\n        this.formatPrefix = (this.isNull = G(this.isValid && !this.isValid(), null === this.x || !p(this.y))) ? \"null\" : \"point\";\n        this.selected && (this.state = \"select\");\n        \"name\" in this && void 0 === e && b.xAxis && b.xAxis.hasNames && (this.x = b.xAxis.nameToX(this));\n        void 0 === this.x && b && (this.x = void 0 === e ? b.autoIncrement(this) : e);\n        return this;\n      },\n      setNestedProperty: function setNestedProperty(c, e, b) {\n        b.split(\".\").reduce(function (b, a, c, g) {\n          b[a] = g.length - 1 === c ? e : y(b[a], !0) ? b[a] : {};\n          return b[a];\n        }, c);\n        return c;\n      },\n      optionsToObject: function optionsToObject(g) {\n        var e = {},\n            b = this.series,\n            d = b.options.keys,\n            a = d || b.pointArrayMap || [\"y\"],\n            h = a.length,\n            k = 0,\n            f = 0;\n        if (p(g) || null === g) e[a[0]] = g;else if (E(g)) for (!d && g.length > h && (b = typeof g[0], \"string\" === b ? e.name = g[0] : \"number\" === b && (e.x = g[0]), k++); f < h;) {\n          d && void 0 === g[k] || (0 < a[f].indexOf(\".\") ? c.Point.prototype.setNestedProperty(e, g[k], a[f]) : e[a[f]] = g[k]), k++, f++;\n        } else \"object\" === typeof g && (e = g, g.dataLabels && (b._hasPointLabels = !0), g.marker && (b._hasPointMarkers = !0));\n        return e;\n      },\n      getClassName: function getClassName() {\n        return \"highcharts-point\" + (this.selected ? \" highcharts-point-select\" : \"\") + (this.negative ? \" highcharts-negative\" : \"\") + (this.isNull ? \" highcharts-null-point\" : \"\") + (void 0 !== this.colorIndex ? \" highcharts-color-\" + this.colorIndex : \"\") + (this.options.className ? \" \" + this.options.className : \"\") + (this.zone && this.zone.className ? \" \" + this.zone.className.replace(\"highcharts-negative\", \"\") : \"\");\n      },\n      getZone: function getZone() {\n        var c = this.series,\n            e = c.zones;\n        c = c.zoneAxis || \"y\";\n        var b = 0,\n            d;\n\n        for (d = e[b]; this[c] >= d.value;) {\n          d = e[++b];\n        }\n\n        this.nonZonedColor || (this.nonZonedColor = this.color);\n        this.color = d && d.color && !this.options.color ? d.color : this.nonZonedColor;\n        return d;\n      },\n      hasNewShapeType: function hasNewShapeType() {\n        return this.graphic && this.graphic.element.nodeName !== this.shapeType;\n      },\n      destroy: function destroy() {\n        var c = this.series.chart,\n            e = c.hoverPoints,\n            b;\n        c.pointCount--;\n        e && (this.setState(), D(e, this), e.length || (c.hoverPoints = null));\n        if (this === c.hoverPoint) this.onMouseOut();\n        if (this.graphic || this.dataLabel || this.dataLabels) w(this), this.destroyElements();\n        this.legendItem && c.legend.destroyItem(this);\n\n        for (b in this) {\n          this[b] = null;\n        }\n      },\n      destroyElements: function destroyElements(c) {\n        var e = this,\n            b = [],\n            d;\n        c = c || {\n          graphic: 1,\n          dataLabel: 1\n        };\n        c.graphic && b.push(\"graphic\", \"shadowGroup\");\n        c.dataLabel && b.push(\"dataLabel\", \"dataLabelUpper\", \"connector\");\n\n        for (d = b.length; d--;) {\n          var a = b[d];\n          e[a] && (e[a] = e[a].destroy());\n        }\n\n        [\"dataLabel\", \"connector\"].forEach(function (a) {\n          var b = a + \"s\";\n          c[a] && e[b] && (e[b].forEach(function (a) {\n            a.element && a.destroy();\n          }), delete e[b]);\n        });\n      },\n      getLabelConfig: function getLabelConfig() {\n        return {\n          x: this.category,\n          y: this.y,\n          color: this.color,\n          colorIndex: this.colorIndex,\n          key: this.name || this.category,\n          series: this.series,\n          point: this,\n          percentage: this.percentage,\n          total: this.total || this.stackTotal\n        };\n      },\n      tooltipFormatter: function tooltipFormatter(c) {\n        var e = this.series,\n            b = e.tooltipOptions,\n            d = G(b.valueDecimals, \"\"),\n            a = b.valuePrefix || \"\",\n            h = b.valueSuffix || \"\";\n        e.chart.styledMode && (c = e.chart.tooltip.styledModeFormat(c));\n        (e.pointArrayMap || [\"y\"]).forEach(function (b) {\n          b = \"{point.\" + b;\n          if (a || h) c = c.replace(RegExp(b + \"}\", \"g\"), a + b + \"}\" + h);\n          c = c.replace(RegExp(b + \"}\", \"g\"), b + \":,.\" + d + \"f}\");\n        });\n        return k(c, {\n          point: this,\n          series: this.series\n        }, e.chart.time);\n      },\n      firePointEvent: function firePointEvent(c, e, b) {\n        var d = this,\n            a = this.series.options;\n        (a.point.events[c] || d.options && d.options.events && d.options.events[c]) && this.importEvents();\n        \"click\" === c && a.allowPointSelect && (b = function b(a) {\n          d.select && d.select(null, a.ctrlKey || a.metaKey || a.shiftKey);\n        });\n        q(this, c, e, b);\n      },\n      visible: !0\n    };\n  });\n  K(C, \"parts/Series.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var H = f.arrayMax,\n        D = f.arrayMin,\n        A = f.defined,\n        E = f.erase,\n        p = f.extend,\n        y = f.isArray,\n        G = f.isNumber,\n        v = f.isString,\n        q = f.objectEach,\n        k = f.pick,\n        m = f.splat,\n        w = f.syncTimeout,\n        g = c.addEvent,\n        e = c.animObject,\n        b = c.correctFloat,\n        d = c.defaultOptions,\n        a = c.defaultPlotOptions,\n        h = c.fireEvent,\n        n = c.merge,\n        F = c.removeEvent,\n        r = c.SVGElement,\n        x = c.win;\n    c.Series = c.seriesType(\"line\", null, {\n      lineWidth: 2,\n      allowPointSelect: !1,\n      showCheckbox: !1,\n      animation: {\n        duration: 1E3\n      },\n      events: {},\n      marker: {\n        lineWidth: 0,\n        lineColor: \"#ffffff\",\n        enabledThreshold: 2,\n        radius: 4,\n        states: {\n          normal: {\n            animation: !0\n          },\n          hover: {\n            animation: {\n              duration: 50\n            },\n            enabled: !0,\n            radiusPlus: 2,\n            lineWidthPlus: 1\n          },\n          select: {\n            fillColor: \"#cccccc\",\n            lineColor: \"#000000\",\n            lineWidth: 2\n          }\n        }\n      },\n      point: {\n        events: {}\n      },\n      dataLabels: {\n        align: \"center\",\n        formatter: function formatter() {\n          return null === this.y ? \"\" : c.numberFormat(this.y, -1);\n        },\n        padding: 5,\n        style: {\n          fontSize: \"11px\",\n          fontWeight: \"bold\",\n          color: \"contrast\",\n          textOutline: \"1px contrast\"\n        },\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0\n      },\n      cropThreshold: 300,\n      opacity: 1,\n      pointRange: 0,\n      softThreshold: !0,\n      states: {\n        normal: {\n          animation: !0\n        },\n        hover: {\n          animation: {\n            duration: 50\n          },\n          lineWidthPlus: 1,\n          marker: {},\n          halo: {\n            size: 10,\n            opacity: .25\n          }\n        },\n        select: {\n          animation: {\n            duration: 0\n          }\n        },\n        inactive: {\n          animation: {\n            duration: 50\n          },\n          opacity: .2\n        }\n      },\n      stickyTracking: !0,\n      turboThreshold: 1E3,\n      findNearestPointBy: \"x\"\n    }, {\n      axisTypes: [\"xAxis\", \"yAxis\"],\n      coll: \"series\",\n      colorCounter: 0,\n      cropShoulder: 1,\n      directTouch: !1,\n      isCartesian: !0,\n      parallelArrays: [\"x\", \"y\"],\n      pointClass: c.Point,\n      requireSorting: !0,\n      sorted: !0,\n      init: function init(a, b) {\n        h(this, \"init\", {\n          options: b\n        });\n        var d = this,\n            e = a.series,\n            l;\n        this.eventOptions = this.eventOptions || {};\n        d.chart = a;\n        d.options = b = d.setOptions(b);\n        d.linkedSeries = [];\n        d.bindAxes();\n        p(d, {\n          name: b.name,\n          state: \"\",\n          visible: !1 !== b.visible,\n          selected: !0 === b.selected\n        });\n        var t = b.events;\n        q(t, function (a, b) {\n          c.isFunction(a) && d.eventOptions[b] !== a && (c.isFunction(d.eventOptions[b]) && F(d, b, d.eventOptions[b]), d.eventOptions[b] = a, g(d, b, a));\n        });\n        if (t && t.click || b.point && b.point.events && b.point.events.click || b.allowPointSelect) a.runTrackerClick = !0;\n        d.getColor();\n        d.getSymbol();\n        d.parallelArrays.forEach(function (a) {\n          d[a + \"Data\"] || (d[a + \"Data\"] = []);\n        });\n        d.points || d.data || d.setData(b.data, !1);\n        d.isCartesian && (a.hasCartesianSeries = !0);\n        e.length && (l = e[e.length - 1]);\n        d._i = k(l && l._i, -1) + 1;\n        a.orderSeries(this.insert(e));\n        h(this, \"afterInit\");\n      },\n      insert: function insert(a) {\n        var b = this.options.index,\n            d;\n\n        if (G(b)) {\n          for (d = a.length; d--;) {\n            if (b >= k(a[d].options.index, a[d]._i)) {\n              a.splice(d + 1, 0, this);\n              break;\n            }\n          }\n\n          -1 === d && a.unshift(this);\n          d += 1;\n        } else a.push(this);\n\n        return k(d, a.length - 1);\n      },\n      bindAxes: function bindAxes() {\n        var a = this,\n            b = a.options,\n            d = a.chart,\n            e;\n        h(this, \"bindAxes\", null, function () {\n          (a.axisTypes || []).forEach(function (l) {\n            d[l].forEach(function (d) {\n              e = d.options;\n              if (b[l] === e.index || void 0 !== b[l] && b[l] === e.id || void 0 === b[l] && 0 === e.index) a.insert(d.series), a[l] = d, d.isDirty = !0;\n            });\n            a[l] || a.optionalAxis === l || c.error(18, !0, d);\n          });\n        });\n      },\n      updateParallelArrays: function updateParallelArrays(a, b) {\n        var d = a.series,\n            e = arguments,\n            c = G(b) ? function (e) {\n          var c = \"y\" === e && d.toYData ? d.toYData(a) : a[e];\n          d[e + \"Data\"][b] = c;\n        } : function (a) {\n          Array.prototype[b].apply(d[a + \"Data\"], Array.prototype.slice.call(e, 2));\n        };\n        d.parallelArrays.forEach(c);\n      },\n      hasData: function hasData() {\n        return this.visible && void 0 !== this.dataMax && void 0 !== this.dataMin || this.visible && this.yData && 0 < this.yData.length;\n      },\n      autoIncrement: function autoIncrement() {\n        var a = this.options,\n            b = this.xIncrement,\n            d,\n            e = a.pointIntervalUnit,\n            c = this.chart.time;\n        b = k(b, a.pointStart, 0);\n        this.pointInterval = d = k(this.pointInterval, a.pointInterval, 1);\n        e && (a = new c.Date(b), \"day\" === e ? c.set(\"Date\", a, c.get(\"Date\", a) + d) : \"month\" === e ? c.set(\"Month\", a, c.get(\"Month\", a) + d) : \"year\" === e && c.set(\"FullYear\", a, c.get(\"FullYear\", a) + d), d = a.getTime() - b);\n        this.xIncrement = b + d;\n        return b;\n      },\n      setOptions: function setOptions(a) {\n        var b = this.chart,\n            e = b.options,\n            c = e.plotOptions,\n            l = b.userOptions || {};\n        a = n(a);\n        b = b.styledMode;\n        var g = {\n          plotOptions: c,\n          userOptions: a\n        };\n        h(this, \"setOptions\", g);\n        var f = g.plotOptions[this.type],\n            r = l.plotOptions || {};\n        this.userOptions = g.userOptions;\n        l = n(f, c.series, l.plotOptions && l.plotOptions[this.type], a);\n        this.tooltipOptions = n(d.tooltip, d.plotOptions.series && d.plotOptions.series.tooltip, d.plotOptions[this.type].tooltip, e.tooltip.userOptions, c.series && c.series.tooltip, c[this.type].tooltip, a.tooltip);\n        this.stickyTracking = k(a.stickyTracking, r[this.type] && r[this.type].stickyTracking, r.series && r.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : l.stickyTracking);\n        null === f.marker && delete l.marker;\n        this.zoneAxis = l.zoneAxis;\n        e = this.zones = (l.zones || []).slice();\n        !l.negativeColor && !l.negativeFillColor || l.zones || (c = {\n          value: l[this.zoneAxis + \"Threshold\"] || l.threshold || 0,\n          className: \"highcharts-negative\"\n        }, b || (c.color = l.negativeColor, c.fillColor = l.negativeFillColor), e.push(c));\n        e.length && A(e[e.length - 1].value) && e.push(b ? {} : {\n          color: this.color,\n          fillColor: this.fillColor\n        });\n        h(this, \"afterSetOptions\", {\n          options: l\n        });\n        return l;\n      },\n      getName: function getName() {\n        return k(this.options.name, \"Series \" + (this.index + 1));\n      },\n      getCyclic: function getCyclic(a, b, d) {\n        var e = this.chart,\n            c = this.userOptions,\n            l = a + \"Index\",\n            h = a + \"Counter\",\n            g = d ? d.length : k(e.options.chart[a + \"Count\"], e[a + \"Count\"]);\n\n        if (!b) {\n          var t = k(c[l], c[\"_\" + l]);\n          A(t) || (e.series.length || (e[h] = 0), c[\"_\" + l] = t = e[h] % g, e[h] += 1);\n          d && (b = d[t]);\n        }\n\n        void 0 !== t && (this[l] = t);\n        this[a] = b;\n      },\n      getColor: function getColor() {\n        this.chart.styledMode ? this.getCyclic(\"color\") : this.options.colorByPoint ? this.options.color = null : this.getCyclic(\"color\", this.options.color || a[this.type].color, this.chart.options.colors);\n      },\n      getSymbol: function getSymbol() {\n        this.getCyclic(\"symbol\", this.options.marker.symbol, this.chart.options.symbols);\n      },\n      findPointIndex: function findPointIndex(a, b) {\n        var d = a.id;\n        a = a.x;\n        var e = this.points,\n            c;\n\n        if (d) {\n          var l = (d = this.chart.get(d)) && d.index;\n          void 0 !== l && (c = !0);\n        }\n\n        void 0 === l && G(a) && (l = this.xData.indexOf(a, b));\n        -1 !== l && void 0 !== l && this.cropped && (l = l >= this.cropStart ? l - this.cropStart : l);\n        !c && e[l] && e[l].touched && (l = void 0);\n        return l;\n      },\n      drawLegendSymbol: c.LegendSymbolMixin.drawLineMarker,\n      updateData: function updateData(a) {\n        var b = this.options,\n            d = this.points,\n            e = [],\n            c,\n            l,\n            h,\n            g = this.requireSorting,\n            k = a.length === d.length,\n            f = !0;\n        this.xIncrement = null;\n        a.forEach(function (a, l) {\n          var t = A(a) && this.pointClass.prototype.optionsToObject.call({\n            series: this\n          }, a) || {};\n          var f = t.x;\n          if (t.id || G(f)) if (f = this.findPointIndex(t, h), -1 === f || void 0 === f ? e.push(a) : d[f] && a !== b.data[f] ? (d[f].update(a, !1, null, !1), d[f].touched = !0, g && (h = f + 1)) : d[f] && (d[f].touched = !0), !k || l !== f || this.hasDerivedData) c = !0;\n        }, this);\n        if (c) for (a = d.length; a--;) {\n          (l = d[a]) && !l.touched && l.remove(!1);\n        } else k ? a.forEach(function (a, b) {\n          d[b].update && a !== d[b].y && d[b].update(a, !1, null, !1);\n        }) : f = !1;\n        d.forEach(function (a) {\n          a && (a.touched = !1);\n        });\n        if (!f) return !1;\n        e.forEach(function (a) {\n          this.addPoint(a, !1, null, null, !1);\n        }, this);\n        return !0;\n      },\n      setData: function setData(a, b, d, e) {\n        var l = this,\n            h = l.points,\n            g = h && h.length || 0,\n            t,\n            f = l.options,\n            r = l.chart,\n            n = null,\n            B = l.xAxis;\n        n = f.turboThreshold;\n        var x = this.xData,\n            m = this.yData,\n            I = (t = l.pointArrayMap) && t.length,\n            q = f.keys,\n            w = 0,\n            F = 1,\n            p;\n        a = a || [];\n        t = a.length;\n        b = k(b, !0);\n        !1 !== e && t && g && !l.cropped && !l.hasGroupedData && l.visible && !l.isSeriesBoosting && (p = this.updateData(a));\n\n        if (!p) {\n          l.xIncrement = null;\n          l.colorCounter = 0;\n          this.parallelArrays.forEach(function (a) {\n            l[a + \"Data\"].length = 0;\n          });\n          if (n && t > n) {\n            if (n = l.getFirstValidPoint(a), G(n)) for (d = 0; d < t; d++) {\n              x[d] = this.autoIncrement(), m[d] = a[d];\n            } else if (y(n)) {\n              if (I) for (d = 0; d < t; d++) {\n                e = a[d], x[d] = e[0], m[d] = e.slice(1, I + 1);\n              } else for (q && (w = q.indexOf(\"x\"), F = q.indexOf(\"y\"), w = 0 <= w ? w : 0, F = 0 <= F ? F : 1), d = 0; d < t; d++) {\n                e = a[d], x[d] = e[w], m[d] = e[F];\n              }\n            } else c.error(12, !1, r);\n          } else for (d = 0; d < t; d++) {\n            void 0 !== a[d] && (e = {\n              series: l\n            }, l.pointClass.prototype.applyOptions.apply(e, [a[d]]), l.updateParallelArrays(e, d));\n          }\n          m && v(m[0]) && c.error(14, !0, r);\n          l.data = [];\n          l.options.data = l.userOptions.data = a;\n\n          for (d = g; d--;) {\n            h[d] && h[d].destroy && h[d].destroy();\n          }\n\n          B && (B.minRange = B.userMinRange);\n          l.isDirty = r.isDirtyBox = !0;\n          l.isDirtyData = !!h;\n          d = !1;\n        }\n\n        \"point\" === f.legendType && (this.processData(), this.generatePoints());\n        b && r.redraw(d);\n      },\n      processData: function processData(a) {\n        var b = this.xData,\n            d = this.yData,\n            e = b.length;\n        var l = 0;\n        var h = this.xAxis,\n            g = this.options;\n        var k = g.cropThreshold;\n        var f = this.getExtremesFromAll || g.getExtremesFromAll,\n            r = this.isCartesian;\n        g = h && h.val2lin;\n        var n = h && h.isLog,\n            x = this.requireSorting;\n        if (r && !this.isDirty && !h.isDirty && !this.yAxis.isDirty && !a) return !1;\n\n        if (h) {\n          a = h.getExtremes();\n          var m = a.min;\n          var q = a.max;\n        }\n\n        if (r && this.sorted && !f && (!k || e > k || this.forceCrop)) if (b[e - 1] < m || b[0] > q) b = [], d = [];else if (this.yData && (b[0] < m || b[e - 1] > q)) {\n          l = this.cropData(this.xData, this.yData, m, q);\n          b = l.xData;\n          d = l.yData;\n          l = l.start;\n          var w = !0;\n        }\n\n        for (k = b.length || 1; --k;) {\n          if (e = n ? g(b[k]) - g(b[k - 1]) : b[k] - b[k - 1], 0 < e && (void 0 === F || e < F)) var F = e;else 0 > e && x && (c.error(15, !1, this.chart), x = !1);\n        }\n\n        this.cropped = w;\n        this.cropStart = l;\n        this.processedXData = b;\n        this.processedYData = d;\n        this.closestPointRange = this.basePointRange = F;\n      },\n      cropData: function cropData(a, b, d, e, c) {\n        var l = a.length,\n            h = 0,\n            g = l,\n            f;\n        c = k(c, this.cropShoulder);\n\n        for (f = 0; f < l; f++) {\n          if (a[f] >= d) {\n            h = Math.max(0, f - c);\n            break;\n          }\n        }\n\n        for (d = f; d < l; d++) {\n          if (a[d] > e) {\n            g = d + c;\n            break;\n          }\n        }\n\n        return {\n          xData: a.slice(h, g),\n          yData: b.slice(h, g),\n          start: h,\n          end: g\n        };\n      },\n      generatePoints: function generatePoints() {\n        var a = this.options,\n            b = a.data,\n            d = this.data,\n            e,\n            c = this.processedXData,\n            g = this.processedYData,\n            k = this.pointClass,\n            f = c.length,\n            r = this.cropStart || 0,\n            n = this.hasGroupedData;\n        a = a.keys;\n        var x = [],\n            q;\n        d || n || (d = [], d.length = b.length, d = this.data = d);\n        a && n && (this.options.keys = !1);\n\n        for (q = 0; q < f; q++) {\n          var w = r + q;\n\n          if (n) {\n            var F = new k().init(this, [c[q]].concat(m(g[q])));\n            F.dataGroup = this.groupMap[q];\n            F.dataGroup.options && (F.options = F.dataGroup.options, p(F, F.dataGroup.options), delete F.dataLabels);\n          } else (F = d[w]) || void 0 === b[w] || (d[w] = F = new k().init(this, b[w], c[q]));\n\n          F && (F.index = w, x[q] = F);\n        }\n\n        this.options.keys = a;\n        if (d && (f !== (e = d.length) || n)) for (q = 0; q < e; q++) {\n          q !== r || n || (q += f), d[q] && (d[q].destroyElements(), d[q].plotX = void 0);\n        }\n        this.data = d;\n        this.points = x;\n        h(this, \"afterGeneratePoints\");\n      },\n      getXExtremes: function getXExtremes(a) {\n        return {\n          min: D(a),\n          max: H(a)\n        };\n      },\n      getExtremes: function getExtremes(a) {\n        var b = this.xAxis,\n            d = this.yAxis,\n            e = this.processedXData || this.xData,\n            c = [],\n            l = 0,\n            g = 0;\n        var k = 0;\n        var f = this.requireSorting ? this.cropShoulder : 0,\n            r = d ? d.positiveValuesOnly : !1,\n            n;\n        a = a || this.stackedYData || this.processedYData || [];\n        d = a.length;\n        b && (k = b.getExtremes(), g = k.min, k = k.max);\n\n        for (n = 0; n < d; n++) {\n          var x = e[n];\n          var m = a[n];\n          var q = (G(m) || y(m)) && (m.length || 0 < m || !r);\n          x = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !b || (e[n + f] || x) >= g && (e[n - f] || x) <= k;\n          if (q && x) if (q = m.length) for (; q--;) {\n            G(m[q]) && (c[l++] = m[q]);\n          } else c[l++] = m;\n        }\n\n        this.dataMin = D(c);\n        this.dataMax = H(c);\n        h(this, \"afterGetExtremes\");\n      },\n      getFirstValidPoint: function getFirstValidPoint(a) {\n        for (var b = null, d = a.length, e = 0; null === b && e < d;) {\n          b = a[e], e++;\n        }\n\n        return b;\n      },\n      translate: function translate() {\n        this.processedXData || this.processData();\n        this.generatePoints();\n        var a = this.options,\n            d = a.stacking,\n            e = this.xAxis,\n            c = e.categories,\n            g = this.yAxis,\n            f = this.points,\n            r = f.length,\n            n = !!this.modifyValue,\n            x,\n            m = this.pointPlacementToXValue(),\n            q = G(m),\n            w = a.threshold,\n            F = a.startFromThreshold ? w : 0,\n            p,\n            v = this.zoneAxis || \"y\",\n            E = Number.MAX_VALUE;\n\n        for (x = 0; x < r; x++) {\n          var D = f[x],\n              H = D.x;\n          var C = D.y;\n          var K = D.low,\n              P = d && g.stacks[(this.negStacks && C < (F ? 0 : w) ? \"-\" : \"\") + this.stackKey];\n          g.positiveValuesOnly && null !== C && 0 >= C && (D.isNull = !0);\n          D.plotX = p = b(Math.min(Math.max(-1E5, e.translate(H, 0, 0, 0, 1, m, \"flags\" === this.type)), 1E5));\n\n          if (d && this.visible && P && P[H]) {\n            var Y = this.getStackIndicator(Y, H, this.index);\n\n            if (!D.isNull) {\n              var V = P[H];\n              var Z = V.points[Y.key];\n            }\n          }\n\n          y(Z) && (K = Z[0], C = Z[1], K === F && Y.key === P[H].base && (K = k(G(w) && w, g.min)), g.positiveValuesOnly && 0 >= K && (K = null), D.total = D.stackTotal = V.total, D.percentage = V.total && D.y / V.total * 100, D.stackY = C, this.irregularWidths || V.setOffset(this.pointXOffset || 0, this.barW || 0));\n          D.yBottom = A(K) ? Math.min(Math.max(-1E5, g.translate(K, 0, 1, 0, 1)), 1E5) : null;\n          n && (C = this.modifyValue(C, D));\n          D.plotY = C = \"number\" === typeof C && Infinity !== C ? Math.min(Math.max(-1E5, g.translate(C, 0, 1, 0, 1)), 1E5) : void 0;\n          D.isInside = void 0 !== C && 0 <= C && C <= g.len && 0 <= p && p <= e.len;\n          D.clientX = q ? b(e.translate(H, 0, 0, 0, 1, m)) : p;\n          D.negative = D[v] < (a[v + \"Threshold\"] || w || 0);\n          D.category = c && void 0 !== c[D.x] ? c[D.x] : D.x;\n\n          if (!D.isNull) {\n            void 0 !== aa && (E = Math.min(E, Math.abs(p - aa)));\n            var aa = p;\n          }\n\n          D.zone = this.zones.length && D.getZone();\n        }\n\n        this.closestPointRangePx = E;\n        h(this, \"afterTranslate\");\n      },\n      getValidPoints: function getValidPoints(a, b, d) {\n        var e = this.chart;\n        return (a || this.points || []).filter(function (a) {\n          return b && !e.isInsidePlot(a.plotX, a.plotY, e.inverted) ? !1 : d || !a.isNull;\n        });\n      },\n      getClipBox: function getClipBox(a, b) {\n        var d = this.options,\n            e = this.chart,\n            c = e.inverted,\n            l = this.xAxis,\n            h = l && this.yAxis;\n        a && !1 === d.clip && h ? a = c ? {\n          y: -e.chartWidth + h.len + h.pos,\n          height: e.chartWidth,\n          width: e.chartHeight,\n          x: -e.chartHeight + l.len + l.pos\n        } : {\n          y: -h.pos,\n          height: e.chartHeight,\n          width: e.chartWidth,\n          x: -l.pos\n        } : (a = this.clipBox || e.clipBox, b && (a.width = e.plotSizeX, a.x = 0));\n        return b ? {\n          width: a.width,\n          x: a.x\n        } : a;\n      },\n      setClip: function setClip(a) {\n        var b = this.chart,\n            d = this.options,\n            e = b.renderer,\n            c = b.inverted,\n            l = this.clipBox,\n            h = this.getClipBox(a),\n            g = this.sharedClipKey || [\"_sharedClip\", a && a.duration, a && a.easing, h.height, d.xAxis, d.yAxis].join(),\n            k = b[g],\n            f = b[g + \"m\"];\n        k || (a && (h.width = 0, c && (h.x = b.plotSizeX + (!1 !== d.clip ? 0 : b.plotTop)), b[g + \"m\"] = f = e.clipRect(c ? b.plotSizeX + 99 : -99, c ? -b.plotLeft : -b.plotTop, 99, c ? b.chartWidth : b.chartHeight)), b[g] = k = e.clipRect(h), k.count = {\n          length: 0\n        });\n        a && !k.count[this.index] && (k.count[this.index] = !0, k.count.length += 1);\n        if (!1 !== d.clip || a) this.group.clip(a || l ? k : b.clipRect), this.markerGroup.clip(f), this.sharedClipKey = g;\n        a || (k.count[this.index] && (delete k.count[this.index], --k.count.length), 0 === k.count.length && g && b[g] && (l || (b[g] = b[g].destroy()), b[g + \"m\"] && (b[g + \"m\"] = b[g + \"m\"].destroy())));\n      },\n      animate: function animate(a) {\n        var b = this.chart,\n            d = e(this.options.animation);\n        if (a) this.setClip(d);else {\n          var c = this.sharedClipKey;\n          a = b[c];\n          var l = this.getClipBox(d, !0);\n          a && a.animate(l, d);\n          b[c + \"m\"] && b[c + \"m\"].animate({\n            width: l.width + 99,\n            x: l.x - (b.inverted ? 0 : 99)\n          }, d);\n          this.animate = null;\n        }\n      },\n      afterAnimate: function afterAnimate() {\n        this.setClip();\n        h(this, \"afterAnimate\");\n        this.finishedAnimating = !0;\n      },\n      drawPoints: function drawPoints() {\n        var a = this.points,\n            b = this.chart,\n            d,\n            e = this.options.marker,\n            c = this[this.specialGroup] || this.markerGroup;\n        var h = this.xAxis;\n        var g = k(e.enabled, !h || h.isRadial ? !0 : null, this.closestPointRangePx >= e.enabledThreshold * e.radius);\n        if (!1 !== e.enabled || this._hasPointMarkers) for (h = 0; h < a.length; h++) {\n          var f = a[h];\n          var r = (d = f.graphic) ? \"animate\" : \"attr\";\n          var n = f.marker || {};\n          var x = !!f.marker;\n          var m = g && void 0 === n.enabled || n.enabled;\n          var q = !1 !== f.isInside;\n\n          if (m && !f.isNull) {\n            var w = k(n.symbol, this.symbol);\n            m = this.markerAttribs(f, f.selected && \"select\");\n            d ? d[q ? \"show\" : \"hide\"](q).animate(m) : q && (0 < m.width || f.hasImage) && (f.graphic = d = b.renderer.symbol(w, m.x, m.y, m.width, m.height, x ? n : e).add(c));\n            if (d && !b.styledMode) d[r](this.pointAttribs(f, f.selected && \"select\"));\n            d && d.addClass(f.getClassName(), !0);\n          } else d && (f.graphic = d.destroy());\n        }\n      },\n      markerAttribs: function markerAttribs(a, b) {\n        var d = this.options.marker,\n            e = a.marker || {},\n            c = e.symbol || d.symbol,\n            h = k(e.radius, d.radius);\n        b && (d = d.states[b], b = e.states && e.states[b], h = k(b && b.radius, d && d.radius, h + (d && d.radiusPlus || 0)));\n        a.hasImage = c && 0 === c.indexOf(\"url\");\n        a.hasImage && (h = 0);\n        a = {\n          x: Math.floor(a.plotX) - h,\n          y: a.plotY - h\n        };\n        h && (a.width = a.height = 2 * h);\n        return a;\n      },\n      pointAttribs: function pointAttribs(a, b) {\n        var d = this.options.marker,\n            e = a && a.options,\n            c = e && e.marker || {},\n            h = this.color,\n            l = e && e.color,\n            g = a && a.color;\n        e = k(c.lineWidth, d.lineWidth);\n        var f = a && a.zone && a.zone.color;\n        a = 1;\n        h = l || f || g || h;\n        l = c.fillColor || d.fillColor || h;\n        h = c.lineColor || d.lineColor || h;\n        b = b || \"normal\";\n        d = d.states[b];\n        b = c.states && c.states[b] || {};\n        e = k(b.lineWidth, d.lineWidth, e + k(b.lineWidthPlus, d.lineWidthPlus, 0));\n        l = b.fillColor || d.fillColor || l;\n        h = b.lineColor || d.lineColor || h;\n        a = k(b.opacity, d.opacity, a);\n        return {\n          stroke: h,\n          \"stroke-width\": e,\n          fill: l,\n          opacity: a\n        };\n      },\n      destroy: function destroy(a) {\n        var b = this,\n            d = b.chart,\n            e = /AppleWebKit\\/533/.test(x.navigator.userAgent),\n            l,\n            g,\n            k = b.data || [],\n            f,\n            n;\n        h(b, \"destroy\");\n        a || F(b);\n        (b.axisTypes || []).forEach(function (a) {\n          (n = b[a]) && n.series && (E(n.series, b), n.isDirty = n.forceRedraw = !0);\n        });\n        b.legendItem && b.chart.legend.destroyItem(b);\n\n        for (g = k.length; g--;) {\n          (f = k[g]) && f.destroy && f.destroy();\n        }\n\n        b.points = null;\n        c.clearTimeout(b.animationTimeout);\n        q(b, function (a, b) {\n          a instanceof r && !a.survive && (l = e && \"group\" === b ? \"hide\" : \"destroy\", a[l]());\n        });\n        d.hoverSeries === b && (d.hoverSeries = null);\n        E(d.series, b);\n        d.orderSeries();\n        q(b, function (d, e) {\n          a && \"hcEvents\" === e || delete b[e];\n        });\n      },\n      getGraphPath: function getGraphPath(a, b, d) {\n        var e = this,\n            c = e.options,\n            h = c.step,\n            l,\n            g = [],\n            k = [],\n            f;\n        a = a || e.points;\n        (l = a.reversed) && a.reverse();\n        (h = {\n          right: 1,\n          center: 2\n        }[h] || h && 3) && l && (h = 4 - h);\n        !c.connectNulls || b || d || (a = this.getValidPoints(a));\n        a.forEach(function (l, r) {\n          var t = l.plotX,\n              n = l.plotY,\n              u = a[r - 1];\n          (l.leftCliff || u && u.rightCliff) && !d && (f = !0);\n          l.isNull && !A(b) && 0 < r ? f = !c.connectNulls : l.isNull && !b ? f = !0 : (0 === r || f ? r = [\"M\", l.plotX, l.plotY] : e.getPointSpline ? r = e.getPointSpline(a, l, r) : h ? (r = 1 === h ? [\"L\", u.plotX, n] : 2 === h ? [\"L\", (u.plotX + t) / 2, u.plotY, \"L\", (u.plotX + t) / 2, n] : [\"L\", t, u.plotY], r.push(\"L\", t, n)) : r = [\"L\", t, n], k.push(l.x), h && (k.push(l.x), 2 === h && k.push(l.x)), g.push.apply(g, r), f = !1);\n        });\n        g.xMap = k;\n        return e.graphPath = g;\n      },\n      drawGraph: function drawGraph() {\n        var a = this,\n            b = this.options,\n            d = (this.gappedPath || this.getGraphPath).call(this),\n            e = this.chart.styledMode,\n            c = [[\"graph\", \"highcharts-graph\"]];\n        e || c[0].push(b.lineColor || this.color || \"#cccccc\", b.dashStyle);\n        c = a.getZonesGraphs(c);\n        c.forEach(function (c, h) {\n          var l = c[0],\n              g = a[l],\n              k = g ? \"animate\" : \"attr\";\n          g ? (g.endX = a.preventGraphAnimation ? null : d.xMap, g.animate({\n            d: d\n          })) : d.length && (a[l] = g = a.chart.renderer.path(d).addClass(c[1]).attr({\n            zIndex: 1\n          }).add(a.group));\n          g && !e && (l = {\n            stroke: c[2],\n            \"stroke-width\": b.lineWidth,\n            fill: a.fillGraph && a.color || \"none\"\n          }, c[3] ? l.dashstyle = c[3] : \"square\" !== b.linecap && (l[\"stroke-linecap\"] = l[\"stroke-linejoin\"] = \"round\"), g[k](l).shadow(2 > h && b.shadow));\n          g && (g.startX = d.xMap, g.isArea = d.isArea);\n        });\n      },\n      getZonesGraphs: function getZonesGraphs(a) {\n        this.zones.forEach(function (b, d) {\n          d = [\"zone-graph-\" + d, \"highcharts-graph highcharts-zone-graph-\" + d + \" \" + (b.className || \"\")];\n          this.chart.styledMode || d.push(b.color || this.color, b.dashStyle || this.options.dashStyle);\n          a.push(d);\n        }, this);\n        return a;\n      },\n      applyZones: function applyZones() {\n        var a = this,\n            b = this.chart,\n            d = b.renderer,\n            e = this.zones,\n            c,\n            h,\n            g = this.clips || [],\n            f,\n            r = this.graph,\n            n = this.area,\n            x = Math.max(b.chartWidth, b.chartHeight),\n            m = this[(this.zoneAxis || \"y\") + \"Axis\"],\n            q = b.inverted,\n            w,\n            F,\n            p,\n            y = !1;\n\n        if (e.length && (r || n) && m && void 0 !== m.min) {\n          var v = m.reversed;\n          var A = m.horiz;\n          r && !this.showLine && r.hide();\n          n && n.hide();\n          var G = m.getExtremes();\n          e.forEach(function (e, l) {\n            c = v ? A ? b.plotWidth : 0 : A ? 0 : m.toPixels(G.min) || 0;\n            c = Math.min(Math.max(k(h, c), 0), x);\n            h = Math.min(Math.max(Math.round(m.toPixels(k(e.value, G.max), !0) || 0), 0), x);\n            y && (c = h = m.toPixels(G.max));\n            w = Math.abs(c - h);\n            F = Math.min(c, h);\n            p = Math.max(c, h);\n            m.isXAxis ? (f = {\n              x: q ? p : F,\n              y: 0,\n              width: w,\n              height: x\n            }, A || (f.x = b.plotHeight - f.x)) : (f = {\n              x: 0,\n              y: q ? p : F,\n              width: x,\n              height: w\n            }, A && (f.y = b.plotWidth - f.y));\n            q && d.isVML && (f = m.isXAxis ? {\n              x: 0,\n              y: v ? F : p,\n              height: f.width,\n              width: b.chartWidth\n            } : {\n              x: f.y - b.plotLeft - b.spacingBox.x,\n              y: 0,\n              width: f.height,\n              height: b.chartHeight\n            });\n            g[l] ? g[l].animate(f) : g[l] = d.clipRect(f);\n            r && a[\"zone-graph-\" + l].clip(g[l]);\n            n && a[\"zone-area-\" + l].clip(g[l]);\n            y = e.value > G.max;\n            a.resetZones && 0 === h && (h = void 0);\n          });\n          this.clips = g;\n        } else a.visible && (r && r.show(!0), n && n.show(!0));\n      },\n      invertGroups: function invertGroups(a) {\n        function b() {\n          [\"group\", \"markerGroup\"].forEach(function (b) {\n            d[b] && (e.renderer.isVML && d[b].attr({\n              width: d.yAxis.len,\n              height: d.xAxis.len\n            }), d[b].width = d.yAxis.len, d[b].height = d.xAxis.len, d[b].invert(a));\n          });\n        }\n\n        var d = this,\n            e = d.chart;\n\n        if (d.xAxis) {\n          var c = g(e, \"resize\", b);\n          g(d, \"destroy\", c);\n          b(a);\n          d.invertGroups = b;\n        }\n      },\n      plotGroup: function plotGroup(a, b, d, e, c) {\n        var h = this[a],\n            l = !h;\n        l && (this[a] = h = this.chart.renderer.g().attr({\n          zIndex: e || .1\n        }).add(c));\n        h.addClass(\"highcharts-\" + b + \" highcharts-series-\" + this.index + \" highcharts-\" + this.type + \"-series \" + (A(this.colorIndex) ? \"highcharts-color-\" + this.colorIndex + \" \" : \"\") + (this.options.className || \"\") + (h.hasClass(\"highcharts-tracker\") ? \" highcharts-tracker\" : \"\"), !0);\n        h.attr({\n          visibility: d\n        })[l ? \"attr\" : \"animate\"](this.getPlotBox());\n        return h;\n      },\n      getPlotBox: function getPlotBox() {\n        var a = this.chart,\n            b = this.xAxis,\n            d = this.yAxis;\n        a.inverted && (b = d, d = this.xAxis);\n        return {\n          translateX: b ? b.left : a.plotLeft,\n          translateY: d ? d.top : a.plotTop,\n          scaleX: 1,\n          scaleY: 1\n        };\n      },\n      render: function render() {\n        var a = this,\n            b = a.chart,\n            d = a.options,\n            c = !!a.animate && b.renderer.isSVG && e(d.animation).duration,\n            g = a.visible ? \"inherit\" : \"hidden\",\n            k = d.zIndex,\n            f = a.hasRendered,\n            r = b.seriesGroup,\n            n = b.inverted;\n        h(this, \"render\");\n        var x = a.plotGroup(\"group\", \"series\", g, k, r);\n        a.markerGroup = a.plotGroup(\"markerGroup\", \"markers\", g, k, r);\n        c && a.animate(!0);\n        x.inverted = a.isCartesian || a.invertable ? n : !1;\n        a.drawGraph && (a.drawGraph(), a.applyZones());\n        a.visible && a.drawPoints();\n        a.drawDataLabels && a.drawDataLabels();\n        a.redrawPoints && a.redrawPoints();\n        a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker();\n        a.invertGroups(n);\n        !1 === d.clip || a.sharedClipKey || f || x.clip(b.clipRect);\n        c && a.animate();\n        f || (a.animationTimeout = w(function () {\n          a.afterAnimate();\n        }, c || 0));\n        a.isDirty = !1;\n        a.hasRendered = !0;\n        h(a, \"afterRender\");\n      },\n      redraw: function redraw() {\n        var a = this.chart,\n            b = this.isDirty || this.isDirtyData,\n            d = this.group,\n            e = this.xAxis,\n            c = this.yAxis;\n        d && (a.inverted && d.attr({\n          width: a.plotWidth,\n          height: a.plotHeight\n        }), d.animate({\n          translateX: k(e && e.left, a.plotLeft),\n          translateY: k(c && c.top, a.plotTop)\n        }));\n        this.translate();\n        this.render();\n        b && delete this.kdTree;\n      },\n      kdAxisArray: [\"clientX\", \"plotY\"],\n      searchPoint: function searchPoint(a, b) {\n        var d = this.xAxis,\n            e = this.yAxis,\n            c = this.chart.inverted;\n        return this.searchKDTree({\n          clientX: c ? d.len - a.chartY + d.pos : a.chartX - d.pos,\n          plotY: c ? e.len - a.chartX + e.pos : a.chartY - e.pos\n        }, b, a);\n      },\n      buildKDTree: function buildKDTree(a) {\n        function b(a, e, c) {\n          var h;\n\n          if (h = a && a.length) {\n            var l = d.kdAxisArray[e % c];\n            a.sort(function (a, b) {\n              return a[l] - b[l];\n            });\n            h = Math.floor(h / 2);\n            return {\n              point: a[h],\n              left: b(a.slice(0, h), e + 1, c),\n              right: b(a.slice(h + 1), e + 1, c)\n            };\n          }\n        }\n\n        this.buildingKdTree = !0;\n        var d = this,\n            e = -1 < d.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        delete d.kdTree;\n        w(function () {\n          d.kdTree = b(d.getValidPoints(null, !d.directTouch), e, e);\n          d.buildingKdTree = !1;\n        }, d.options.kdNow || a && \"touchstart\" === a.type ? 0 : 1);\n      },\n      searchKDTree: function searchKDTree(a, b, d) {\n        function e(a, b, d, k) {\n          var f = b.point,\n              r = c.kdAxisArray[d % k],\n              n = f;\n          var t = A(a[h]) && A(f[h]) ? Math.pow(a[h] - f[h], 2) : null;\n          var x = A(a[l]) && A(f[l]) ? Math.pow(a[l] - f[l], 2) : null;\n          x = (t || 0) + (x || 0);\n          f.dist = A(x) ? Math.sqrt(x) : Number.MAX_VALUE;\n          f.distX = A(t) ? Math.sqrt(t) : Number.MAX_VALUE;\n          r = a[r] - f[r];\n          x = 0 > r ? \"left\" : \"right\";\n          t = 0 > r ? \"right\" : \"left\";\n          b[x] && (x = e(a, b[x], d + 1, k), n = x[g] < n[g] ? x : f);\n          b[t] && Math.sqrt(r * r) < n[g] && (a = e(a, b[t], d + 1, k), n = a[g] < n[g] ? a : n);\n          return n;\n        }\n\n        var c = this,\n            h = this.kdAxisArray[0],\n            l = this.kdAxisArray[1],\n            g = b ? \"distX\" : \"dist\";\n        b = -1 < c.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        this.kdTree || this.buildingKdTree || this.buildKDTree(d);\n        if (this.kdTree) return e(a, this.kdTree, b, b);\n      },\n      pointPlacementToXValue: function pointPlacementToXValue() {\n        var a = this.xAxis,\n            b = this.options.pointPlacement;\n        \"between\" === b && (b = a.reversed ? -.5 : .5);\n        G(b) && (b *= k(this.options.pointRange || a.pointRange));\n        return b;\n      }\n    });\n    \"\";\n  });\n  K(C, \"parts/Stacking.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var H = f.defined,\n        D = f.destroyObjectProperties,\n        A = f.objectEach,\n        E = f.pick;\n    f = c.Axis;\n    var p = c.Chart,\n        y = c.correctFloat,\n        G = c.format,\n        v = c.Series;\n\n    c.StackItem = function (c, f, m, w, g) {\n      var e = c.chart.inverted;\n      this.axis = c;\n      this.isNegative = m;\n      this.options = f = f || {};\n      this.x = w;\n      this.total = null;\n      this.points = {};\n      this.stack = g;\n      this.rightCliff = this.leftCliff = 0;\n      this.alignOptions = {\n        align: f.align || (e ? m ? \"left\" : \"right\" : \"center\"),\n        verticalAlign: f.verticalAlign || (e ? \"middle\" : m ? \"bottom\" : \"top\"),\n        y: f.y,\n        x: f.x\n      };\n      this.textAlign = f.textAlign || (e ? m ? \"right\" : \"left\" : \"center\");\n    };\n\n    c.StackItem.prototype = {\n      destroy: function destroy() {\n        D(this, this.axis);\n      },\n      render: function render(c) {\n        var f = this.axis.chart,\n            m = this.options,\n            q = m.format;\n        q = q ? G(q, this, f.time) : m.formatter.call(this);\n        this.label ? this.label.attr({\n          text: q,\n          visibility: \"hidden\"\n        }) : (this.label = f.renderer.label(q, null, null, m.shape, null, null, m.useHTML, !1, \"stack-labels\"), q = {\n          text: q,\n          align: this.textAlign,\n          rotation: m.rotation,\n          padding: E(m.padding, 0),\n          visibility: \"hidden\"\n        }, this.label.attr(q), f.styledMode || this.label.css(m.style), this.label.added || this.label.add(c));\n        this.label.labelrank = f.plotHeight;\n      },\n      setOffset: function setOffset(c, f, m, w, g) {\n        var e = this.axis,\n            b = e.chart;\n        w = e.translate(e.usePercentage ? 100 : w ? w : this.total, 0, 0, 0, 1);\n        m = e.translate(m ? m : 0);\n        m = H(w) && Math.abs(w - m);\n        c = E(g, b.xAxis[0].translate(this.x)) + c;\n        e = H(w) && this.getStackBox(b, this, c, w, f, m, e);\n        f = this.label;\n        c = this.isNegative;\n        g = \"justify\" === E(this.options.overflow, \"justify\");\n\n        if (f && e) {\n          m = f.getBBox();\n          var d = b.inverted ? c ? m.width : 0 : m.width / 2,\n              a = b.inverted ? m.height / 2 : c ? -4 : m.height + 4;\n          this.alignOptions.x = E(this.options.x, 0);\n          f.align(this.alignOptions, null, e);\n          w = f.alignAttr;\n          f.show();\n          w.y -= a;\n          g && (w.x -= d, v.prototype.justifyDataLabel.call(this.axis, f, this.alignOptions, w, m, e), w.x += d);\n          w.x = f.alignAttr.x;\n          f.attr({\n            x: w.x,\n            y: w.y\n          });\n          E(!g && this.options.crop, !0) && ((b = b.isInsidePlot(f.x + (b.inverted ? 0 : -m.width / 2), f.y) && b.isInsidePlot(f.x + (b.inverted ? c ? -m.width : m.width : m.width / 2), f.y + m.height)) || f.hide());\n        }\n      },\n      getStackBox: function getStackBox(c, f, m, w, g, e, b) {\n        var d = f.axis.reversed,\n            a = c.inverted;\n        c = b.height + b.pos - (a ? c.plotLeft : c.plotTop);\n        f = f.isNegative && !d || !f.isNegative && d;\n        return {\n          x: a ? f ? w : w - e : m,\n          y: a ? c - m - g : f ? c - w - e : c - w,\n          width: a ? e : g,\n          height: a ? g : e\n        };\n      }\n    };\n\n    p.prototype.getStacks = function () {\n      var c = this,\n          f = c.inverted;\n      c.yAxis.forEach(function (c) {\n        c.stacks && c.hasVisibleSeries && (c.oldStacks = c.stacks);\n      });\n      c.series.forEach(function (k) {\n        var m = k.xAxis && k.xAxis.options || {};\n        !k.options.stacking || !0 !== k.visible && !1 !== c.options.chart.ignoreHiddenSeries || (k.stackKey = [k.type, E(k.options.stack, \"\"), f ? m.top : m.left, f ? m.height : m.width].join());\n      });\n    };\n\n    f.prototype.buildStacks = function () {\n      var c = this.series,\n          f = E(this.options.reversedStacks, !0),\n          m = c.length,\n          w;\n\n      if (!this.isXAxis) {\n        this.usePercentage = !1;\n\n        for (w = m; w--;) {\n          c[f ? w : m - w - 1].setStackedPoints();\n        }\n\n        for (w = 0; w < m; w++) {\n          c[w].modifyStacks();\n        }\n      }\n    };\n\n    f.prototype.renderStackTotals = function () {\n      var c = this.chart,\n          f = c.renderer,\n          m = this.stacks,\n          w = this.stackTotalGroup;\n      w || (this.stackTotalGroup = w = f.g(\"stack-labels\").attr({\n        visibility: \"visible\",\n        zIndex: 6\n      }).add());\n      w.translate(c.plotLeft, c.plotTop);\n      A(m, function (c) {\n        A(c, function (e) {\n          e.render(w);\n        });\n      });\n    };\n\n    f.prototype.resetStacks = function () {\n      var c = this,\n          f = c.stacks;\n      c.isXAxis || A(f, function (f) {\n        A(f, function (k, g) {\n          k.touched < c.stacksTouched ? (k.destroy(), delete f[g]) : (k.total = null, k.cumulative = null);\n        });\n      });\n    };\n\n    f.prototype.cleanStacks = function () {\n      if (!this.isXAxis) {\n        if (this.oldStacks) var c = this.stacks = this.oldStacks;\n        A(c, function (c) {\n          A(c, function (c) {\n            c.cumulative = c.total;\n          });\n        });\n      }\n    };\n\n    v.prototype.setStackedPoints = function () {\n      if (this.options.stacking && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {\n        var f = this.processedXData,\n            k = this.processedYData,\n            m = [],\n            w = k.length,\n            g = this.options,\n            e = g.threshold,\n            b = E(g.startFromThreshold && e, 0),\n            d = g.stack;\n        g = g.stacking;\n        var a = this.stackKey,\n            h = \"-\" + a,\n            n = this.negStacks,\n            F = this.yAxis,\n            r = F.stacks,\n            x = F.oldStacks,\n            l,\n            t;\n        F.stacksTouched += 1;\n\n        for (t = 0; t < w; t++) {\n          var B = f[t];\n          var I = k[t];\n          var z = this.getStackIndicator(z, B, this.index);\n          var u = z.key;\n          var p = (l = n && I < (b ? 0 : e)) ? h : a;\n          r[p] || (r[p] = {});\n          r[p][B] || (x[p] && x[p][B] ? (r[p][B] = x[p][B], r[p][B].total = null) : r[p][B] = new c.StackItem(F, F.options.stackLabels, l, B, d));\n          p = r[p][B];\n          null !== I ? (p.points[u] = p.points[this.index] = [E(p.cumulative, b)], H(p.cumulative) || (p.base = u), p.touched = F.stacksTouched, 0 < z.index && !1 === this.singleStacks && (p.points[u][0] = p.points[this.index + \",\" + B + \",0\"][0])) : p.points[u] = p.points[this.index] = null;\n          \"percent\" === g ? (l = l ? a : h, n && r[l] && r[l][B] ? (l = r[l][B], p.total = l.total = Math.max(l.total, p.total) + Math.abs(I) || 0) : p.total = y(p.total + (Math.abs(I) || 0))) : p.total = y(p.total + (I || 0));\n          p.cumulative = E(p.cumulative, b) + (I || 0);\n          null !== I && (p.points[u].push(p.cumulative), m[t] = p.cumulative);\n        }\n\n        \"percent\" === g && (F.usePercentage = !0);\n        this.stackedYData = m;\n        F.oldStacks = {};\n      }\n    };\n\n    v.prototype.modifyStacks = function () {\n      var c = this,\n          f = c.stackKey,\n          m = c.yAxis.stacks,\n          p = c.processedXData,\n          g,\n          e = c.options.stacking;\n      c[e + \"Stacker\"] && [f, \"-\" + f].forEach(function (b) {\n        for (var d = p.length, a, h; d--;) {\n          if (a = p[d], g = c.getStackIndicator(g, a, c.index, b), h = (a = m[b] && m[b][a]) && a.points[g.key]) c[e + \"Stacker\"](h, a, d);\n        }\n      });\n    };\n\n    v.prototype.percentStacker = function (c, f, m) {\n      f = f.total ? 100 / f.total : 0;\n      c[0] = y(c[0] * f);\n      c[1] = y(c[1] * f);\n      this.stackedYData[m] = c[1];\n    };\n\n    v.prototype.getStackIndicator = function (c, f, m, p) {\n      !H(c) || c.x !== f || p && c.key !== p ? c = {\n        x: f,\n        index: 0,\n        key: p\n      } : c.index++;\n      c.key = [m, f, c.index].join();\n      return c;\n    };\n  });\n  K(C, \"parts/Dynamics.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var H = f.defined,\n        D = f.erase,\n        A = f.extend,\n        E = f.isArray,\n        p = f.isNumber,\n        y = f.isObject,\n        G = f.isString,\n        v = f.objectEach,\n        q = f.pick,\n        k = f.setAnimation,\n        m = f.splat,\n        w = c.addEvent,\n        g = c.animate,\n        e = c.Axis;\n    f = c.Chart;\n    var b = c.createElement,\n        d = c.css,\n        a = c.fireEvent,\n        h = c.merge,\n        n = c.Point,\n        F = c.Series,\n        r = c.seriesTypes;\n\n    c.cleanRecursively = function (a, b) {\n      var d = {};\n      v(a, function (e, h) {\n        if (y(a[h], !0) && !a.nodeType && b[h]) e = c.cleanRecursively(a[h], b[h]), Object.keys(e).length && (d[h] = e);else if (y(a[h]) || a[h] !== b[h]) d[h] = a[h];\n      });\n      return d;\n    };\n\n    A(f.prototype, {\n      addSeries: function addSeries(b, d, e) {\n        var c,\n            h = this;\n        b && (d = q(d, !0), a(h, \"addSeries\", {\n          options: b\n        }, function () {\n          c = h.initSeries(b);\n          h.isDirtyLegend = !0;\n          h.linkSeries();\n          a(h, \"afterAddSeries\", {\n            series: c\n          });\n          d && h.redraw(e);\n        }));\n        return c;\n      },\n      addAxis: function addAxis(a, b, d, e) {\n        return this.createAxis(b ? \"xAxis\" : \"yAxis\", {\n          axis: a,\n          redraw: d,\n          animation: e\n        });\n      },\n      addColorAxis: function addColorAxis(a, b, d) {\n        return this.createAxis(\"colorAxis\", {\n          axis: a,\n          redraw: b,\n          animation: d\n        });\n      },\n      createAxis: function createAxis(a, b) {\n        var d = this.options,\n            f = \"colorAxis\" === a,\n            g = b.redraw,\n            l = b.animation;\n        b = h(b.axis, {\n          index: this[a].length,\n          isX: \"xAxis\" === a\n        });\n        var k = f ? new c.ColorAxis(this, b) : new e(this, b);\n        d[a] = m(d[a] || {});\n        d[a].push(b);\n        f && (this.isDirtyLegend = !0, this.axes.forEach(function (a) {\n          a.series = [];\n        }), this.series.forEach(function (a) {\n          a.bindAxes();\n          a.isDirtyData = !0;\n        }));\n        q(g, !0) && this.redraw(l);\n        return k;\n      },\n      showLoading: function showLoading(a) {\n        var e = this,\n            c = e.options,\n            h = e.loadingDiv,\n            f = c.loading,\n            k = function k() {\n          h && d(h, {\n            left: e.plotLeft + \"px\",\n            top: e.plotTop + \"px\",\n            width: e.plotWidth + \"px\",\n            height: e.plotHeight + \"px\"\n          });\n        };\n\n        h || (e.loadingDiv = h = b(\"div\", {\n          className: \"highcharts-loading highcharts-loading-hidden\"\n        }, null, e.container), e.loadingSpan = b(\"span\", {\n          className: \"highcharts-loading-inner\"\n        }, null, h), w(e, \"redraw\", k));\n        h.className = \"highcharts-loading\";\n        e.loadingSpan.innerHTML = q(a, c.lang.loading, \"\");\n        e.styledMode || (d(h, A(f.style, {\n          zIndex: 10\n        })), d(e.loadingSpan, f.labelStyle), e.loadingShown || (d(h, {\n          opacity: 0,\n          display: \"\"\n        }), g(h, {\n          opacity: f.style.opacity || .5\n        }, {\n          duration: f.showDuration || 0\n        })));\n        e.loadingShown = !0;\n        k();\n      },\n      hideLoading: function hideLoading() {\n        var a = this.options,\n            b = this.loadingDiv;\n        b && (b.className = \"highcharts-loading highcharts-loading-hidden\", this.styledMode || g(b, {\n          opacity: 0\n        }, {\n          duration: a.loading.hideDuration || 100,\n          complete: function complete() {\n            d(b, {\n              display: \"none\"\n            });\n          }\n        }));\n        this.loadingShown = !1;\n      },\n      propsRequireDirtyBox: \"backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow\".split(\" \"),\n      propsRequireReflow: \"margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft\".split(\" \"),\n      propsRequireUpdateSeries: \"chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip\".split(\" \"),\n      collectionsWithUpdate: \"xAxis yAxis zAxis colorAxis series pane\".split(\" \"),\n      update: function update(b, d, e, f) {\n        var g = this,\n            l = {\n          credits: \"addCredits\",\n          title: \"setTitle\",\n          subtitle: \"setSubtitle\",\n          caption: \"setCaption\"\n        },\n            k,\n            r,\n            n,\n            t = b.isResponsiveOptions,\n            x = [];\n        a(g, \"update\", {\n          options: b\n        });\n        t || g.setResponsive(!1, !0);\n        b = c.cleanRecursively(b, g.options);\n        h(!0, g.userOptions, b);\n\n        if (k = b.chart) {\n          h(!0, g.options.chart, k);\n          \"className\" in k && g.setClassName(k.className);\n          \"reflow\" in k && g.setReflow(k.reflow);\n\n          if (\"inverted\" in k || \"polar\" in k || \"type\" in k) {\n            g.propFromSeries();\n            var F = !0;\n          }\n\n          \"alignTicks\" in k && (F = !0);\n          v(k, function (a, b) {\n            -1 !== g.propsRequireUpdateSeries.indexOf(\"chart.\" + b) && (r = !0);\n            -1 !== g.propsRequireDirtyBox.indexOf(b) && (g.isDirtyBox = !0);\n            t || -1 === g.propsRequireReflow.indexOf(b) || (n = !0);\n          });\n          !g.styledMode && \"style\" in k && g.renderer.setStyle(k.style);\n        }\n\n        !g.styledMode && b.colors && (this.options.colors = b.colors);\n        b.plotOptions && h(!0, this.options.plotOptions, b.plotOptions);\n        b.time && this.time === c.time && (this.time = new c.Time(b.time));\n        v(b, function (a, b) {\n          if (g[b] && \"function\" === typeof g[b].update) g[b].update(a, !1);else if (\"function\" === typeof g[l[b]]) g[l[b]](a);\n          \"chart\" !== b && -1 !== g.propsRequireUpdateSeries.indexOf(b) && (r = !0);\n        });\n        this.collectionsWithUpdate.forEach(function (a) {\n          if (b[a]) {\n            if (\"series\" === a) {\n              var d = [];\n              g[a].forEach(function (a, b) {\n                a.options.isInternal || d.push(q(a.options.index, b));\n              });\n            }\n\n            m(b[a]).forEach(function (b, c) {\n              (c = H(b.id) && g.get(b.id) || g[a][d ? d[c] : c]) && c.coll === a && (c.update(b, !1), e && (c.touched = !0));\n              !c && e && g.collectionsWithInit[a] && (g.collectionsWithInit[a][0].apply(g, [b].concat(g.collectionsWithInit[a][1] || []).concat([!1])).touched = !0);\n            });\n            e && g[a].forEach(function (a) {\n              a.touched || a.options.isInternal ? delete a.touched : x.push(a);\n            });\n          }\n        });\n        x.forEach(function (a) {\n          a.remove && a.remove(!1);\n        });\n        F && g.axes.forEach(function (a) {\n          a.update({}, !1);\n        });\n        r && g.series.forEach(function (a) {\n          a.update({}, !1);\n        });\n        b.loading && h(!0, g.options.loading, b.loading);\n        F = k && k.width;\n        k = k && k.height;\n        G(k) && (k = c.relativeLength(k, F || g.chartWidth));\n        n || p(F) && F !== g.chartWidth || p(k) && k !== g.chartHeight ? g.setSize(F, k, f) : q(d, !0) && g.redraw(f);\n        a(g, \"afterUpdate\", {\n          options: b,\n          redraw: d,\n          animation: f\n        });\n      },\n      setSubtitle: function setSubtitle(a, b) {\n        this.applyDescription(\"subtitle\", a);\n        this.layOutTitles(b);\n      },\n      setCaption: function setCaption(a, b) {\n        this.applyDescription(\"caption\", a);\n        this.layOutTitles(b);\n      }\n    });\n    f.prototype.collectionsWithInit = {\n      xAxis: [f.prototype.addAxis, [!0]],\n      yAxis: [f.prototype.addAxis, [!1]],\n      colorAxis: [f.prototype.addColorAxis, [!1]],\n      series: [f.prototype.addSeries]\n    };\n    A(n.prototype, {\n      update: function update(a, b, d, e) {\n        function c() {\n          h.applyOptions(a);\n          null === h.y && f && (h.graphic = f.destroy());\n          y(a, !0) && (f && f.element && a && a.marker && void 0 !== a.marker.symbol && (h.graphic = f.destroy()), a && a.dataLabels && h.dataLabel && (h.dataLabel = h.dataLabel.destroy()), h.connector && (h.connector = h.connector.destroy()));\n          l = h.index;\n          g.updateParallelArrays(h, l);\n          r.data[l] = y(r.data[l], !0) || y(a, !0) ? h.options : q(a, r.data[l]);\n          g.isDirty = g.isDirtyData = !0;\n          !g.fixedBox && g.hasCartesianSeries && (k.isDirtyBox = !0);\n          \"point\" === r.legendType && (k.isDirtyLegend = !0);\n          b && k.redraw(d);\n        }\n\n        var h = this,\n            g = h.series,\n            f = h.graphic,\n            l,\n            k = g.chart,\n            r = g.options;\n        b = q(b, !0);\n        !1 === e ? c() : h.firePointEvent(\"update\", {\n          options: a\n        }, c);\n      },\n      remove: function remove(a, b) {\n        this.series.removePoint(this.series.data.indexOf(this), a, b);\n      }\n    });\n    A(F.prototype, {\n      addPoint: function addPoint(b, d, e, c, h) {\n        var g = this.options,\n            f = this.data,\n            l = this.chart,\n            k = this.xAxis;\n        k = k && k.hasNames && k.names;\n        var r = g.data,\n            n = this.xData,\n            t;\n        d = q(d, !0);\n        var x = {\n          series: this\n        };\n        this.pointClass.prototype.applyOptions.apply(x, [b]);\n        var m = x.x;\n        var F = n.length;\n        if (this.requireSorting && m < n[F - 1]) for (t = !0; F && n[F - 1] > m;) {\n          F--;\n        }\n        this.updateParallelArrays(x, \"splice\", F, 0, 0);\n        this.updateParallelArrays(x, F);\n        k && x.name && (k[m] = x.name);\n        r.splice(F, 0, b);\n        t && (this.data.splice(F, 0, null), this.processData());\n        \"point\" === g.legendType && this.generatePoints();\n        e && (f[0] && f[0].remove ? f[0].remove(!1) : (f.shift(), this.updateParallelArrays(x, \"shift\"), r.shift()));\n        !1 !== h && a(this, \"addPoint\", {\n          point: x\n        });\n        this.isDirtyData = this.isDirty = !0;\n        d && l.redraw(c);\n      },\n      removePoint: function removePoint(a, b, d) {\n        var e = this,\n            c = e.data,\n            h = c[a],\n            g = e.points,\n            f = e.chart,\n            l = function l() {\n          g && g.length === c.length && g.splice(a, 1);\n          c.splice(a, 1);\n          e.options.data.splice(a, 1);\n          e.updateParallelArrays(h || {\n            series: e\n          }, \"splice\", a, 1);\n          h && h.destroy();\n          e.isDirty = !0;\n          e.isDirtyData = !0;\n          b && f.redraw();\n        };\n\n        k(d, f);\n        b = q(b, !0);\n        h ? h.firePointEvent(\"remove\", null, l) : l();\n      },\n      remove: function remove(b, d, e, c) {\n        function h() {\n          g.destroy(c);\n          g.remove = null;\n          f.isDirtyLegend = f.isDirtyBox = !0;\n          f.linkSeries();\n          q(b, !0) && f.redraw(d);\n        }\n\n        var g = this,\n            f = g.chart;\n        !1 !== e ? a(g, \"remove\", null, h) : h();\n      },\n      update: function update(b, d) {\n        b = c.cleanRecursively(b, this.userOptions);\n        a(this, \"update\", {\n          options: b\n        });\n        var e = this,\n            g = e.chart,\n            f = e.userOptions,\n            l = e.initialType || e.type,\n            k = b.type || f.type || g.options.chart.type,\n            n = !(this.hasDerivedData || b.dataGrouping || k && k !== this.type || void 0 !== b.pointStart || b.pointInterval || b.pointIntervalUnit || b.keys),\n            m = r[l].prototype,\n            x,\n            F = [\"group\", \"markerGroup\", \"dataLabelsGroup\", \"transformGroup\"],\n            p = [\"eventOptions\", \"navigatorSeries\", \"baseSeries\"],\n            w = e.finishedAnimating && {\n          animation: !1\n        },\n            y = {};\n        n && (p.push(\"data\", \"isDirtyData\", \"points\", \"processedXData\", \"processedYData\", \"xIncrement\", \"_hasPointMarkers\", \"_hasPointLabels\", \"mapMap\", \"mapData\", \"minY\", \"maxY\", \"minX\", \"maxX\"), !1 !== b.visible && p.push(\"area\", \"graph\"), e.parallelArrays.forEach(function (a) {\n          p.push(a + \"Data\");\n        }), b.data && this.setData(b.data, !1));\n        b = h(f, w, {\n          index: void 0 === f.index ? e.index : f.index,\n          pointStart: q(f.pointStart, e.xData[0])\n        }, !n && {\n          data: e.options.data\n        }, b);\n        n && b.data && (b.data = e.options.data);\n        p = F.concat(p);\n        p.forEach(function (a) {\n          p[a] = e[a];\n          delete e[a];\n        });\n        e.remove(!1, null, !1, !0);\n\n        for (x in m) {\n          e[x] = void 0;\n        }\n\n        r[k || l] ? A(e, r[k || l].prototype) : c.error(17, !0, g, {\n          missingModuleFor: k || l\n        });\n        p.forEach(function (a) {\n          e[a] = p[a];\n        });\n        e.init(g, b);\n\n        if (n && this.points) {\n          var v = e.options;\n          !1 === v.visible ? (y.graphic = 1, y.dataLabel = 1) : e._hasPointLabels || (k = v.marker, m = v.dataLabels, k && (!1 === k.enabled || \"symbol\" in k) && (y.graphic = 1), m && !1 === m.enabled && (y.dataLabel = 1));\n          this.points.forEach(function (a) {\n            a && a.series && (a.resolveColor(), Object.keys(y).length && a.destroyElements(y), !1 === v.showInLegend && a.legendItem && g.legend.destroyItem(a));\n          }, this);\n        }\n\n        b.zIndex !== f.zIndex && F.forEach(function (a) {\n          e[a] && e[a].attr({\n            zIndex: b.zIndex\n          });\n        });\n        e.initialType = l;\n        g.linkSeries();\n        a(this, \"afterUpdate\");\n        q(d, !0) && g.redraw(n ? void 0 : !1);\n      },\n      setName: function setName(a) {\n        this.name = this.options.name = this.userOptions.name = a;\n        this.chart.isDirtyLegend = !0;\n      }\n    });\n    A(e.prototype, {\n      update: function update(a, b) {\n        var d = this.chart,\n            e = a && a.events || {};\n        a = h(this.userOptions, a);\n        d.options[this.coll].indexOf && (d.options[this.coll][d.options[this.coll].indexOf(this.userOptions)] = a);\n        v(d.options[this.coll].events, function (a, b) {\n          \"undefined\" === typeof e[b] && (e[b] = void 0);\n        });\n        this.destroy(!0);\n        this.init(d, A(a, {\n          events: e\n        }));\n        d.isDirtyBox = !0;\n        q(b, !0) && d.redraw();\n      },\n      remove: function remove(a) {\n        for (var b = this.chart, d = this.coll, e = this.series, c = e.length; c--;) {\n          e[c] && e[c].remove(!1);\n        }\n\n        D(b.axes, this);\n        D(b[d], this);\n        E(b.options[d]) ? b.options[d].splice(this.options.index, 1) : delete b.options[d];\n        b[d].forEach(function (a, b) {\n          a.options.index = a.userOptions.index = b;\n        });\n        this.destroy();\n        b.isDirtyBox = !0;\n        q(a, !0) && b.redraw();\n      },\n      setTitle: function setTitle(a, b) {\n        this.update({\n          title: a\n        }, b);\n      },\n      setCategories: function setCategories(a, b) {\n        this.update({\n          categories: a\n        }, b);\n      }\n    });\n  });\n  K(C, \"parts/AreaSeries.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var H = f.objectEach,\n        D = f.pick,\n        A = c.color,\n        E = c.Series;\n    f = c.seriesType;\n    f(\"area\", \"line\", {\n      softThreshold: !1,\n      threshold: 0\n    }, {\n      singleStacks: !1,\n      getStackPoints: function getStackPoints(c) {\n        var f = [],\n            p = [],\n            v = this.xAxis,\n            q = this.yAxis,\n            k = q.stacks[this.stackKey],\n            m = {},\n            w = this.index,\n            g = q.series,\n            e = g.length,\n            b = D(q.options.reversedStacks, !0) ? 1 : -1,\n            d;\n        c = c || this.points;\n\n        if (this.options.stacking) {\n          for (d = 0; d < c.length; d++) {\n            c[d].leftNull = c[d].rightNull = void 0, m[c[d].x] = c[d];\n          }\n\n          H(k, function (a, b) {\n            null !== a.total && p.push(b);\n          });\n          p.sort(function (a, b) {\n            return a - b;\n          });\n          var a = g.map(function (a) {\n            return a.visible;\n          });\n          p.forEach(function (c, g) {\n            var h = 0,\n                r,\n                n;\n            if (m[c] && !m[c].isNull) f.push(m[c]), [-1, 1].forEach(function (h) {\n              var f = 1 === h ? \"rightNull\" : \"leftNull\",\n                  l = 0,\n                  x = k[p[g + h]];\n              if (x) for (d = w; 0 <= d && d < e;) {\n                r = x.points[d], r || (d === w ? m[c][f] = !0 : a[d] && (n = k[c].points[d]) && (l -= n[1] - n[0])), d += b;\n              }\n              m[c][1 === h ? \"rightCliff\" : \"leftCliff\"] = l;\n            });else {\n              for (d = w; 0 <= d && d < e;) {\n                if (r = k[c].points[d]) {\n                  h = r[1];\n                  break;\n                }\n\n                d += b;\n              }\n\n              h = q.translate(h, 0, 1, 0, 1);\n              f.push({\n                isNull: !0,\n                plotX: v.translate(c, 0, 0, 0, 1),\n                x: c,\n                plotY: h,\n                yBottom: h\n              });\n            }\n          });\n        }\n\n        return f;\n      },\n      getGraphPath: function getGraphPath(c) {\n        var f = E.prototype.getGraphPath,\n            p = this.options,\n            v = p.stacking,\n            q = this.yAxis,\n            k,\n            m = [],\n            w = [],\n            g = this.index,\n            e = q.stacks[this.stackKey],\n            b = p.threshold,\n            d = Math.round(q.getThreshold(p.threshold));\n        p = D(p.connectNulls, \"percent\" === v);\n\n        var a = function a(_a, h, f) {\n          var k = c[_a];\n          _a = v && e[k.x].points[g];\n          var l = k[f + \"Null\"] || 0;\n          f = k[f + \"Cliff\"] || 0;\n          k = !0;\n\n          if (f || l) {\n            var r = (l ? _a[0] : _a[1]) + f;\n            var x = _a[0] + f;\n            k = !!l;\n          } else !v && c[h] && c[h].isNull && (r = x = b);\n\n          void 0 !== r && (w.push({\n            plotX: n,\n            plotY: null === r ? d : q.getThreshold(r),\n            isNull: k,\n            isCliff: !0\n          }), m.push({\n            plotX: n,\n            plotY: null === x ? d : q.getThreshold(x),\n            doCurve: !1\n          }));\n        };\n\n        c = c || this.points;\n        v && (c = this.getStackPoints(c));\n\n        for (k = 0; k < c.length; k++) {\n          v || (c[k].leftCliff = c[k].rightCliff = c[k].leftNull = c[k].rightNull = void 0);\n          var h = c[k].isNull;\n          var n = D(c[k].rectPlotX, c[k].plotX);\n          var F = D(c[k].yBottom, d);\n          if (!h || p) p || a(k, k - 1, \"left\"), h && !v && p || (w.push(c[k]), m.push({\n            x: k,\n            plotX: n,\n            plotY: F\n          })), p || a(k, k + 1, \"right\");\n        }\n\n        k = f.call(this, w, !0, !0);\n        m.reversed = !0;\n        h = f.call(this, m, !0, !0);\n        h.length && (h[0] = \"L\");\n        h = k.concat(h);\n        f = f.call(this, w, !1, p);\n        h.xMap = k.xMap;\n        this.areaPath = h;\n        return f;\n      },\n      drawGraph: function drawGraph() {\n        this.areaPath = [];\n        E.prototype.drawGraph.apply(this);\n        var c = this,\n            f = this.areaPath,\n            G = this.options,\n            v = [[\"area\", \"highcharts-area\", this.color, G.fillColor]];\n        this.zones.forEach(function (f, k) {\n          v.push([\"zone-area-\" + k, \"highcharts-area highcharts-zone-area-\" + k + \" \" + f.className, f.color || c.color, f.fillColor || G.fillColor]);\n        });\n        v.forEach(function (q) {\n          var k = q[0],\n              m = c[k],\n              p = m ? \"animate\" : \"attr\",\n              g = {};\n          m ? (m.endX = c.preventGraphAnimation ? null : f.xMap, m.animate({\n            d: f\n          })) : (g.zIndex = 0, m = c[k] = c.chart.renderer.path(f).addClass(q[1]).add(c.group), m.isArea = !0);\n          c.chart.styledMode || (g.fill = D(q[3], A(q[2]).setOpacity(D(G.fillOpacity, .75)).get()));\n          m[p](g);\n          m.startX = f.xMap;\n          m.shiftUnit = G.step ? 2 : 1;\n        });\n      },\n      drawLegendSymbol: c.LegendSymbolMixin.drawRectangle\n    });\n    \"\";\n  });\n  K(C, \"parts/SplineSeries.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var H = f.pick;\n    c = c.seriesType;\n    c(\"spline\", \"line\", {}, {\n      getPointSpline: function getPointSpline(c, f, E) {\n        var p = f.plotX,\n            y = f.plotY,\n            A = c[E - 1];\n        E = c[E + 1];\n\n        if (A && !A.isNull && !1 !== A.doCurve && !f.isCliff && E && !E.isNull && !1 !== E.doCurve && !f.isCliff) {\n          c = A.plotY;\n          var v = E.plotX;\n          E = E.plotY;\n          var q = 0;\n          var k = (1.5 * p + A.plotX) / 2.5;\n          var m = (1.5 * y + c) / 2.5;\n          v = (1.5 * p + v) / 2.5;\n          var w = (1.5 * y + E) / 2.5;\n          v !== k && (q = (w - m) * (v - p) / (v - k) + y - w);\n          m += q;\n          w += q;\n          m > c && m > y ? (m = Math.max(c, y), w = 2 * y - m) : m < c && m < y && (m = Math.min(c, y), w = 2 * y - m);\n          w > E && w > y ? (w = Math.max(E, y), m = 2 * y - w) : w < E && w < y && (w = Math.min(E, y), m = 2 * y - w);\n          f.rightContX = v;\n          f.rightContY = w;\n        }\n\n        f = [\"C\", H(A.rightContX, A.plotX), H(A.rightContY, A.plotY), H(k, p), H(m, y), p, y];\n        A.rightContX = A.rightContY = null;\n        return f;\n      }\n    });\n    \"\";\n  });\n  K(C, \"parts/AreaSplineSeries.js\", [C[\"parts/Globals.js\"]], function (c) {\n    var f = c.seriesTypes.area.prototype,\n        H = c.seriesType;\n    H(\"areaspline\", \"spline\", c.defaultPlotOptions.area, {\n      getStackPoints: f.getStackPoints,\n      getGraphPath: f.getGraphPath,\n      drawGraph: f.drawGraph,\n      drawLegendSymbol: c.LegendSymbolMixin.drawRectangle\n    });\n    \"\";\n  });\n  K(C, \"parts/ColumnSeries.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var H = f.defined,\n        D = f.extend,\n        A = f.isNumber,\n        E = f.pick,\n        p = c.animObject,\n        y = c.color,\n        G = c.merge,\n        v = c.Series;\n    f = c.seriesType;\n    var q = c.svg;\n    f(\"column\", \"line\", {\n      borderRadius: 0,\n      crisp: !0,\n      groupPadding: .2,\n      marker: null,\n      pointPadding: .1,\n      minPointLength: 0,\n      cropThreshold: 50,\n      pointRange: null,\n      states: {\n        hover: {\n          halo: !1,\n          brightness: .1\n        },\n        select: {\n          color: \"#cccccc\",\n          borderColor: \"#000000\"\n        }\n      },\n      dataLabels: {\n        align: null,\n        verticalAlign: null,\n        y: null\n      },\n      softThreshold: !1,\n      startFromThreshold: !0,\n      stickyTracking: !1,\n      tooltip: {\n        distance: 6\n      },\n      threshold: 0,\n      borderColor: \"#ffffff\"\n    }, {\n      cropShoulder: 0,\n      directTouch: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      negStacks: !0,\n      init: function init() {\n        v.prototype.init.apply(this, arguments);\n        var c = this,\n            f = c.chart;\n        f.hasRendered && f.series.forEach(function (f) {\n          f.type === c.type && (f.isDirty = !0);\n        });\n      },\n      getColumnMetrics: function getColumnMetrics() {\n        var c = this,\n            f = c.options,\n            q = c.xAxis,\n            g = c.yAxis,\n            e = q.options.reversedStacks;\n        e = q.reversed && !e || !q.reversed && e;\n        var b,\n            d = {},\n            a = 0;\n        !1 === f.grouping ? a = 1 : c.chart.series.forEach(function (e) {\n          var h = e.yAxis,\n              f = e.options;\n\n          if (e.type === c.type && (e.visible || !c.chart.options.chart.ignoreHiddenSeries) && g.len === h.len && g.pos === h.pos) {\n            if (f.stacking) {\n              b = e.stackKey;\n              void 0 === d[b] && (d[b] = a++);\n              var k = d[b];\n            } else !1 !== f.grouping && (k = a++);\n\n            e.columnIndex = k;\n          }\n        });\n        var h = Math.min(Math.abs(q.transA) * (q.ordinalSlope || f.pointRange || q.closestPointRange || q.tickInterval || 1), q.len),\n            n = h * f.groupPadding,\n            F = (h - 2 * n) / (a || 1);\n        f = Math.min(f.maxPointWidth || q.len, E(f.pointWidth, F * (1 - 2 * f.pointPadding)));\n        c.columnMetrics = {\n          width: f,\n          offset: (F - f) / 2 + (n + ((c.columnIndex || 0) + (e ? 1 : 0)) * F - h / 2) * (e ? -1 : 1)\n        };\n        return c.columnMetrics;\n      },\n      crispCol: function crispCol(c, f, q, g) {\n        var e = this.chart,\n            b = this.borderWidth,\n            d = -(b % 2 ? .5 : 0);\n        b = b % 2 ? .5 : 1;\n        e.inverted && e.renderer.isVML && (b += 1);\n        this.options.crisp && (q = Math.round(c + q) + d, c = Math.round(c) + d, q -= c);\n        g = Math.round(f + g) + b;\n        d = .5 >= Math.abs(f) && .5 < g;\n        f = Math.round(f) + b;\n        g -= f;\n        d && g && (--f, g += 1);\n        return {\n          x: c,\n          y: f,\n          width: q,\n          height: g\n        };\n      },\n      translate: function translate() {\n        var c = this,\n            f = c.chart,\n            q = c.options,\n            g = c.dense = 2 > c.closestPointRange * c.xAxis.transA;\n        g = c.borderWidth = E(q.borderWidth, g ? 0 : 1);\n        var e = c.yAxis,\n            b = q.threshold,\n            d = c.translatedThreshold = e.getThreshold(b),\n            a = E(q.minPointLength, 5),\n            h = c.getColumnMetrics(),\n            n = h.width,\n            F = c.barW = Math.max(n, 1 + 2 * g),\n            r = c.pointXOffset = h.offset,\n            x = c.dataMin,\n            l = c.dataMax;\n        f.inverted && (d -= .5);\n        q.pointPadding && (F = Math.ceil(F));\n        v.prototype.translate.apply(c);\n        c.points.forEach(function (h) {\n          var g = E(h.yBottom, d),\n              k = 999 + Math.abs(g),\n              t = n;\n          k = Math.min(Math.max(-k, h.plotY), e.len + k);\n          var m = h.plotX + r,\n              q = F,\n              p = Math.min(k, g),\n              w = Math.max(k, g) - p;\n\n          if (a && Math.abs(w) < a) {\n            w = a;\n            var v = !e.reversed && !h.negative || e.reversed && h.negative;\n            h.y === b && c.dataMax <= b && e.min < b && x !== l && (v = !v);\n            p = Math.abs(p - d) > a ? g - a : d - (v ? a : 0);\n          }\n\n          H(h.options.pointWidth) && (t = q = Math.ceil(h.options.pointWidth), m -= Math.round((t - n) / 2));\n          h.barX = m;\n          h.pointWidth = t;\n          h.tooltipPos = f.inverted ? [e.len + e.pos - f.plotLeft - k, c.xAxis.len - m - q / 2, w] : [m + q / 2, k + e.pos - f.plotTop, w];\n          h.shapeType = c.pointClass.prototype.shapeType || \"rect\";\n          h.shapeArgs = c.crispCol.apply(c, h.isNull ? [m, d, q, 0] : [m, p, q, w]);\n        });\n      },\n      getSymbol: c.noop,\n      drawLegendSymbol: c.LegendSymbolMixin.drawRectangle,\n      drawGraph: function drawGraph() {\n        this.group[this.dense ? \"addClass\" : \"removeClass\"](\"highcharts-dense-data\");\n      },\n      pointAttribs: function pointAttribs(c, f) {\n        var k = this.options,\n            g = this.pointAttrToOptions || {};\n        var e = g.stroke || \"borderColor\";\n        var b = g[\"stroke-width\"] || \"borderWidth\",\n            d = c && c.color || this.color,\n            a = c && c[e] || k[e] || this.color || d,\n            h = c && c[b] || k[b] || this[b] || 0;\n        g = c && c.options.dashStyle || k.dashStyle;\n        var n = E(k.opacity, 1);\n\n        if (c && this.zones.length) {\n          var m = c.getZone();\n          d = c.options.color || m && (m.color || c.nonZonedColor) || this.color;\n          m && (a = m.borderColor || a, g = m.dashStyle || g, h = m.borderWidth || h);\n        }\n\n        f && (c = G(k.states[f], c.options.states && c.options.states[f] || {}), f = c.brightness, d = c.color || void 0 !== f && y(d).brighten(c.brightness).get() || d, a = c[e] || a, h = c[b] || h, g = c.dashStyle || g, n = E(c.opacity, n));\n        e = {\n          fill: d,\n          stroke: a,\n          \"stroke-width\": h,\n          opacity: n\n        };\n        g && (e.dashstyle = g);\n        return e;\n      },\n      drawPoints: function drawPoints() {\n        var c = this,\n            f = this.chart,\n            q = c.options,\n            g = f.renderer,\n            e = q.animationLimit || 250,\n            b;\n        c.points.forEach(function (d) {\n          var a = d.graphic,\n              h = a && f.pointCount < e ? \"animate\" : \"attr\";\n\n          if (A(d.plotY) && null !== d.y) {\n            b = d.shapeArgs;\n            a && d.hasNewShapeType() && (a = a.destroy());\n            if (a) a[h](G(b));else d.graphic = a = g[d.shapeType](b).add(d.group || c.group);\n            if (q.borderRadius) a[h]({\n              r: q.borderRadius\n            });\n            f.styledMode || a[h](c.pointAttribs(d, d.selected && \"select\")).shadow(!1 !== d.allowShadow && q.shadow, null, q.stacking && !q.borderRadius);\n            a.addClass(d.getClassName(), !0);\n          } else a && (d.graphic = a.destroy());\n        });\n      },\n      animate: function animate(c) {\n        var f = this,\n            k = this.yAxis,\n            g = f.options,\n            e = this.chart.inverted,\n            b = {},\n            d = e ? \"translateX\" : \"translateY\";\n        if (q) if (c) b.scaleY = .001, c = Math.min(k.pos + k.len, Math.max(k.pos, k.toPixels(g.threshold))), e ? b.translateX = c - k.len : b.translateY = c, f.clipBox && f.setClip(), f.group.attr(b);else {\n          var a = f.group.attr(d);\n          f.group.animate({\n            scaleY: 1\n          }, D(p(f.options.animation), {\n            step: function step(e, c) {\n              b[d] = a + c.pos * (k.pos - a);\n              f.group.attr(b);\n            }\n          }));\n          f.animate = null;\n        }\n      },\n      remove: function remove() {\n        var c = this,\n            f = c.chart;\n        f.hasRendered && f.series.forEach(function (f) {\n          f.type === c.type && (f.isDirty = !0);\n        });\n        v.prototype.remove.apply(c, arguments);\n      }\n    });\n    \"\";\n  });\n  K(C, \"parts/BarSeries.js\", [C[\"parts/Globals.js\"]], function (c) {\n    c = c.seriesType;\n    c(\"bar\", \"column\", null, {\n      inverted: !0\n    });\n    \"\";\n  });\n  K(C, \"parts/ScatterSeries.js\", [C[\"parts/Globals.js\"]], function (c) {\n    var f = c.Series,\n        H = c.seriesType;\n    H(\"scatter\", \"line\", {\n      lineWidth: 0,\n      findNearestPointBy: \"xy\",\n      jitter: {\n        x: 0,\n        y: 0\n      },\n      marker: {\n        enabled: !0\n      },\n      tooltip: {\n        headerFormat: \"<span style=\\\"color:{point.color}\\\">\\u25CF</span> <span style=\\\"font-size: 10px\\\"> {series.name}</span><br/>\",\n        pointFormat: \"x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>\"\n      }\n    }, {\n      sorted: !1,\n      requireSorting: !1,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n      takeOrdinalPosition: !1,\n      drawGraph: function drawGraph() {\n        this.options.lineWidth && f.prototype.drawGraph.call(this);\n      },\n      applyJitter: function applyJitter() {\n        var c = this,\n            f = this.options.jitter,\n            E = this.points.length;\n        f && this.points.forEach(function (p, y) {\n          [\"x\", \"y\"].forEach(function (A, v) {\n            var q = \"plot\" + A.toUpperCase();\n\n            if (f[A] && !p.isNull) {\n              var k = c[A + \"Axis\"];\n              var m = f[A] * k.transA;\n\n              if (k && !k.isLog) {\n                var w = Math.max(0, p[q] - m);\n                k = Math.min(k.len, p[q] + m);\n                v = 1E4 * Math.sin(y + v * E);\n                p[q] = w + (k - w) * (v - Math.floor(v));\n                \"x\" === A && (p.clientX = p.plotX);\n              }\n            }\n          });\n        });\n      }\n    });\n    c.addEvent(f, \"afterTranslate\", function () {\n      this.applyJitter && this.applyJitter();\n    });\n    \"\";\n  });\n  K(C, \"mixins/centered-series.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var H = f.isNumber,\n        D = f.pick,\n        A = c.deg2rad,\n        E = c.relativeLength;\n    c.CenteredSeriesMixin = {\n      getCenter: function getCenter() {\n        var c = this.options,\n            f = this.chart,\n            A = 2 * (c.slicedOffset || 0),\n            v = f.plotWidth - 2 * A;\n        f = f.plotHeight - 2 * A;\n        var q = c.center;\n        q = [D(q[0], \"50%\"), D(q[1], \"50%\"), c.size || \"100%\", c.innerSize || 0];\n        var k = Math.min(v, f),\n            m;\n\n        for (m = 0; 4 > m; ++m) {\n          var w = q[m];\n          c = 2 > m || 2 === m && /%$/.test(w);\n          q[m] = E(w, [v, f, k, q[2]][m]) + (c ? A : 0);\n        }\n\n        q[3] > q[2] && (q[3] = q[2]);\n        return q;\n      },\n      getStartAndEndRadians: function getStartAndEndRadians(c, f) {\n        c = H(c) ? c : 0;\n        f = H(f) && f > c && 360 > f - c ? f : c + 360;\n        return {\n          start: A * (c + -90),\n          end: A * (f + -90)\n        };\n      }\n    };\n  });\n  K(C, \"parts/PieSeries.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var H = f.defined,\n        D = f.isNumber,\n        A = f.pick,\n        E = f.setAnimation,\n        p = c.addEvent;\n    f = c.CenteredSeriesMixin;\n    var y = f.getStartAndEndRadians,\n        G = c.merge,\n        v = c.noop,\n        q = c.Point,\n        k = c.Series,\n        m = c.seriesType,\n        w = c.fireEvent;\n    m(\"pie\", \"line\", {\n      center: [null, null],\n      clip: !1,\n      colorByPoint: !0,\n      dataLabels: {\n        allowOverlap: !0,\n        connectorPadding: 5,\n        distance: 30,\n        enabled: !0,\n        formatter: function formatter() {\n          return this.point.isNull ? void 0 : this.point.name;\n        },\n        softConnector: !0,\n        x: 0,\n        connectorShape: \"fixedOffset\",\n        crookDistance: \"70%\"\n      },\n      fillColor: void 0,\n      ignoreHiddenPoint: !0,\n      inactiveOtherPoints: !0,\n      legendType: \"point\",\n      marker: null,\n      size: null,\n      showInLegend: !1,\n      slicedOffset: 10,\n      stickyTracking: !1,\n      tooltip: {\n        followPointer: !0\n      },\n      borderColor: \"#ffffff\",\n      borderWidth: 1,\n      lineWidth: void 0,\n      states: {\n        hover: {\n          brightness: .1\n        }\n      }\n    }, {\n      isCartesian: !1,\n      requireSorting: !1,\n      directTouch: !0,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      axisTypes: [],\n      pointAttribs: c.seriesTypes.column.prototype.pointAttribs,\n      animate: function animate(c) {\n        var e = this,\n            b = e.points,\n            d = e.startAngleRad;\n        c || (b.forEach(function (a) {\n          var b = a.graphic,\n              c = a.shapeArgs;\n          b && (b.attr({\n            r: a.startR || e.center[3] / 2,\n            start: d,\n            end: d\n          }), b.animate({\n            r: c.r,\n            start: c.start,\n            end: c.end\n          }, e.options.animation));\n        }), e.animate = null);\n      },\n      hasData: function hasData() {\n        return !!this.processedXData.length;\n      },\n      updateTotals: function updateTotals() {\n        var c,\n            e = 0,\n            b = this.points,\n            d = b.length,\n            a = this.options.ignoreHiddenPoint;\n\n        for (c = 0; c < d; c++) {\n          var h = b[c];\n          e += a && !h.visible ? 0 : h.isNull ? 0 : h.y;\n        }\n\n        this.total = e;\n\n        for (c = 0; c < d; c++) {\n          h = b[c], h.percentage = 0 < e && (h.visible || !a) ? h.y / e * 100 : 0, h.total = e;\n        }\n      },\n      generatePoints: function generatePoints() {\n        k.prototype.generatePoints.call(this);\n        this.updateTotals();\n      },\n      getX: function getX(c, e, b) {\n        var d = this.center,\n            a = this.radii ? this.radii[b.index] : d[2] / 2;\n        return d[0] + (e ? -1 : 1) * Math.cos(Math.asin(Math.max(Math.min((c - d[1]) / (a + b.labelDistance), 1), -1))) * (a + b.labelDistance) + (0 < b.labelDistance ? (e ? -1 : 1) * this.options.dataLabels.padding : 0);\n      },\n      translate: function translate(f) {\n        this.generatePoints();\n        var e = 0,\n            b = this.options,\n            d = b.slicedOffset,\n            a = d + (b.borderWidth || 0),\n            h = y(b.startAngle, b.endAngle),\n            g = this.startAngleRad = h.start;\n        h = (this.endAngleRad = h.end) - g;\n        var k = this.points,\n            r = b.dataLabels.distance;\n        b = b.ignoreHiddenPoint;\n        var m,\n            l = k.length;\n        f || (this.center = f = this.getCenter());\n\n        for (m = 0; m < l; m++) {\n          var t = k[m];\n          var q = g + e * h;\n          if (!b || t.visible) e += t.percentage / 100;\n          var p = g + e * h;\n          t.shapeType = \"arc\";\n          t.shapeArgs = {\n            x: f[0],\n            y: f[1],\n            r: f[2] / 2,\n            innerR: f[3] / 2,\n            start: Math.round(1E3 * q) / 1E3,\n            end: Math.round(1E3 * p) / 1E3\n          };\n          t.labelDistance = A(t.options.dataLabels && t.options.dataLabels.distance, r);\n          t.labelDistance = c.relativeLength(t.labelDistance, t.shapeArgs.r);\n          this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, t.labelDistance);\n          p = (p + q) / 2;\n          p > 1.5 * Math.PI ? p -= 2 * Math.PI : p < -Math.PI / 2 && (p += 2 * Math.PI);\n          t.slicedTranslation = {\n            translateX: Math.round(Math.cos(p) * d),\n            translateY: Math.round(Math.sin(p) * d)\n          };\n          var z = Math.cos(p) * f[2] / 2;\n          var u = Math.sin(p) * f[2] / 2;\n          t.tooltipPos = [f[0] + .7 * z, f[1] + .7 * u];\n          t.half = p < -Math.PI / 2 || p > Math.PI / 2 ? 1 : 0;\n          t.angle = p;\n          q = Math.min(a, t.labelDistance / 5);\n          t.labelPosition = {\n            natural: {\n              x: f[0] + z + Math.cos(p) * t.labelDistance,\n              y: f[1] + u + Math.sin(p) * t.labelDistance\n            },\n            \"final\": {},\n            alignment: 0 > t.labelDistance ? \"center\" : t.half ? \"right\" : \"left\",\n            connectorPosition: {\n              breakAt: {\n                x: f[0] + z + Math.cos(p) * q,\n                y: f[1] + u + Math.sin(p) * q\n              },\n              touchingSliceAt: {\n                x: f[0] + z,\n                y: f[1] + u\n              }\n            }\n          };\n        }\n\n        w(this, \"afterTranslate\");\n      },\n      drawEmpty: function drawEmpty() {\n        var c = this.options;\n\n        if (0 === this.total) {\n          var e = this.center[0];\n          var b = this.center[1];\n          this.graph || (this.graph = this.chart.renderer.circle(e, b, 0).addClass(\"highcharts-graph\").add(this.group));\n          this.graph.animate({\n            \"stroke-width\": c.borderWidth,\n            cx: e,\n            cy: b,\n            r: this.center[2] / 2,\n            fill: c.fillColor || \"none\",\n            stroke: c.color || \"#cccccc\"\n          });\n        } else this.graph && (this.graph = this.graph.destroy());\n      },\n      redrawPoints: function redrawPoints() {\n        var c = this,\n            e = c.chart,\n            b = e.renderer,\n            d,\n            a,\n            h,\n            f,\n            k = c.options.shadow;\n        this.drawEmpty();\n        !k || c.shadowGroup || e.styledMode || (c.shadowGroup = b.g(\"shadow\").attr({\n          zIndex: -1\n        }).add(c.group));\n        c.points.forEach(function (g) {\n          var r = {};\n          a = g.graphic;\n\n          if (!g.isNull && a) {\n            f = g.shapeArgs;\n            d = g.getTranslate();\n\n            if (!e.styledMode) {\n              var l = g.shadowGroup;\n              k && !l && (l = g.shadowGroup = b.g(\"shadow\").add(c.shadowGroup));\n              l && l.attr(d);\n              h = c.pointAttribs(g, g.selected && \"select\");\n            }\n\n            g.delayedRendering ? (a.setRadialReference(c.center).attr(f).attr(d), e.styledMode || a.attr(h).attr({\n              \"stroke-linejoin\": \"round\"\n            }).shadow(k, l), g.delayedRendering = !1) : (a.setRadialReference(c.center), e.styledMode || G(!0, r, h), G(!0, r, f, d), a.animate(r));\n            a.attr({\n              visibility: g.visible ? \"inherit\" : \"hidden\"\n            });\n            a.addClass(g.getClassName());\n          } else a && (g.graphic = a.destroy());\n        });\n      },\n      drawPoints: function drawPoints() {\n        var c = this.chart.renderer;\n        this.points.forEach(function (e) {\n          e.graphic || (e.graphic = c[e.shapeType](e.shapeArgs).add(e.series.group), e.delayedRendering = !0);\n        });\n      },\n      searchPoint: v,\n      sortByAngle: function sortByAngle(c, e) {\n        c.sort(function (b, d) {\n          return void 0 !== b.angle && (d.angle - b.angle) * e;\n        });\n      },\n      drawLegendSymbol: c.LegendSymbolMixin.drawRectangle,\n      getCenter: f.getCenter,\n      getSymbol: v,\n      drawGraph: null\n    }, {\n      init: function init() {\n        q.prototype.init.apply(this, arguments);\n        var c = this;\n        c.name = A(c.name, \"Slice\");\n\n        var e = function e(b) {\n          c.slice(\"select\" === b.type);\n        };\n\n        p(c, \"select\", e);\n        p(c, \"unselect\", e);\n        return c;\n      },\n      isValid: function isValid() {\n        return D(this.y) && 0 <= this.y;\n      },\n      setVisible: function setVisible(c, e) {\n        var b = this,\n            d = b.series,\n            a = d.chart,\n            h = d.options.ignoreHiddenPoint;\n        e = A(e, h);\n        c !== b.visible && (b.visible = b.options.visible = c = void 0 === c ? !b.visible : c, d.options.data[d.data.indexOf(b)] = b.options, [\"graphic\", \"dataLabel\", \"connector\", \"shadowGroup\"].forEach(function (a) {\n          if (b[a]) b[a][c ? \"show\" : \"hide\"](!0);\n        }), b.legendItem && a.legend.colorizeItem(b, c), c || \"hover\" !== b.state || b.setState(\"\"), h && (d.isDirty = !0), e && a.redraw());\n      },\n      slice: function slice(c, e, b) {\n        var d = this.series;\n        E(b, d.chart);\n        A(e, !0);\n        this.sliced = this.options.sliced = H(c) ? c : !this.sliced;\n        d.options.data[d.data.indexOf(this)] = this.options;\n        this.graphic.animate(this.getTranslate());\n        this.shadowGroup && this.shadowGroup.animate(this.getTranslate());\n      },\n      getTranslate: function getTranslate() {\n        return this.sliced ? this.slicedTranslation : {\n          translateX: 0,\n          translateY: 0\n        };\n      },\n      haloPath: function haloPath(c) {\n        var e = this.shapeArgs;\n        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(e.x, e.y, e.r + c, e.r + c, {\n          innerR: e.r - 1,\n          start: e.start,\n          end: e.end\n        });\n      },\n      connectorShapes: {\n        fixedOffset: function fixedOffset(c, e, b) {\n          var d = e.breakAt;\n          e = e.touchingSliceAt;\n          return [\"M\", c.x, c.y].concat(b.softConnector ? [\"C\", c.x + (\"left\" === c.alignment ? -5 : 5), c.y, 2 * d.x - e.x, 2 * d.y - e.y, d.x, d.y] : [\"L\", d.x, d.y]).concat([\"L\", e.x, e.y]);\n        },\n        straight: function straight(c, e) {\n          e = e.touchingSliceAt;\n          return [\"M\", c.x, c.y, \"L\", e.x, e.y];\n        },\n        crookedLine: function crookedLine(f, e, b) {\n          e = e.touchingSliceAt;\n          var d = this.series,\n              a = d.center[0],\n              h = d.chart.plotWidth,\n              g = d.chart.plotLeft;\n          d = f.alignment;\n          var k = this.shapeArgs.r;\n          b = c.relativeLength(b.crookDistance, 1);\n          b = \"left\" === d ? a + k + (h + g - a - k) * (1 - b) : g + (a - k) * b;\n          a = [\"L\", b, f.y];\n          if (\"left\" === d ? b > f.x || b < e.x : b < f.x || b > e.x) a = [];\n          return [\"M\", f.x, f.y].concat(a).concat([\"L\", e.x, e.y]);\n        }\n      },\n      getConnectorPath: function getConnectorPath() {\n        var c = this.labelPosition,\n            e = this.series.options.dataLabels,\n            b = e.connectorShape,\n            d = this.connectorShapes;\n        d[b] && (b = d[b]);\n        return b.call(this, {\n          x: c.final.x,\n          y: c.final.y,\n          alignment: c.alignment\n        }, c.connectorPosition, e);\n      }\n    });\n    \"\";\n  });\n  K(C, \"parts/DataLabels.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var H = f.arrayMax,\n        D = f.defined,\n        A = f.extend,\n        E = f.isArray,\n        p = f.objectEach,\n        y = f.pick,\n        G = f.splat,\n        v = c.format,\n        q = c.merge;\n    f = c.noop;\n    var k = c.relativeLength,\n        m = c.Series,\n        w = c.seriesTypes,\n        g = c.stableSort;\n\n    c.distribute = function (e, b, d) {\n      function a(a, b) {\n        return a.target - b.target;\n      }\n\n      var h,\n          f = !0,\n          k = e,\n          r = [];\n      var m = 0;\n      var l = k.reducedLen || b;\n\n      for (h = e.length; h--;) {\n        m += e[h].size;\n      }\n\n      if (m > l) {\n        g(e, function (a, b) {\n          return (b.rank || 0) - (a.rank || 0);\n        });\n\n        for (m = h = 0; m <= l;) {\n          m += e[h].size, h++;\n        }\n\n        r = e.splice(h - 1, e.length);\n      }\n\n      g(e, a);\n\n      for (e = e.map(function (a) {\n        return {\n          size: a.size,\n          targets: [a.target],\n          align: y(a.align, .5)\n        };\n      }); f;) {\n        for (h = e.length; h--;) {\n          f = e[h], m = (Math.min.apply(0, f.targets) + Math.max.apply(0, f.targets)) / 2, f.pos = Math.min(Math.max(0, m - f.size * f.align), b - f.size);\n        }\n\n        h = e.length;\n\n        for (f = !1; h--;) {\n          0 < h && e[h - 1].pos + e[h - 1].size > e[h].pos && (e[h - 1].size += e[h].size, e[h - 1].targets = e[h - 1].targets.concat(e[h].targets), e[h - 1].align = .5, e[h - 1].pos + e[h - 1].size > b && (e[h - 1].pos = b - e[h - 1].size), e.splice(h, 1), f = !0);\n        }\n      }\n\n      k.push.apply(k, r);\n      h = 0;\n      e.some(function (a) {\n        var e = 0;\n        if (a.targets.some(function () {\n          k[h].pos = a.pos + e;\n          if (Math.abs(k[h].pos - k[h].target) > d) return k.slice(0, h + 1).forEach(function (a) {\n            delete a.pos;\n          }), k.reducedLen = (k.reducedLen || b) - .1 * b, k.reducedLen > .1 * b && c.distribute(k, b, d), !0;\n          e += k[h].size;\n          h++;\n        })) return !0;\n      });\n      g(k, a);\n    };\n\n    m.prototype.drawDataLabels = function () {\n      function e(a, b) {\n        var d = b.filter;\n        return d ? (b = d.operator, a = a[d.property], d = d.value, \">\" === b && a > d || \"<\" === b && a < d || \">=\" === b && a >= d || \"<=\" === b && a <= d || \"==\" === b && a == d || \"===\" === b && a === d ? !0 : !1) : !0;\n      }\n\n      function b(a, b) {\n        var d = [],\n            c;\n        if (E(a) && !E(b)) d = a.map(function (a) {\n          return q(a, b);\n        });else if (E(b) && !E(a)) d = b.map(function (b) {\n          return q(a, b);\n        });else if (E(a) || E(b)) for (c = Math.max(a.length, b.length); c--;) {\n          d[c] = q(a[c], b[c]);\n        } else d = q(a, b);\n        return d;\n      }\n\n      var d = this,\n          a = d.chart,\n          f = d.options,\n          g = f.dataLabels,\n          k = d.points,\n          r,\n          m = d.hasRendered || 0,\n          l = c.animObject(f.animation).duration,\n          t = Math.min(l, 200),\n          B = !a.renderer.forExport && y(g.defer, 0 < t),\n          w = a.renderer;\n      g = b(b(a.options.plotOptions && a.options.plotOptions.series && a.options.plotOptions.series.dataLabels, a.options.plotOptions && a.options.plotOptions[d.type] && a.options.plotOptions[d.type].dataLabels), g);\n      c.fireEvent(this, \"drawDataLabels\");\n\n      if (E(g) || g.enabled || d._hasPointLabels) {\n        var z = d.plotGroup(\"dataLabelsGroup\", \"data-labels\", B && !m ? \"hidden\" : \"inherit\", g.zIndex || 6);\n        B && (z.attr({\n          opacity: +m\n        }), m || setTimeout(function () {\n          var a = d.dataLabelsGroup;\n          a && (d.visible && z.show(!0), a[f.animation ? \"animate\" : \"attr\"]({\n            opacity: 1\n          }, {\n            duration: t\n          }));\n        }, l - t));\n        k.forEach(function (c) {\n          r = G(b(g, c.dlOptions || c.options && c.options.dataLabels));\n          r.forEach(function (b, h) {\n            var g = b.enabled && (!c.isNull || c.dataLabelOnNull) && e(c, b),\n                l = c.dataLabels ? c.dataLabels[h] : c.dataLabel,\n                k = c.connectors ? c.connectors[h] : c.connector,\n                r = y(b.distance, c.labelDistance),\n                n = !l;\n\n            if (g) {\n              var t = c.getLabelConfig();\n              var m = y(b[c.formatPrefix + \"Format\"], b.format);\n              t = D(m) ? v(m, t, a.time) : (b[c.formatPrefix + \"Formatter\"] || b.formatter).call(t, b);\n              m = b.style;\n              var q = b.rotation;\n              a.styledMode || (m.color = y(b.color, m.color, d.color, \"#000000\"), \"contrast\" === m.color && (c.contrastColor = w.getContrast(c.color || d.color), m.color = !D(r) && b.inside || 0 > r || f.stacking ? c.contrastColor : \"#000000\"), f.cursor && (m.cursor = f.cursor));\n              var x = {\n                r: b.borderRadius || 0,\n                rotation: q,\n                padding: b.padding,\n                zIndex: 1\n              };\n              a.styledMode || (x.fill = b.backgroundColor, x.stroke = b.borderColor, x[\"stroke-width\"] = b.borderWidth);\n              p(x, function (a, b) {\n                void 0 === a && delete x[b];\n              });\n            }\n\n            !l || g && D(t) ? g && D(t) && (l ? x.text = t : (c.dataLabels = c.dataLabels || [], l = c.dataLabels[h] = q ? w.text(t, 0, -9999).addClass(\"highcharts-data-label\") : w.label(t, 0, -9999, b.shape, null, null, b.useHTML, null, \"data-label\"), h || (c.dataLabel = l), l.addClass(\" highcharts-data-label-color-\" + c.colorIndex + \" \" + (b.className || \"\") + (b.useHTML ? \" highcharts-tracker\" : \"\"))), l.options = b, l.attr(x), a.styledMode || l.css(m).shadow(b.shadow), l.added || l.add(z), b.textPath && !b.useHTML && l.setTextPath(c.getDataLabelPath && c.getDataLabelPath(l) || c.graphic, b.textPath), d.alignDataLabel(c, l, b, null, n)) : (c.dataLabel = c.dataLabel && c.dataLabel.destroy(), c.dataLabels && (1 === c.dataLabels.length ? delete c.dataLabels : delete c.dataLabels[h]), h || delete c.dataLabel, k && (c.connector = c.connector.destroy(), c.connectors && (1 === c.connectors.length ? delete c.connectors : delete c.connectors[h])));\n          });\n        });\n      }\n\n      c.fireEvent(this, \"afterDrawDataLabels\");\n    };\n\n    m.prototype.alignDataLabel = function (c, b, d, a, f) {\n      var e = this.chart,\n          h = this.isCartesian && e.inverted,\n          g = y(c.dlBox && c.dlBox.centerX, c.plotX, -9999),\n          k = y(c.plotY, -9999),\n          l = b.getBBox(),\n          t = d.rotation,\n          m = d.align,\n          q = this.visible && (c.series.forceDL || e.isInsidePlot(g, Math.round(k), h) || a && e.isInsidePlot(g, h ? a.x + 1 : a.y + a.height - 1, h)),\n          p = \"justify\" === y(d.overflow, \"justify\");\n\n      if (q) {\n        var u = e.renderer.fontMetrics(e.styledMode ? void 0 : d.style.fontSize, b).b;\n        a = A({\n          x: h ? this.yAxis.len - k : g,\n          y: Math.round(h ? this.xAxis.len - g : k),\n          width: 0,\n          height: 0\n        }, a);\n        A(d, {\n          width: l.width,\n          height: l.height\n        });\n        t ? (p = !1, g = e.renderer.rotCorr(u, t), g = {\n          x: a.x + d.x + a.width / 2 + g.x,\n          y: a.y + d.y + {\n            top: 0,\n            middle: .5,\n            bottom: 1\n          }[d.verticalAlign] * a.height\n        }, b[f ? \"attr\" : \"animate\"](g).attr({\n          align: m\n        }), k = (t + 720) % 360, k = 180 < k && 360 > k, \"left\" === m ? g.y -= k ? l.height : 0 : \"center\" === m ? (g.x -= l.width / 2, g.y -= l.height / 2) : \"right\" === m && (g.x -= l.width, g.y -= k ? 0 : l.height), b.placed = !0, b.alignAttr = g) : (b.align(d, null, a), g = b.alignAttr);\n        p && 0 <= a.height ? this.justifyDataLabel(b, d, g, l, a, f) : y(d.crop, !0) && (q = e.isInsidePlot(g.x, g.y) && e.isInsidePlot(g.x + l.width, g.y + l.height));\n        if (d.shape && !t) b[f ? \"attr\" : \"animate\"]({\n          anchorX: h ? e.plotWidth - c.plotY : c.plotX,\n          anchorY: h ? e.plotHeight - c.plotX : c.plotY\n        });\n      }\n\n      q || (b.hide(!0), b.placed = !1);\n    };\n\n    m.prototype.justifyDataLabel = function (c, b, d, a, f, g) {\n      var e = this.chart,\n          h = b.align,\n          k = b.verticalAlign,\n          l = c.box ? 0 : c.padding || 0;\n      var n = d.x + l;\n\n      if (0 > n) {\n        \"right\" === h ? (b.align = \"left\", b.inside = !0) : b.x = -n;\n        var m = !0;\n      }\n\n      n = d.x + a.width - l;\n      n > e.plotWidth && (\"left\" === h ? (b.align = \"right\", b.inside = !0) : b.x = e.plotWidth - n, m = !0);\n      n = d.y + l;\n      0 > n && (\"bottom\" === k ? (b.verticalAlign = \"top\", b.inside = !0) : b.y = -n, m = !0);\n      n = d.y + a.height - l;\n      n > e.plotHeight && (\"top\" === k ? (b.verticalAlign = \"bottom\", b.inside = !0) : b.y = e.plotHeight - n, m = !0);\n      m && (c.placed = !g, c.align(b, null, f));\n      return m;\n    };\n\n    w.pie && (w.pie.prototype.dataLabelPositioners = {\n      radialDistributionY: function radialDistributionY(c) {\n        return c.top + c.distributeBox.pos;\n      },\n      radialDistributionX: function radialDistributionX(c, b, d, a) {\n        return c.getX(d < b.top + 2 || d > b.bottom - 2 ? a : d, b.half, b);\n      },\n      justify: function justify(c, b, d) {\n        return d[0] + (c.half ? -1 : 1) * (b + c.labelDistance);\n      },\n      alignToPlotEdges: function alignToPlotEdges(c, b, d, a) {\n        c = c.getBBox().width;\n        return b ? c + a : d - c - a;\n      },\n      alignToConnectors: function alignToConnectors(c, b, d, a) {\n        var e = 0,\n            f;\n        c.forEach(function (a) {\n          f = a.dataLabel.getBBox().width;\n          f > e && (e = f);\n        });\n        return b ? e + a : d - e - a;\n      }\n    }, w.pie.prototype.drawDataLabels = function () {\n      var e = this,\n          b = e.data,\n          d,\n          a = e.chart,\n          f = e.options.dataLabels,\n          g = f.connectorPadding,\n          k,\n          r = a.plotWidth,\n          x = a.plotHeight,\n          l = a.plotLeft,\n          t = Math.round(a.chartWidth / 3),\n          p,\n          w = e.center,\n          z = w[2] / 2,\n          u = w[1],\n          v,\n          A,\n          E,\n          G,\n          C = [[], []],\n          K,\n          J,\n          O,\n          P,\n          S = [0, 0, 0, 0],\n          U = e.dataLabelPositioners,\n          X;\n      e.visible && (f.enabled || e._hasPointLabels) && (b.forEach(function (a) {\n        a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({\n          width: \"auto\"\n        }).css({\n          width: \"auto\",\n          textOverflow: \"clip\"\n        }), a.dataLabel.shortened = !1);\n      }), m.prototype.drawDataLabels.apply(e), b.forEach(function (a) {\n        a.dataLabel && (a.visible ? (C[a.half].push(a), a.dataLabel._pos = null, !D(f.style.width) && !D(a.options.dataLabels && a.options.dataLabels.style && a.options.dataLabels.style.width) && a.dataLabel.getBBox().width > t && (a.dataLabel.css({\n          width: .7 * t\n        }), a.dataLabel.shortened = !0)) : (a.dataLabel = a.dataLabel.destroy(), a.dataLabels && 1 === a.dataLabels.length && delete a.dataLabels));\n      }), C.forEach(function (b, h) {\n        var k = b.length,\n            n = [],\n            t;\n\n        if (k) {\n          e.sortByAngle(b, h - .5);\n\n          if (0 < e.maxLabelDistance) {\n            var m = Math.max(0, u - z - e.maxLabelDistance);\n            var q = Math.min(u + z + e.maxLabelDistance, a.plotHeight);\n            b.forEach(function (b) {\n              0 < b.labelDistance && b.dataLabel && (b.top = Math.max(0, u - z - b.labelDistance), b.bottom = Math.min(u + z + b.labelDistance, a.plotHeight), t = b.dataLabel.getBBox().height || 21, b.distributeBox = {\n                target: b.labelPosition.natural.y - b.top + t / 2,\n                size: t,\n                rank: b.y\n              }, n.push(b.distributeBox));\n            });\n            m = q + t - m;\n            c.distribute(n, m, m / 5);\n          }\n\n          for (P = 0; P < k; P++) {\n            d = b[P];\n            E = d.labelPosition;\n            v = d.dataLabel;\n            O = !1 === d.visible ? \"hidden\" : \"inherit\";\n            J = m = E.natural.y;\n            n && D(d.distributeBox) && (void 0 === d.distributeBox.pos ? O = \"hidden\" : (G = d.distributeBox.size, J = U.radialDistributionY(d)));\n            delete d.positionIndex;\n            if (f.justify) K = U.justify(d, z, w);else switch (f.alignTo) {\n              case \"connectors\":\n                K = U.alignToConnectors(b, h, r, l);\n                break;\n\n              case \"plotEdges\":\n                K = U.alignToPlotEdges(v, h, r, l);\n                break;\n\n              default:\n                K = U.radialDistributionX(e, d, J, m);\n            }\n            v._attr = {\n              visibility: O,\n              align: E.alignment\n            };\n            v._pos = {\n              x: K + f.x + ({\n                left: g,\n                right: -g\n              }[E.alignment] || 0),\n              y: J + f.y - 10\n            };\n            E.final.x = K;\n            E.final.y = J;\n            y(f.crop, !0) && (A = v.getBBox().width, m = null, K - A < g && 1 === h ? (m = Math.round(A - K + g), S[3] = Math.max(m, S[3])) : K + A > r - g && 0 === h && (m = Math.round(K + A - r + g), S[1] = Math.max(m, S[1])), 0 > J - G / 2 ? S[0] = Math.max(Math.round(-J + G / 2), S[0]) : J + G / 2 > x && (S[2] = Math.max(Math.round(J + G / 2 - x), S[2])), v.sideOverflow = m);\n          }\n        }\n      }), 0 === H(S) || this.verifyDataLabelOverflow(S)) && (this.placeDataLabels(), this.points.forEach(function (b) {\n        X = q(f, b.options.dataLabels);\n\n        if (k = y(X.connectorWidth, 1)) {\n          var d;\n          p = b.connector;\n\n          if ((v = b.dataLabel) && v._pos && b.visible && 0 < b.labelDistance) {\n            O = v._attr.visibility;\n            if (d = !p) b.connector = p = a.renderer.path().addClass(\"highcharts-data-label-connector  highcharts-color-\" + b.colorIndex + (b.className ? \" \" + b.className : \"\")).add(e.dataLabelsGroup), a.styledMode || p.attr({\n              \"stroke-width\": k,\n              stroke: X.connectorColor || b.color || \"#666666\"\n            });\n            p[d ? \"attr\" : \"animate\"]({\n              d: b.getConnectorPath()\n            });\n            p.attr(\"visibility\", O);\n          } else p && (b.connector = p.destroy());\n        }\n      }));\n    }, w.pie.prototype.placeDataLabels = function () {\n      this.points.forEach(function (c) {\n        var b = c.dataLabel,\n            d;\n        b && c.visible && ((d = b._pos) ? (b.sideOverflow && (b._attr.width = Math.max(b.getBBox().width - b.sideOverflow, 0), b.css({\n          width: b._attr.width + \"px\",\n          textOverflow: (this.options.dataLabels.style || {}).textOverflow || \"ellipsis\"\n        }), b.shortened = !0), b.attr(b._attr), b[b.moved ? \"animate\" : \"attr\"](d), b.moved = !0) : b && b.attr({\n          y: -9999\n        }));\n        delete c.distributeBox;\n      }, this);\n    }, w.pie.prototype.alignDataLabel = f, w.pie.prototype.verifyDataLabelOverflow = function (c) {\n      var b = this.center,\n          d = this.options,\n          a = d.center,\n          e = d.minSize || 80,\n          f = null !== d.size;\n\n      if (!f) {\n        if (null !== a[0]) var g = Math.max(b[2] - Math.max(c[1], c[3]), e);else g = Math.max(b[2] - c[1] - c[3], e), b[0] += (c[3] - c[1]) / 2;\n        null !== a[1] ? g = Math.max(Math.min(g, b[2] - Math.max(c[0], c[2])), e) : (g = Math.max(Math.min(g, b[2] - c[0] - c[2]), e), b[1] += (c[0] - c[2]) / 2);\n        g < b[2] ? (b[2] = g, b[3] = Math.min(k(d.innerSize || 0, g), g), this.translate(b), this.drawDataLabels && this.drawDataLabels()) : f = !0;\n      }\n\n      return f;\n    });\n    w.column && (w.column.prototype.alignDataLabel = function (c, b, d, a, f) {\n      var e = this.chart.inverted,\n          h = c.series,\n          g = c.dlBox || c.shapeArgs,\n          k = y(c.below, c.plotY > y(this.translatedThreshold, h.yAxis.len)),\n          l = y(d.inside, !!this.options.stacking);\n      g && (a = q(g), 0 > a.y && (a.height += a.y, a.y = 0), g = a.y + a.height - h.yAxis.len, 0 < g && (a.height -= g), e && (a = {\n        x: h.yAxis.len - a.y - a.height,\n        y: h.xAxis.len - a.x - a.width,\n        width: a.height,\n        height: a.width\n      }), l || (e ? (a.x += k ? 0 : a.width, a.width = 0) : (a.y += k ? a.height : 0, a.height = 0)));\n      d.align = y(d.align, !e || l ? \"center\" : k ? \"right\" : \"left\");\n      d.verticalAlign = y(d.verticalAlign, e || l ? \"middle\" : k ? \"top\" : \"bottom\");\n      m.prototype.alignDataLabel.call(this, c, b, d, a, f);\n      d.inside && c.contrastColor && b.css({\n        color: c.contrastColor\n      });\n    });\n  });\n  K(C, \"modules/overlapping-datalabels.src.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var H = f.isArray,\n        D = f.objectEach,\n        A = f.pick;\n    f = c.Chart;\n    var E = c.addEvent,\n        p = c.fireEvent;\n    E(f, \"render\", function () {\n      var c = [];\n      (this.labelCollectors || []).forEach(function (f) {\n        c = c.concat(f());\n      });\n      (this.yAxis || []).forEach(function (f) {\n        f.options.stackLabels && !f.options.stackLabels.allowOverlap && D(f.stacks, function (f) {\n          D(f, function (f) {\n            c.push(f.label);\n          });\n        });\n      });\n      (this.series || []).forEach(function (f) {\n        var p = f.options.dataLabels;\n        f.visible && (!1 !== p.enabled || f._hasPointLabels) && f.points.forEach(function (f) {\n          f.visible && (H(f.dataLabels) ? f.dataLabels : f.dataLabel ? [f.dataLabel] : []).forEach(function (k) {\n            var m = k.options;\n            k.labelrank = A(m.labelrank, f.labelrank, f.shapeArgs && f.shapeArgs.height);\n            m.allowOverlap || c.push(k);\n          });\n        });\n      });\n      this.hideOverlappingLabels(c);\n    });\n\n    f.prototype.hideOverlappingLabels = function (c) {\n      var f = this,\n          v = c.length,\n          q = f.renderer,\n          k,\n          m,\n          w;\n\n      var g = function g(b) {\n        var a = b.box ? 0 : b.padding || 0;\n        var d = 0;\n\n        if (b && (!b.alignAttr || b.placed)) {\n          var c = b.attr(\"x\");\n          var e = b.attr(\"y\");\n          c = \"number\" === typeof c && \"number\" === typeof e ? {\n            x: c,\n            y: e\n          } : b.alignAttr;\n          e = b.parentGroup;\n          b.width || (d = b.getBBox(), b.width = d.width, b.height = d.height, d = q.fontMetrics(null, b.element).h);\n          return {\n            x: c.x + (e.translateX || 0) + a,\n            y: c.y + (e.translateY || 0) + a - d,\n            width: b.width - 2 * a,\n            height: b.height - 2 * a\n          };\n        }\n      };\n\n      for (m = 0; m < v; m++) {\n        if (k = c[m]) k.oldOpacity = k.opacity, k.newOpacity = 1, k.absoluteBox = g(k);\n      }\n\n      c.sort(function (b, a) {\n        return (a.labelrank || 0) - (b.labelrank || 0);\n      });\n\n      for (m = 0; m < v; m++) {\n        var e = (g = c[m]) && g.absoluteBox;\n\n        for (k = m + 1; k < v; ++k) {\n          var b = (w = c[k]) && w.absoluteBox;\n          !e || !b || g === w || 0 === g.newOpacity || 0 === w.newOpacity || b.x > e.x + e.width || b.x + b.width < e.x || b.y > e.y + e.height || b.y + b.height < e.y || ((g.labelrank < w.labelrank ? g : w).newOpacity = 0);\n        }\n      }\n\n      c.forEach(function (b) {\n        var a;\n\n        if (b) {\n          var d = b.newOpacity;\n          b.oldOpacity !== d && (b.alignAttr && b.placed ? (d ? b.show(!0) : a = function a() {\n            b.hide(!0);\n            b.placed = !1;\n          }, b.alignAttr.opacity = d, b[b.isOld ? \"animate\" : \"attr\"](b.alignAttr, null, a), p(f, \"afterHideOverlappingLabels\")) : b.attr({\n            opacity: d\n          }));\n          b.isOld = !0;\n        }\n      });\n    };\n  });\n  K(C, \"parts/Interaction.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var H = f.defined,\n        D = f.extend,\n        A = f.isArray,\n        E = f.isObject,\n        p = f.objectEach,\n        y = f.pick,\n        G = c.addEvent;\n    f = c.Chart;\n    var v = c.createElement,\n        q = c.css,\n        k = c.defaultOptions,\n        m = c.defaultPlotOptions,\n        w = c.fireEvent,\n        g = c.hasTouch,\n        e = c.Legend,\n        b = c.merge,\n        d = c.Point,\n        a = c.Series,\n        h = c.seriesTypes,\n        n = c.svg;\n    var F = c.TrackerMixin = {\n      drawTrackerPoint: function drawTrackerPoint() {\n        var a = this,\n            b = a.chart,\n            d = b.pointer,\n            c = function c(a) {\n          var b = d.getPointFromEvent(a);\n          void 0 !== b && (d.isDirectTouch = !0, b.onMouseOver(a));\n        },\n            e;\n\n        a.points.forEach(function (a) {\n          e = A(a.dataLabels) ? a.dataLabels : a.dataLabel ? [a.dataLabel] : [];\n          a.graphic && (a.graphic.element.point = a);\n          e.forEach(function (b) {\n            b.div ? b.div.point = a : b.element.point = a;\n          });\n        });\n        a._hasTracking || (a.trackerGroups.forEach(function (e) {\n          if (a[e]) {\n            a[e].addClass(\"highcharts-tracker\").on(\"mouseover\", c).on(\"mouseout\", function (a) {\n              d.onTrackerMouseOut(a);\n            });\n            if (g) a[e].on(\"touchstart\", c);\n            !b.styledMode && a.options.cursor && a[e].css(q).css({\n              cursor: a.options.cursor\n            });\n          }\n        }), a._hasTracking = !0);\n        w(this, \"afterDrawTracker\");\n      },\n      drawTrackerGraph: function drawTrackerGraph() {\n        var a = this,\n            b = a.options,\n            d = b.trackByArea,\n            c = [].concat(d ? a.areaPath : a.graphPath),\n            e = c.length,\n            f = a.chart,\n            h = f.pointer,\n            k = f.renderer,\n            m = f.options.tooltip.snap,\n            q = a.tracker,\n            p,\n            v = function v() {\n          if (f.hoverSeries !== a) a.onMouseOver();\n        },\n            F = \"rgba(192,192,192,\" + (n ? .0001 : .002) + \")\";\n\n        if (e && !d) for (p = e + 1; p--;) {\n          \"M\" === c[p] && c.splice(p + 1, 0, c[p + 1] - m, c[p + 2], \"L\"), (p && \"M\" === c[p] || p === e) && c.splice(p, 0, \"L\", c[p - 2] + m, c[p - 1]);\n        }\n        q ? q.attr({\n          d: c\n        }) : a.graph && (a.tracker = k.path(c).attr({\n          visibility: a.visible ? \"visible\" : \"hidden\",\n          zIndex: 2\n        }).addClass(d ? \"highcharts-tracker-area\" : \"highcharts-tracker-line\").add(a.group), f.styledMode || a.tracker.attr({\n          \"stroke-linejoin\": \"round\",\n          stroke: F,\n          fill: d ? F : \"none\",\n          \"stroke-width\": a.graph.strokeWidth() + (d ? 0 : 2 * m)\n        }), [a.tracker, a.markerGroup].forEach(function (a) {\n          a.addClass(\"highcharts-tracker\").on(\"mouseover\", v).on(\"mouseout\", function (a) {\n            h.onTrackerMouseOut(a);\n          });\n          b.cursor && !f.styledMode && a.css({\n            cursor: b.cursor\n          });\n          if (g) a.on(\"touchstart\", v);\n        }));\n        w(this, \"afterDrawTracker\");\n      }\n    };\n    h.column && (h.column.prototype.drawTracker = F.drawTrackerPoint);\n    h.pie && (h.pie.prototype.drawTracker = F.drawTrackerPoint);\n    h.scatter && (h.scatter.prototype.drawTracker = F.drawTrackerPoint);\n    D(e.prototype, {\n      setItemEvents: function setItemEvents(a, c, e) {\n        var f = this,\n            h = f.chart.renderer.boxWrapper,\n            g = a instanceof d,\n            k = \"highcharts-legend-\" + (g ? \"point\" : \"series\") + \"-active\",\n            l = f.chart.styledMode;\n        (e ? c : a.legendGroup).on(\"mouseover\", function () {\n          a.visible && f.allItems.forEach(function (b) {\n            a !== b && b.setState(\"inactive\", !g);\n          });\n          a.setState(\"hover\");\n          a.visible && h.addClass(k);\n          l || c.css(f.options.itemHoverStyle);\n        }).on(\"mouseout\", function () {\n          f.chart.styledMode || c.css(b(a.visible ? f.itemStyle : f.itemHiddenStyle));\n          f.allItems.forEach(function (b) {\n            a !== b && b.setState(\"\", !g);\n          });\n          h.removeClass(k);\n          a.setState();\n        }).on(\"click\", function (b) {\n          var d = function d() {\n            a.setVisible && a.setVisible();\n            f.allItems.forEach(function (b) {\n              a !== b && b.setState(a.visible ? \"inactive\" : \"\", !g);\n            });\n          };\n\n          h.removeClass(k);\n          b = {\n            browserEvent: b\n          };\n          a.firePointEvent ? a.firePointEvent(\"legendItemClick\", b, d) : w(a, \"legendItemClick\", b, d);\n        });\n      },\n      createCheckboxForItem: function createCheckboxForItem(a) {\n        a.checkbox = v(\"input\", {\n          type: \"checkbox\",\n          className: \"highcharts-legend-checkbox\",\n          checked: a.selected,\n          defaultChecked: a.selected\n        }, this.options.itemCheckboxStyle, this.chart.container);\n        G(a.checkbox, \"click\", function (b) {\n          w(a.series || a, \"checkboxClick\", {\n            checked: b.target.checked,\n            item: a\n          }, function () {\n            a.select();\n          });\n        });\n      }\n    });\n    D(f.prototype, {\n      showResetZoom: function showResetZoom() {\n        function a() {\n          b.zoomOut();\n        }\n\n        var b = this,\n            d = k.lang,\n            c = b.options.chart.resetZoomButton,\n            e = c.theme,\n            f = e.states,\n            h = \"chart\" === c.relativeTo || \"spaceBox\" === c.relativeTo ? null : \"plotBox\";\n        w(this, \"beforeShowResetZoom\", null, function () {\n          b.resetZoomButton = b.renderer.button(d.resetZoom, null, null, a, e, f && f.hover).attr({\n            align: c.position.align,\n            title: d.resetZoomTitle\n          }).addClass(\"highcharts-reset-zoom\").add().align(c.position, !1, h);\n        });\n        w(this, \"afterShowResetZoom\");\n      },\n      zoomOut: function zoomOut() {\n        w(this, \"selection\", {\n          resetSelection: !0\n        }, this.zoom);\n      },\n      zoom: function zoom(a) {\n        var b = this,\n            d,\n            c = b.pointer,\n            e = !1,\n            f = b.inverted ? c.mouseDownX : c.mouseDownY;\n        !a || a.resetSelection ? (b.axes.forEach(function (a) {\n          d = a.zoom();\n        }), c.initiated = !1) : a.xAxis.concat(a.yAxis).forEach(function (a) {\n          var h = a.axis,\n              g = b.inverted ? h.left : h.top,\n              k = b.inverted ? g + h.width : g + h.height,\n              l = h.isXAxis,\n              r = !1;\n          if (!l && f >= g && f <= k || l || !H(f)) r = !0;\n          c[l ? \"zoomX\" : \"zoomY\"] && r && (d = h.zoom(a.min, a.max), h.displayBtn && (e = !0));\n        });\n        var h = b.resetZoomButton;\n        e && !h ? b.showResetZoom() : !e && E(h) && (b.resetZoomButton = h.destroy());\n        d && b.redraw(y(b.options.chart.animation, a && a.animation, 100 > b.pointCount));\n      },\n      pan: function pan(a, b) {\n        var d = this,\n            c = d.hoverPoints,\n            e;\n        w(this, \"pan\", {\n          originalEvent: a\n        }, function () {\n          c && c.forEach(function (a) {\n            a.setState();\n          });\n          (\"xy\" === b ? [1, 0] : [1]).forEach(function (b) {\n            b = d[b ? \"xAxis\" : \"yAxis\"][0];\n            var c = b.horiz,\n                f = a[c ? \"chartX\" : \"chartY\"];\n            c = c ? \"mouseDownX\" : \"mouseDownY\";\n            var h = d[c],\n                g = (b.pointRange || 0) / 2,\n                k = b.reversed && !d.inverted || !b.reversed && d.inverted ? -1 : 1,\n                l = b.getExtremes(),\n                r = b.toValue(h - f, !0) + g * k;\n            k = b.toValue(h + b.len - f, !0) - g * k;\n            var n = k < r;\n            h = n ? k : r;\n            r = n ? r : k;\n            k = Math.min(l.dataMin, g ? l.min : b.toValue(b.toPixels(l.min) - b.minPixelPadding));\n            g = Math.max(l.dataMax, g ? l.max : b.toValue(b.toPixels(l.max) + b.minPixelPadding));\n            n = k - h;\n            0 < n && (r += n, h = k);\n            n = r - g;\n            0 < n && (r = g, h -= n);\n            b.series.length && h !== l.min && r !== l.max && (b.setExtremes(h, r, !1, !1, {\n              trigger: \"pan\"\n            }), e = !0);\n            d[c] = f;\n          });\n          e && d.redraw(!1);\n          q(d.container, {\n            cursor: \"move\"\n          });\n        });\n      }\n    });\n    D(d.prototype, {\n      select: function select(a, b) {\n        var d = this,\n            c = d.series,\n            e = c.chart;\n        this.selectedStaging = a = y(a, !d.selected);\n        d.firePointEvent(a ? \"select\" : \"unselect\", {\n          accumulate: b\n        }, function () {\n          d.selected = d.options.selected = a;\n          c.options.data[c.data.indexOf(d)] = d.options;\n          d.setState(a && \"select\");\n          b || e.getSelectedPoints().forEach(function (a) {\n            var b = a.series;\n            a.selected && a !== d && (a.selected = a.options.selected = !1, b.options.data[b.data.indexOf(a)] = a.options, a.setState(e.hoverPoints && b.options.inactiveOtherPoints ? \"inactive\" : \"\"), a.firePointEvent(\"unselect\"));\n          });\n        });\n        delete this.selectedStaging;\n      },\n      onMouseOver: function onMouseOver(a) {\n        var b = this.series.chart,\n            d = b.pointer;\n        a = a ? d.normalize(a) : d.getChartCoordinatesFromPoint(this, b.inverted);\n        d.runPointActions(a, this);\n      },\n      onMouseOut: function onMouseOut() {\n        var a = this.series.chart;\n        this.firePointEvent(\"mouseOut\");\n        this.series.options.inactiveOtherPoints || (a.hoverPoints || []).forEach(function (a) {\n          a.setState();\n        });\n        a.hoverPoints = a.hoverPoint = null;\n      },\n      importEvents: function importEvents() {\n        if (!this.hasImportedEvents) {\n          var a = this,\n              d = b(a.series.options.point, a.options).events;\n          a.events = d;\n          p(d, function (b, d) {\n            c.isFunction(b) && G(a, d, b);\n          });\n          this.hasImportedEvents = !0;\n        }\n      },\n      setState: function setState(a, b) {\n        var d = this.series,\n            c = this.state,\n            e = d.options.states[a || \"normal\"] || {},\n            f = m[d.type].marker && d.options.marker,\n            h = f && !1 === f.enabled,\n            g = f && f.states && f.states[a || \"normal\"] || {},\n            k = !1 === g.enabled,\n            n = d.stateMarkerGraphic,\n            r = this.marker || {},\n            q = d.chart,\n            p = d.halo,\n            x,\n            v = f && d.markerAttribs;\n        a = a || \"\";\n\n        if (!(a === this.state && !b || this.selected && \"select\" !== a || !1 === e.enabled || a && (k || h && !1 === g.enabled) || a && r.states && r.states[a] && !1 === r.states[a].enabled)) {\n          this.state = a;\n          v && (x = d.markerAttribs(this, a));\n\n          if (this.graphic) {\n            c && this.graphic.removeClass(\"highcharts-point-\" + c);\n            a && this.graphic.addClass(\"highcharts-point-\" + a);\n\n            if (!q.styledMode) {\n              var F = d.pointAttribs(this, a);\n              var A = y(q.options.chart.animation, e.animation);\n              d.options.inactiveOtherPoints && ((this.dataLabels || []).forEach(function (a) {\n                a && a.animate({\n                  opacity: F.opacity\n                }, A);\n              }), this.connector && this.connector.animate({\n                opacity: F.opacity\n              }, A));\n              this.graphic.animate(F, A);\n            }\n\n            x && this.graphic.animate(x, y(q.options.chart.animation, g.animation, f.animation));\n            n && n.hide();\n          } else {\n            if (a && g) {\n              c = r.symbol || d.symbol;\n              n && n.currentSymbol !== c && (n = n.destroy());\n              if (x) if (n) n[b ? \"animate\" : \"attr\"]({\n                x: x.x,\n                y: x.y\n              });else c && (d.stateMarkerGraphic = n = q.renderer.symbol(c, x.x, x.y, x.width, x.height).add(d.markerGroup), n.currentSymbol = c);\n              !q.styledMode && n && n.attr(d.pointAttribs(this, a));\n            }\n\n            n && (n[a && this.isInside ? \"show\" : \"hide\"](), n.element.point = this);\n          }\n\n          a = e.halo;\n          e = (n = this.graphic || n) && n.visibility || \"inherit\";\n          a && a.size && n && \"hidden\" !== e ? (p || (d.halo = p = q.renderer.path().add(n.parentGroup)), p.show()[b ? \"animate\" : \"attr\"]({\n            d: this.haloPath(a.size)\n          }), p.attr({\n            \"class\": \"highcharts-halo highcharts-color-\" + y(this.colorIndex, d.colorIndex) + (this.className ? \" \" + this.className : \"\"),\n            visibility: e,\n            zIndex: -1\n          }), p.point = this, q.styledMode || p.attr(D({\n            fill: this.color || d.color,\n            \"fill-opacity\": a.opacity\n          }, a.attributes))) : p && p.point && p.point.haloPath && p.animate({\n            d: p.point.haloPath(0)\n          }, null, p.hide);\n          w(this, \"afterSetState\");\n        }\n      },\n      haloPath: function haloPath(a) {\n        return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - a, this.plotY - a, 2 * a, 2 * a);\n      }\n    });\n    D(a.prototype, {\n      onMouseOver: function onMouseOver() {\n        var a = this.chart,\n            b = a.hoverSeries;\n        if (b && b !== this) b.onMouseOut();\n        this.options.events.mouseOver && w(this, \"mouseOver\");\n        this.setState(\"hover\");\n        a.hoverSeries = this;\n      },\n      onMouseOut: function onMouseOut() {\n        var a = this.options,\n            b = this.chart,\n            d = b.tooltip,\n            c = b.hoverPoint;\n        b.hoverSeries = null;\n        if (c) c.onMouseOut();\n        this && a.events.mouseOut && w(this, \"mouseOut\");\n        !d || this.stickyTracking || d.shared && !this.noSharedTooltip || d.hide();\n        b.series.forEach(function (a) {\n          a.setState(\"\", !0);\n        });\n      },\n      setState: function setState(a, b) {\n        var d = this,\n            c = d.options,\n            e = d.graph,\n            f = c.inactiveOtherPoints,\n            h = c.states,\n            g = c.lineWidth,\n            k = c.opacity,\n            n = y(h[a || \"normal\"] && h[a || \"normal\"].animation, d.chart.options.chart.animation);\n        c = 0;\n        a = a || \"\";\n\n        if (d.state !== a && ([d.group, d.markerGroup, d.dataLabelsGroup].forEach(function (b) {\n          b && (d.state && b.removeClass(\"highcharts-series-\" + d.state), a && b.addClass(\"highcharts-series-\" + a));\n        }), d.state = a, !d.chart.styledMode)) {\n          if (h[a] && !1 === h[a].enabled) return;\n          a && (g = h[a].lineWidth || g + (h[a].lineWidthPlus || 0), k = y(h[a].opacity, k));\n          if (e && !e.dashstyle) for (h = {\n            \"stroke-width\": g\n          }, e.animate(h, n); d[\"zone-graph-\" + c];) {\n            d[\"zone-graph-\" + c].attr(h), c += 1;\n          }\n          f || [d.group, d.markerGroup, d.dataLabelsGroup, d.labelBySeries].forEach(function (a) {\n            a && a.animate({\n              opacity: k\n            }, n);\n          });\n        }\n\n        b && f && d.points && d.setAllPointsToState(a);\n      },\n      setAllPointsToState: function setAllPointsToState(a) {\n        this.points.forEach(function (b) {\n          b.setState && b.setState(a);\n        });\n      },\n      setVisible: function setVisible(a, b) {\n        var d = this,\n            c = d.chart,\n            e = d.legendItem,\n            f = c.options.chart.ignoreHiddenSeries,\n            h = d.visible;\n        var g = (d.visible = a = d.options.visible = d.userOptions.visible = void 0 === a ? !h : a) ? \"show\" : \"hide\";\n        [\"group\", \"dataLabelsGroup\", \"markerGroup\", \"tracker\", \"tt\"].forEach(function (a) {\n          if (d[a]) d[a][g]();\n        });\n        if (c.hoverSeries === d || (c.hoverPoint && c.hoverPoint.series) === d) d.onMouseOut();\n        e && c.legend.colorizeItem(d, a);\n        d.isDirty = !0;\n        d.options.stacking && c.series.forEach(function (a) {\n          a.options.stacking && a.visible && (a.isDirty = !0);\n        });\n        d.linkedSeries.forEach(function (b) {\n          b.setVisible(a, !1);\n        });\n        f && (c.isDirtyBox = !0);\n        w(d, g);\n        !1 !== b && c.redraw();\n      },\n      show: function show() {\n        this.setVisible(!0);\n      },\n      hide: function hide() {\n        this.setVisible(!1);\n      },\n      select: function select(a) {\n        this.selected = a = this.options.selected = void 0 === a ? !this.selected : a;\n        this.checkbox && (this.checkbox.checked = a);\n        w(this, a ? \"select\" : \"unselect\");\n      },\n      drawTracker: F.drawTrackerGraph\n    });\n  });\n  K(C, \"parts/Responsive.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var H = f.isArray,\n        D = f.isObject,\n        A = f.objectEach,\n        E = f.pick,\n        p = f.splat;\n    f = c.Chart;\n\n    f.prototype.setResponsive = function (f, p) {\n      var v = this.options.responsive,\n          q = [],\n          k = this.currentResponsive;\n      !p && v && v.rules && v.rules.forEach(function (f) {\n        void 0 === f._id && (f._id = c.uniqueKey());\n        this.matchResponsiveRule(f, q);\n      }, this);\n      p = c.merge.apply(0, q.map(function (f) {\n        return c.find(v.rules, function (c) {\n          return c._id === f;\n        }).chartOptions;\n      }));\n      p.isResponsiveOptions = !0;\n      q = q.toString() || void 0;\n      q !== (k && k.ruleIds) && (k && this.update(k.undoOptions, f, !0), q ? (k = this.currentOptions(p), k.isResponsiveOptions = !0, this.currentResponsive = {\n        ruleIds: q,\n        mergedOptions: p,\n        undoOptions: k\n      }, this.update(p, f, !0)) : this.currentResponsive = void 0);\n    };\n\n    f.prototype.matchResponsiveRule = function (c, f) {\n      var p = c.condition;\n      (p.callback || function () {\n        return this.chartWidth <= E(p.maxWidth, Number.MAX_VALUE) && this.chartHeight <= E(p.maxHeight, Number.MAX_VALUE) && this.chartWidth >= E(p.minWidth, 0) && this.chartHeight >= E(p.minHeight, 0);\n      }).call(this) && f.push(c._id);\n    };\n\n    f.prototype.currentOptions = function (c) {\n      function f(c, m, q, g) {\n        var e;\n        A(c, function (b, d) {\n          if (!g && -1 < v.collectionsWithUpdate.indexOf(d)) for (b = p(b), q[d] = [], e = 0; e < b.length; e++) {\n            m[d][e] && (q[d][e] = {}, f(b[e], m[d][e], q[d][e], g + 1));\n          } else D(b) ? (q[d] = H(b) ? [] : {}, f(b, m[d] || {}, q[d], g + 1)) : q[d] = void 0 === m[d] ? null : m[d];\n        });\n      }\n\n      var v = this,\n          q = {};\n      f(c, this.options, q, 0);\n      return q;\n    };\n  });\n  K(C, \"masters/highcharts.src.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var H = f.extend;\n    H(c, {\n      arrayMax: f.arrayMax,\n      arrayMin: f.arrayMin,\n      attr: f.attr,\n      defined: f.defined,\n      erase: f.erase,\n      extend: f.extend,\n      isArray: f.isArray,\n      isClass: f.isClass,\n      isDOMElement: f.isDOMElement,\n      isNumber: f.isNumber,\n      isObject: f.isObject,\n      isString: f.isString,\n      objectEach: f.objectEach,\n      pick: f.pick,\n      pInt: f.pInt,\n      setAnimation: f.setAnimation,\n      splat: f.splat,\n      syncTimeout: f.syncTimeout\n    });\n    return c;\n  });\n  K(C, \"parts-map/MapAxis.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var H = f.pick;\n    f = c.addEvent;\n    c = c.Axis;\n    f(c, \"getSeriesExtremes\", function () {\n      var c = [];\n      this.isXAxis && (this.series.forEach(function (f, E) {\n        f.useMapGeometry && (c[E] = f.xData, f.xData = []);\n      }), this.seriesXData = c);\n    });\n    f(c, \"afterGetSeriesExtremes\", function () {\n      var c = this.seriesXData,\n          f;\n\n      if (this.isXAxis) {\n        var E = H(this.dataMin, Number.MAX_VALUE);\n        var p = H(this.dataMax, -Number.MAX_VALUE);\n        this.series.forEach(function (A, D) {\n          A.useMapGeometry && (E = Math.min(E, H(A.minX, E)), p = Math.max(p, H(A.maxX, p)), A.xData = c[D], f = !0);\n        });\n        f && (this.dataMin = E, this.dataMax = p);\n        delete this.seriesXData;\n      }\n    });\n    f(c, \"afterSetAxisTranslation\", function () {\n      var c = this.chart;\n      var f = c.plotWidth / c.plotHeight;\n      c = c.xAxis[0];\n      var E;\n      \"yAxis\" === this.coll && void 0 !== c.transA && this.series.forEach(function (c) {\n        c.preserveAspectRatio && (E = !0);\n      });\n\n      if (E && (this.transA = c.transA = Math.min(this.transA, c.transA), f /= (c.max - c.min) / (this.max - this.min), f = 1 > f ? this : c, c = (f.max - f.min) * f.transA, f.pixelPadding = f.len - c, f.minPixelPadding = f.pixelPadding / 2, c = f.fixTo)) {\n        c = c[1] - f.toValue(c[0], !0);\n        c *= f.transA;\n        if (Math.abs(c) > f.minPixelPadding || f.min === f.dataMin && f.max === f.dataMax) c = 0;\n        f.minPixelPadding -= c;\n      }\n    });\n    f(c, \"render\", function () {\n      this.fixTo = null;\n    });\n  });\n  K(C, \"parts-map/ColorSeriesMixin.js\", [C[\"parts/Globals.js\"]], function (c) {\n    c.colorPointMixin = {\n      setVisible: function setVisible(c) {\n        var f = this,\n            D = c ? \"show\" : \"hide\";\n        f.visible = !!c;\n        [\"graphic\", \"dataLabel\"].forEach(function (c) {\n          if (f[c]) f[c][D]();\n        });\n      }\n    };\n    c.colorSeriesMixin = {\n      optionalAxis: \"colorAxis\",\n      colorAxis: 0,\n      translateColors: function translateColors() {\n        var c = this,\n            C = this.options.nullColor,\n            D = this.colorAxis,\n            A = this.colorKey;\n        (this.data.length ? this.data : this.points).forEach(function (f) {\n          var p = f[A];\n          if (p = f.options.color || (f.isNull ? C : D && void 0 !== p ? D.toColor(p, f) : f.color || c.color)) f.color = p;\n        });\n      }\n    };\n  });\n  K(C, \"parts-map/ColorAxis.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var C = f.erase,\n        D = f.extend,\n        A = f.isNumber,\n        E = f.pick,\n        p = f.splat;\n    f = c.addEvent;\n    var y = c.Axis,\n        G = c.Chart,\n        v = c.Series,\n        q = c.Point,\n        k = c.color,\n        m = c.Legend,\n        w = c.LegendSymbolMixin,\n        g = c.colorPointMixin,\n        e = c.noop,\n        b = c.merge;\n    D(v.prototype, c.colorSeriesMixin);\n    D(q.prototype, g);\n\n    var d = c.ColorAxis = function () {\n      this.init.apply(this, arguments);\n    };\n\n    D(d.prototype, y.prototype);\n    D(d.prototype, {\n      defaultColorAxisOptions: {\n        lineWidth: 0,\n        minPadding: 0,\n        maxPadding: 0,\n        gridLineWidth: 1,\n        tickPixelInterval: 72,\n        startOnTick: !0,\n        endOnTick: !0,\n        offset: 0,\n        marker: {\n          animation: {\n            duration: 50\n          },\n          width: .01,\n          color: \"#999999\"\n        },\n        labels: {\n          overflow: \"justify\",\n          rotation: 0\n        },\n        minColor: \"#e6ebf5\",\n        maxColor: \"#003399\",\n        tickLength: 5,\n        showInLegend: !0\n      },\n      keepProps: [\"legendGroup\", \"legendItemHeight\", \"legendItemWidth\", \"legendItem\", \"legendSymbol\"].concat(y.prototype.keepProps),\n      init: function init(a, b) {\n        this.coll = \"colorAxis\";\n        var d = this.buildOptions.call(a, this.defaultColorAxisOptions, b);\n        y.prototype.init.call(this, a, d);\n        b.dataClasses && this.initDataClasses(b);\n        this.initStops();\n        this.horiz = !d.opposite;\n        this.zoomEnabled = !1;\n        this.defaultLegendLength = 200;\n      },\n      initDataClasses: function initDataClasses(a) {\n        var d = this.chart,\n            c,\n            e = 0,\n            f = d.options.chart.colorCount,\n            g = this.options,\n            l = a.dataClasses.length;\n        this.dataClasses = c = [];\n        this.legendItems = [];\n        a.dataClasses.forEach(function (a, h) {\n          a = b(a);\n          c.push(a);\n          if (d.styledMode || !a.color) \"category\" === g.dataClassColor ? (d.styledMode || (h = d.options.colors, f = h.length, a.color = h[e]), a.colorIndex = e, e++, e === f && (e = 0)) : a.color = k(g.minColor).tweenTo(k(g.maxColor), 2 > l ? .5 : h / (l - 1));\n        });\n      },\n      hasData: function hasData() {\n        return !(!this.tickPositions || !this.tickPositions.length);\n      },\n      setTickPositions: function setTickPositions() {\n        if (!this.dataClasses) return y.prototype.setTickPositions.call(this);\n      },\n      initStops: function initStops() {\n        this.stops = this.options.stops || [[0, this.options.minColor], [1, this.options.maxColor]];\n        this.stops.forEach(function (a) {\n          a.color = k(a[1]);\n        });\n      },\n      buildOptions: function buildOptions(a, d) {\n        var c = this.options.legend,\n            e = d.layout ? \"vertical\" !== d.layout : \"vertical\" !== c.layout;\n        return b(a, {\n          side: e ? 2 : 1,\n          reversed: !e\n        }, d, {\n          opposite: !e,\n          showEmpty: !1,\n          title: null,\n          visible: c.enabled && (d ? !1 !== d.visible : !0)\n        });\n      },\n      setOptions: function setOptions(a) {\n        y.prototype.setOptions.call(this, a);\n        this.options.crosshair = this.options.marker;\n      },\n      setAxisSize: function setAxisSize() {\n        var a = this.legendSymbol,\n            b = this.chart,\n            d = b.options.legend || {},\n            c,\n            e;\n        a ? (this.left = d = a.attr(\"x\"), this.top = c = a.attr(\"y\"), this.width = e = a.attr(\"width\"), this.height = a = a.attr(\"height\"), this.right = b.chartWidth - d - e, this.bottom = b.chartHeight - c - a, this.len = this.horiz ? e : a, this.pos = this.horiz ? d : c) : this.len = (this.horiz ? d.symbolWidth : d.symbolHeight) || this.defaultLegendLength;\n      },\n      normalizedValue: function normalizedValue(a) {\n        this.isLog && (a = this.val2lin(a));\n        return 1 - (this.max - a) / (this.max - this.min || 1);\n      },\n      toColor: function toColor(a, b) {\n        var d = this.stops,\n            c = this.dataClasses,\n            e;\n        if (c) for (e = c.length; e--;) {\n          var f = c[e];\n          var h = f.from;\n          d = f.to;\n\n          if ((void 0 === h || a >= h) && (void 0 === d || a <= d)) {\n            var g = f.color;\n            b && (b.dataClass = e, b.colorIndex = f.colorIndex);\n            break;\n          }\n        } else {\n          a = this.normalizedValue(a);\n\n          for (e = d.length; e-- && !(a > d[e][0]);) {\n            ;\n          }\n\n          h = d[e] || d[e + 1];\n          d = d[e + 1] || h;\n          a = 1 - (d[0] - a) / (d[0] - h[0] || 1);\n          g = h.color.tweenTo(d.color, a);\n        }\n        return g;\n      },\n      getOffset: function getOffset() {\n        var a = this.legendGroup,\n            b = this.chart.axisOffset[this.side];\n        a && (this.axisParent = a, y.prototype.getOffset.call(this), this.added || (this.added = !0, this.labelLeft = 0, this.labelRight = this.width), this.chart.axisOffset[this.side] = b);\n      },\n      setLegendColor: function setLegendColor() {\n        var a = this.reversed;\n        var b = a ? 1 : 0;\n        a = a ? 0 : 1;\n        b = this.horiz ? [b, 0, a, 0] : [0, a, 0, b];\n        this.legendColor = {\n          linearGradient: {\n            x1: b[0],\n            y1: b[1],\n            x2: b[2],\n            y2: b[3]\n          },\n          stops: this.stops\n        };\n      },\n      drawLegendSymbol: function drawLegendSymbol(a, b) {\n        var d = a.padding,\n            c = a.options,\n            e = this.horiz,\n            f = E(c.symbolWidth, e ? this.defaultLegendLength : 12),\n            h = E(c.symbolHeight, e ? 12 : this.defaultLegendLength),\n            g = E(c.labelPadding, e ? 16 : 30);\n        c = E(c.itemDistance, 10);\n        this.setLegendColor();\n        b.legendSymbol = this.chart.renderer.rect(0, a.baseline - 11, f, h).attr({\n          zIndex: 1\n        }).add(b.legendGroup);\n        this.legendItemWidth = f + d + (e ? c : g);\n        this.legendItemHeight = h + d + (e ? g : 0);\n      },\n      setState: function setState(a) {\n        this.series.forEach(function (b) {\n          b.setState(a);\n        });\n      },\n      visible: !0,\n      setVisible: e,\n      getSeriesExtremes: function getSeriesExtremes() {\n        var a = this.series,\n            b = a.length,\n            d;\n        this.dataMin = Infinity;\n\n        for (this.dataMax = -Infinity; b--;) {\n          var c = a[b];\n          var e = c.colorKey = E(c.options.colorKey, c.colorKey, c.pointValKey, c.zoneAxis, \"y\");\n          var f = c.pointArrayMap;\n          var g = c[e + \"Min\"] && c[e + \"Max\"];\n          if (c[e + \"Data\"]) var k = c[e + \"Data\"];else if (f) {\n            k = [];\n            f = f.indexOf(e);\n            var m = c.yData;\n            if (0 <= f && m) for (d = 0; d < m.length; d++) {\n              k.push(E(m[d][f], m[d]));\n            }\n          } else k = c.yData;\n          g ? (c.minColorValue = c[e + \"Min\"], c.maxColorValue = c[e + \"Max\"]) : (v.prototype.getExtremes.call(c, k), c.minColorValue = c.dataMin, c.maxColorValue = c.dataMax);\n          void 0 !== c.minColorValue && (this.dataMin = Math.min(this.dataMin, c.minColorValue), this.dataMax = Math.max(this.dataMax, c.maxColorValue));\n          g || v.prototype.getExtremes.call(c);\n        }\n      },\n      drawCrosshair: function drawCrosshair(a, b) {\n        var d = b && b.plotX,\n            c = b && b.plotY,\n            e = this.pos,\n            f = this.len;\n\n        if (b) {\n          var h = this.toPixels(b[b.series.colorKey]);\n          h < e ? h = e - 2 : h > e + f && (h = e + f + 2);\n          b.plotX = h;\n          b.plotY = this.len - h;\n          y.prototype.drawCrosshair.call(this, a, b);\n          b.plotX = d;\n          b.plotY = c;\n          this.cross && !this.cross.addedToColorAxis && this.legendGroup && (this.cross.addClass(\"highcharts-coloraxis-marker\").add(this.legendGroup), this.cross.addedToColorAxis = !0, this.chart.styledMode || this.cross.attr({\n            fill: this.crosshair.color\n          }));\n        }\n      },\n      getPlotLinePath: function getPlotLinePath(a) {\n        var b = a.translatedValue;\n        return A(b) ? this.horiz ? [\"M\", b - 4, this.top - 6, \"L\", b + 4, this.top - 6, b, this.top, \"Z\"] : [\"M\", this.left, b, \"L\", this.left - 6, b + 6, this.left - 6, b - 6, \"Z\"] : y.prototype.getPlotLinePath.apply(this, arguments);\n      },\n      update: function update(a, d) {\n        var c = this.chart,\n            e = c.legend,\n            f = this.buildOptions.call(c, {}, a);\n        this.series.forEach(function (a) {\n          a.isDirtyData = !0;\n        });\n        (a.dataClasses && e.allItems || this.dataClasses) && this.destroyItems();\n        c.options[this.coll] = b(this.userOptions, f);\n        y.prototype.update.call(this, f, d);\n        this.legendItem && (this.setLegendColor(), e.colorizeItem(this, !0));\n      },\n      destroyItems: function destroyItems() {\n        var a = this.chart;\n        this.legendItem ? a.legend.destroyItem(this) : this.legendItems && this.legendItems.forEach(function (b) {\n          a.legend.destroyItem(b);\n        });\n        a.isDirtyLegend = !0;\n      },\n      remove: function remove(a) {\n        this.destroyItems();\n        y.prototype.remove.call(this, a);\n      },\n      getDataClassLegendSymbols: function getDataClassLegendSymbols() {\n        var a = this,\n            b = this.chart,\n            d = this.legendItems,\n            f = b.options.legend,\n            g = f.valueDecimals,\n            k = f.valueSuffix || \"\",\n            l;\n        d.length || this.dataClasses.forEach(function (f, h) {\n          var n = !0,\n              m = f.from,\n              r = f.to;\n          l = \"\";\n          void 0 === m ? l = \"< \" : void 0 === r && (l = \"> \");\n          void 0 !== m && (l += c.numberFormat(m, g) + k);\n          void 0 !== m && void 0 !== r && (l += \" - \");\n          void 0 !== r && (l += c.numberFormat(r, g) + k);\n          d.push(D({\n            chart: b,\n            name: l,\n            options: {},\n            drawLegendSymbol: w.drawRectangle,\n            visible: !0,\n            setState: e,\n            isDataClass: !0,\n            setVisible: function setVisible() {\n              n = this.visible = !n;\n              a.series.forEach(function (a) {\n                a.points.forEach(function (a) {\n                  a.dataClass === h && a.setVisible(n);\n                });\n              });\n              b.legend.colorizeItem(this, n);\n            }\n          }, f));\n        });\n        return d;\n      },\n      beforePadding: !1,\n      name: \"\"\n    });\n    [\"fill\", \"stroke\"].forEach(function (a) {\n      c.Fx.prototype[a + \"Setter\"] = function () {\n        this.elem.attr(a, k(this.start).tweenTo(k(this.end), this.pos), null, !0);\n      };\n    });\n    f(G, \"afterGetAxes\", function () {\n      var a = this,\n          b = a.options;\n      this.colorAxis = [];\n      b.colorAxis && (b.colorAxis = p(b.colorAxis), b.colorAxis.forEach(function (b, c) {\n        b.index = c;\n        new d(a, b);\n      }));\n    });\n    f(v, \"bindAxes\", function () {\n      var a = this.axisTypes;\n      a ? -1 === a.indexOf(\"colorAxis\") && a.push(\"colorAxis\") : this.axisTypes = [\"colorAxis\"];\n    });\n    f(m, \"afterGetAllItems\", function (a) {\n      var b = [],\n          d,\n          c;\n      (this.chart.colorAxis || []).forEach(function (c) {\n        (d = c.options) && d.showInLegend && (d.dataClasses && d.visible ? b = b.concat(c.getDataClassLegendSymbols()) : d.visible && b.push(c), c.series.forEach(function (b) {\n          if (!b.options.showInLegend || d.dataClasses) \"point\" === b.options.legendType ? b.points.forEach(function (b) {\n            C(a.allItems, b);\n          }) : C(a.allItems, b);\n        }));\n      });\n\n      for (c = b.length; c--;) {\n        a.allItems.unshift(b[c]);\n      }\n    });\n    f(m, \"afterColorizeItem\", function (a) {\n      a.visible && a.item.legendColor && a.item.legendSymbol.attr({\n        fill: a.item.legendColor\n      });\n    });\n    f(m, \"afterUpdate\", function () {\n      var a = this.chart.colorAxis;\n      a && a.forEach(function (a, b, d) {\n        a.update({}, d);\n      });\n    });\n    f(v, \"afterTranslate\", function () {\n      (this.chart.colorAxis && this.chart.colorAxis.length || this.colorAttribs) && this.translateColors();\n    });\n  });\n  K(C, \"parts-map/ColorMapSeriesMixin.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var C = f.defined;\n    f = c.noop;\n    var D = c.seriesTypes;\n    c.colorMapPointMixin = {\n      dataLabelOnNull: !0,\n      isValid: function isValid() {\n        return null !== this.value && Infinity !== this.value && -Infinity !== this.value;\n      },\n      setState: function setState(f) {\n        c.Point.prototype.setState.call(this, f);\n        this.graphic && this.graphic.attr({\n          zIndex: \"hover\" === f ? 1 : 0\n        });\n      }\n    };\n    c.colorMapSeriesMixin = {\n      pointArrayMap: [\"value\"],\n      axisTypes: [\"xAxis\", \"yAxis\", \"colorAxis\"],\n      trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n      getSymbol: f,\n      parallelArrays: [\"x\", \"y\", \"value\"],\n      colorKey: \"value\",\n      pointAttribs: D.column.prototype.pointAttribs,\n      colorAttribs: function colorAttribs(c) {\n        var f = {};\n        C(c.color) && (f[this.colorProp || \"fill\"] = c.color);\n        return f;\n      }\n    };\n  });\n  K(C, \"parts-map/MapNavigation.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    function C(c) {\n      c && (c.preventDefault && c.preventDefault(), c.stopPropagation && c.stopPropagation(), c.cancelBubble = !0);\n    }\n\n    function D(c) {\n      this.init(c);\n    }\n\n    var A = f.extend,\n        E = f.objectEach,\n        p = f.pick,\n        y = c.addEvent;\n    f = c.Chart;\n    var G = c.doc,\n        v = c.merge;\n\n    D.prototype.init = function (c) {\n      this.chart = c;\n      c.mapNavButtons = [];\n    };\n\n    D.prototype.update = function (c) {\n      var f = this.chart,\n          m = f.options.mapNavigation,\n          q,\n          g,\n          e,\n          b,\n          d,\n          a = function a(_a2) {\n        this.handler.call(f, _a2);\n        C(_a2);\n      },\n          h = f.mapNavButtons;\n\n      c && (m = f.options.mapNavigation = v(f.options.mapNavigation, c));\n\n      for (; h.length;) {\n        h.pop().destroy();\n      }\n\n      p(m.enableButtons, m.enabled) && !f.renderer.forExport && E(m.buttons, function (c, k) {\n        q = v(m.buttonOptions, c);\n        f.styledMode || (g = q.theme, g.style = v(q.theme.style, q.style), b = (e = g.states) && e.hover, d = e && e.select);\n        c = f.renderer.button(q.text, 0, 0, a, g, b, d, 0, \"zoomIn\" === k ? \"topbutton\" : \"bottombutton\").addClass(\"highcharts-map-navigation highcharts-\" + {\n          zoomIn: \"zoom-in\",\n          zoomOut: \"zoom-out\"\n        }[k]).attr({\n          width: q.width,\n          height: q.height,\n          title: f.options.lang[k],\n          padding: q.padding,\n          zIndex: 5\n        }).add();\n        c.handler = q.onclick;\n        c.align(A(q, {\n          width: c.width,\n          height: 2 * c.height\n        }), null, q.alignTo);\n        y(c.element, \"dblclick\", C);\n        h.push(c);\n      });\n      this.updateEvents(m);\n    };\n\n    D.prototype.updateEvents = function (c) {\n      var f = this.chart;\n      p(c.enableDoubleClickZoom, c.enabled) || c.enableDoubleClickZoomTo ? this.unbindDblClick = this.unbindDblClick || y(f.container, \"dblclick\", function (c) {\n        f.pointer.onContainerDblClick(c);\n      }) : this.unbindDblClick && (this.unbindDblClick = this.unbindDblClick());\n      p(c.enableMouseWheelZoom, c.enabled) ? this.unbindMouseWheel = this.unbindMouseWheel || y(f.container, void 0 === G.onmousewheel ? \"DOMMouseScroll\" : \"mousewheel\", function (c) {\n        f.pointer.onContainerMouseWheel(c);\n        C(c);\n        return !1;\n      }) : this.unbindMouseWheel && (this.unbindMouseWheel = this.unbindMouseWheel());\n    };\n\n    A(f.prototype, {\n      fitToBox: function fitToBox(c, f) {\n        [[\"x\", \"width\"], [\"y\", \"height\"]].forEach(function (k) {\n          var m = k[0];\n          k = k[1];\n          c[m] + c[k] > f[m] + f[k] && (c[k] > f[k] ? (c[k] = f[k], c[m] = f[m]) : c[m] = f[m] + f[k] - c[k]);\n          c[k] > f[k] && (c[k] = f[k]);\n          c[m] < f[m] && (c[m] = f[m]);\n        });\n        return c;\n      },\n      mapZoom: function mapZoom(c, f, m, v, g) {\n        var e = this.xAxis[0],\n            b = e.max - e.min,\n            d = p(f, e.min + b / 2),\n            a = b * c;\n        b = this.yAxis[0];\n        var h = b.max - b.min,\n            k = p(m, b.min + h / 2);\n        h *= c;\n        d = this.fitToBox({\n          x: d - a * (v ? (v - e.pos) / e.len : .5),\n          y: k - h * (g ? (g - b.pos) / b.len : .5),\n          width: a,\n          height: h\n        }, {\n          x: e.dataMin,\n          y: b.dataMin,\n          width: e.dataMax - e.dataMin,\n          height: b.dataMax - b.dataMin\n        });\n        a = d.x <= e.dataMin && d.width >= e.dataMax - e.dataMin && d.y <= b.dataMin && d.height >= b.dataMax - b.dataMin;\n        v && (e.fixTo = [v - e.pos, f]);\n        g && (b.fixTo = [g - b.pos, m]);\n        void 0 === c || a ? (e.setExtremes(void 0, void 0, !1), b.setExtremes(void 0, void 0, !1)) : (e.setExtremes(d.x, d.x + d.width, !1), b.setExtremes(d.y, d.y + d.height, !1));\n        this.redraw();\n      }\n    });\n    y(f, \"beforeRender\", function () {\n      this.mapNavigation = new D(this);\n      this.mapNavigation.update();\n    });\n    c.MapNavigation = D;\n  });\n  K(C, \"parts-map/MapPointer.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var C = f.extend,\n        D = f.pick;\n    f = c.Pointer;\n    c = c.wrap;\n    C(f.prototype, {\n      onContainerDblClick: function onContainerDblClick(c) {\n        var f = this.chart;\n        c = this.normalize(c);\n        f.options.mapNavigation.enableDoubleClickZoomTo ? f.pointer.inClass(c.target, \"highcharts-tracker\") && f.hoverPoint && f.hoverPoint.zoomTo() : f.isInsidePlot(c.chartX - f.plotLeft, c.chartY - f.plotTop) && f.mapZoom(.5, f.xAxis[0].toValue(c.chartX), f.yAxis[0].toValue(c.chartY), c.chartX, c.chartY);\n      },\n      onContainerMouseWheel: function onContainerMouseWheel(c) {\n        var f = this.chart;\n        c = this.normalize(c);\n        var p = c.detail || -(c.wheelDelta / 120);\n        f.isInsidePlot(c.chartX - f.plotLeft, c.chartY - f.plotTop) && f.mapZoom(Math.pow(f.options.mapNavigation.mouseWheelSensitivity, p), f.xAxis[0].toValue(c.chartX), f.yAxis[0].toValue(c.chartY), c.chartX, c.chartY);\n      }\n    });\n    c(f.prototype, \"zoomOption\", function (c) {\n      var f = this.chart.options.mapNavigation;\n      D(f.enableTouchZoom, f.enabled) && (this.chart.options.chart.pinchType = \"xy\");\n      c.apply(this, [].slice.call(arguments, 1));\n    });\n    c(f.prototype, \"pinchTranslate\", function (c, f, p, y, D, v, q) {\n      c.call(this, f, p, y, D, v, q);\n      \"map\" === this.chart.options.chart.type && this.hasZoom && (c = y.scaleX > y.scaleY, this.pinchTranslateDirection(!c, f, p, y, D, v, q, c ? y.scaleX : y.scaleY));\n    });\n  });\n  K(C, \"parts-map/MapSeries.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var C = f.extend,\n        D = f.isArray,\n        A = f.isNumber,\n        E = f.objectEach,\n        p = f.pick,\n        y = f.splat;\n    f = c.colorMapPointMixin;\n    var G = c.merge,\n        v = c.noop,\n        q = c.fireEvent,\n        k = c.Point,\n        m = c.Series,\n        w = c.seriesType,\n        g = c.seriesTypes;\n    w(\"map\", \"scatter\", {\n      animation: !1,\n      dataLabels: {\n        crop: !1,\n        formatter: function formatter() {\n          return this.point.value;\n        },\n        inside: !0,\n        overflow: !1,\n        padding: 0,\n        verticalAlign: \"middle\"\n      },\n      marker: null,\n      nullColor: \"#f7f7f7\",\n      stickyTracking: !1,\n      tooltip: {\n        followPointer: !0,\n        pointFormat: \"{point.name}: {point.value}<br/>\"\n      },\n      turboThreshold: 0,\n      allAreas: !0,\n      borderColor: \"#cccccc\",\n      borderWidth: 1,\n      joinBy: \"hc-key\",\n      states: {\n        hover: {\n          halo: null,\n          brightness: .2\n        },\n        normal: {\n          animation: !0\n        },\n        select: {\n          color: \"#cccccc\"\n        },\n        inactive: {\n          opacity: 1\n        }\n      }\n    }, G(c.colorMapSeriesMixin, {\n      type: \"map\",\n      getExtremesFromAll: !0,\n      useMapGeometry: !0,\n      forceDL: !0,\n      searchPoint: v,\n      directTouch: !0,\n      preserveAspectRatio: !0,\n      pointArrayMap: [\"value\"],\n      setOptions: function setOptions(c) {\n        c = m.prototype.setOptions.call(this, c);\n        var b = c.joinBy;\n        null === b && (b = \"_i\");\n        b = this.joinBy = y(b);\n        b[1] || (b[1] = b[0]);\n        return c;\n      },\n      getBox: function getBox(e) {\n        var b = Number.MAX_VALUE,\n            d = -b,\n            a = b,\n            f = -b,\n            g = b,\n            k = b,\n            m = this.xAxis,\n            q = this.yAxis,\n            l;\n        (e || []).forEach(function (e) {\n          if (e.path) {\n            \"string\" === typeof e.path && (e.path = c.splitPath(e.path));\n            var h = e.path || [],\n                n = h.length,\n                m = !1,\n                r = -b,\n                q = b,\n                t = -b,\n                x = b,\n                v = e.properties;\n\n            if (!e._foundBox) {\n              for (; n--;) {\n                A(h[n]) && (m ? (r = Math.max(r, h[n]), q = Math.min(q, h[n])) : (t = Math.max(t, h[n]), x = Math.min(x, h[n])), m = !m);\n              }\n\n              e._midX = q + (r - q) * p(e.middleX, v && v[\"hc-middle-x\"], .5);\n              e._midY = x + (t - x) * p(e.middleY, v && v[\"hc-middle-y\"], .5);\n              e._maxX = r;\n              e._minX = q;\n              e._maxY = t;\n              e._minY = x;\n              e.labelrank = p(e.labelrank, (r - q) * (t - x));\n              e._foundBox = !0;\n            }\n\n            d = Math.max(d, e._maxX);\n            a = Math.min(a, e._minX);\n            f = Math.max(f, e._maxY);\n            g = Math.min(g, e._minY);\n            k = Math.min(e._maxX - e._minX, e._maxY - e._minY, k);\n            l = !0;\n          }\n        });\n        l && (this.minY = Math.min(g, p(this.minY, b)), this.maxY = Math.max(f, p(this.maxY, -b)), this.minX = Math.min(a, p(this.minX, b)), this.maxX = Math.max(d, p(this.maxX, -b)), m && void 0 === m.options.minRange && (m.minRange = Math.min(5 * k, (this.maxX - this.minX) / 5, m.minRange || b)), q && void 0 === q.options.minRange && (q.minRange = Math.min(5 * k, (this.maxY - this.minY) / 5, q.minRange || b)));\n      },\n      hasData: function hasData() {\n        return !!this.processedXData.length;\n      },\n      getExtremes: function getExtremes() {\n        m.prototype.getExtremes.call(this, this.valueData);\n        this.chart.hasRendered && this.isDirtyData && this.getBox(this.options.data);\n        this.valueMin = this.dataMin;\n        this.valueMax = this.dataMax;\n        this.dataMin = this.minY;\n        this.dataMax = this.maxY;\n      },\n      translatePath: function translatePath(c) {\n        var b = !1,\n            d = this.xAxis,\n            a = this.yAxis,\n            e = d.min,\n            f = d.transA;\n        d = d.minPixelPadding;\n        var g = a.min,\n            k = a.transA;\n        a = a.minPixelPadding;\n        var m,\n            l = [];\n        if (c) for (m = c.length; m--;) {\n          A(c[m]) ? (l[m] = b ? (c[m] - e) * f + d : (c[m] - g) * k + a, b = !b) : l[m] = c[m];\n        }\n        return l;\n      },\n      setData: function setData(e, b, d, a) {\n        var f = this.options,\n            g = this.chart.options.chart,\n            k = g && g.map,\n            r = f.mapData,\n            q = this.joinBy,\n            l = f.keys || this.pointArrayMap,\n            p = [],\n            v = {},\n            w = this.chart.mapTransforms;\n        !r && k && (r = \"string\" === typeof k ? c.maps[k] : k);\n        e && e.forEach(function (a, b) {\n          var d = 0;\n          if (A(a)) e[b] = {\n            value: a\n          };else if (D(a)) {\n            e[b] = {};\n            !f.keys && a.length > l.length && \"string\" === typeof a[0] && (e[b][\"hc-key\"] = a[0], ++d);\n\n            for (var h = 0; h < l.length; ++h, ++d) {\n              l[h] && void 0 !== a[d] && (0 < l[h].indexOf(\".\") ? c.Point.prototype.setNestedProperty(e[b], a[d], l[h]) : e[b][l[h]] = a[d]);\n            }\n          }\n          q && \"_i\" === q[0] && (e[b]._i = b);\n        });\n        this.getBox(e);\n        (this.chart.mapTransforms = w = g && g.mapTransforms || r && r[\"hc-transform\"] || w) && E(w, function (a) {\n          a.rotation && (a.cosAngle = Math.cos(a.rotation), a.sinAngle = Math.sin(a.rotation));\n        });\n\n        if (r) {\n          \"FeatureCollection\" === r.type && (this.mapTitle = r.title, r = c.geojson(r, this.type, this));\n          this.mapData = r;\n          this.mapMap = {};\n\n          for (w = 0; w < r.length; w++) {\n            g = r[w], k = g.properties, g._i = w, q[0] && k && k[q[0]] && (g[q[0]] = k[q[0]]), v[g[q[0]]] = g;\n          }\n\n          this.mapMap = v;\n          e && q[1] && e.forEach(function (a) {\n            v[a[q[1]]] && p.push(v[a[q[1]]]);\n          });\n          f.allAreas ? (this.getBox(r), e = e || [], q[1] && e.forEach(function (a) {\n            p.push(a[q[1]]);\n          }), p = \"|\" + p.map(function (a) {\n            return a && a[q[0]];\n          }).join(\"|\") + \"|\", r.forEach(function (b) {\n            q[0] && -1 !== p.indexOf(\"|\" + b[q[0]] + \"|\") || (e.push(G(b, {\n              value: null\n            })), a = !1);\n          })) : this.getBox(p);\n        }\n\n        m.prototype.setData.call(this, e, b, d, a);\n      },\n      drawGraph: v,\n      drawDataLabels: v,\n      doFullTranslate: function doFullTranslate() {\n        return this.isDirtyData || this.chart.isResizing || this.chart.renderer.isVML || !this.baseTrans;\n      },\n      translate: function translate() {\n        var c = this,\n            b = c.xAxis,\n            d = c.yAxis,\n            a = c.doFullTranslate();\n        c.generatePoints();\n        c.data.forEach(function (e) {\n          A(e._midX) && A(e._midY) && (e.plotX = b.toPixels(e._midX, !0), e.plotY = d.toPixels(e._midY, !0));\n          a && (e.shapeType = \"path\", e.shapeArgs = {\n            d: c.translatePath(e.path)\n          });\n        });\n        q(c, \"afterTranslate\");\n      },\n      pointAttribs: function pointAttribs(c, b) {\n        b = c.series.chart.styledMode ? this.colorAttribs(c) : g.column.prototype.pointAttribs.call(this, c, b);\n        b[\"stroke-width\"] = p(c.options[this.pointAttrToOptions && this.pointAttrToOptions[\"stroke-width\"] || \"borderWidth\"], \"inherit\");\n        return b;\n      },\n      drawPoints: function drawPoints() {\n        var c = this,\n            b = c.xAxis,\n            d = c.yAxis,\n            a = c.group,\n            f = c.chart,\n            k = f.renderer,\n            m = this.baseTrans;\n        c.transformGroup || (c.transformGroup = k.g().attr({\n          scaleX: 1,\n          scaleY: 1\n        }).add(a), c.transformGroup.survive = !0);\n        if (c.doFullTranslate()) f.hasRendered && !f.styledMode && c.points.forEach(function (a) {\n          a.shapeArgs && (a.shapeArgs.fill = c.pointAttribs(a, a.state).fill);\n        }), c.group = c.transformGroup, g.column.prototype.drawPoints.apply(c), c.group = a, c.points.forEach(function (a) {\n          if (a.graphic) {\n            var b = \"\";\n            a.name && (b += \"highcharts-name-\" + a.name.replace(/ /g, \"-\").toLowerCase());\n            a.properties && a.properties[\"hc-key\"] && (b += \" highcharts-key-\" + a.properties[\"hc-key\"].toLowerCase());\n            b && a.graphic.addClass(b);\n            f.styledMode && a.graphic.css(c.pointAttribs(a, a.selected && \"select\"));\n          }\n        }), this.baseTrans = {\n          originX: b.min - b.minPixelPadding / b.transA,\n          originY: d.min - d.minPixelPadding / d.transA + (d.reversed ? 0 : d.len / d.transA),\n          transAX: b.transA,\n          transAY: d.transA\n        }, this.transformGroup.animate({\n          translateX: 0,\n          translateY: 0,\n          scaleX: 1,\n          scaleY: 1\n        });else {\n          var r = b.transA / m.transAX;\n          var q = d.transA / m.transAY;\n          var l = b.toPixels(m.originX, !0);\n          var t = d.toPixels(m.originY, !0);\n          .99 < r && 1.01 > r && .99 < q && 1.01 > q && (q = r = 1, l = Math.round(l), t = Math.round(t));\n          var v = this.transformGroup;\n\n          if (f.renderer.globalAnimation) {\n            var w = v.attr(\"translateX\");\n            var z = v.attr(\"translateY\");\n            var u = v.attr(\"scaleX\");\n            var y = v.attr(\"scaleY\");\n            v.attr({\n              animator: 0\n            }).animate({\n              animator: 1\n            }, {\n              step: function step(a, b) {\n                v.attr({\n                  translateX: w + (l - w) * b.pos,\n                  translateY: z + (t - z) * b.pos,\n                  scaleX: u + (r - u) * b.pos,\n                  scaleY: y + (q - y) * b.pos\n                });\n              }\n            });\n          } else v.attr({\n            translateX: l,\n            translateY: t,\n            scaleX: r,\n            scaleY: q\n          });\n        }\n        f.styledMode || a.element.setAttribute(\"stroke-width\", p(c.options[c.pointAttrToOptions && c.pointAttrToOptions[\"stroke-width\"] || \"borderWidth\"], 1) / (r || 1));\n        this.drawMapDataLabels();\n      },\n      drawMapDataLabels: function drawMapDataLabels() {\n        m.prototype.drawDataLabels.call(this);\n        this.dataLabelsGroup && this.dataLabelsGroup.clip(this.chart.clipRect);\n      },\n      render: function render() {\n        var c = this,\n            b = m.prototype.render;\n        c.chart.renderer.isVML && 3E3 < c.data.length ? setTimeout(function () {\n          b.call(c);\n        }) : b.call(c);\n      },\n      animate: function animate(c) {\n        var b = this.options.animation,\n            d = this.group,\n            a = this.xAxis,\n            e = this.yAxis,\n            f = a.pos,\n            g = e.pos;\n        this.chart.renderer.isSVG && (!0 === b && (b = {\n          duration: 1E3\n        }), c ? d.attr({\n          translateX: f + a.len / 2,\n          translateY: g + e.len / 2,\n          scaleX: .001,\n          scaleY: .001\n        }) : (d.animate({\n          translateX: f,\n          translateY: g,\n          scaleX: 1,\n          scaleY: 1\n        }, b), this.animate = null));\n      },\n      animateDrilldown: function animateDrilldown(c) {\n        var b = this.chart.plotBox,\n            d = this.chart.drilldownLevels[this.chart.drilldownLevels.length - 1],\n            a = d.bBox,\n            e = this.chart.options.drilldown.animation;\n        c || (c = Math.min(a.width / b.width, a.height / b.height), d.shapeArgs = {\n          scaleX: c,\n          scaleY: c,\n          translateX: a.x,\n          translateY: a.y\n        }, this.points.forEach(function (a) {\n          a.graphic && a.graphic.attr(d.shapeArgs).animate({\n            scaleX: 1,\n            scaleY: 1,\n            translateX: 0,\n            translateY: 0\n          }, e);\n        }), this.animate = null);\n      },\n      drawLegendSymbol: c.LegendSymbolMixin.drawRectangle,\n      animateDrillupFrom: function animateDrillupFrom(c) {\n        g.column.prototype.animateDrillupFrom.call(this, c);\n      },\n      animateDrillupTo: function animateDrillupTo(c) {\n        g.column.prototype.animateDrillupTo.call(this, c);\n      }\n    }), C({\n      applyOptions: function applyOptions(c, b) {\n        var d = this.series;\n        c = k.prototype.applyOptions.call(this, c, b);\n        b = d.joinBy;\n        d.mapData && ((b = void 0 !== c[b[1]] && d.mapMap[c[b[1]]]) ? (d.xyFromShape && (c.x = b._midX, c.y = b._midY), C(c, b)) : c.value = c.value || null);\n        return c;\n      },\n      onMouseOver: function onMouseOver(e) {\n        c.clearTimeout(this.colorInterval);\n        if (null !== this.value || this.series.options.nullInteraction) k.prototype.onMouseOver.call(this, e);else this.series.onMouseOut(e);\n      },\n      zoomTo: function zoomTo() {\n        var c = this.series;\n        c.xAxis.setExtremes(this._minX, this._maxX, !1);\n        c.yAxis.setExtremes(this._minY, this._maxY, !1);\n        c.chart.redraw();\n      }\n    }, f));\n    \"\";\n  });\n  K(C, \"parts-map/MapLineSeries.js\", [C[\"parts/Globals.js\"]], function (c) {\n    var f = c.seriesType,\n        C = c.seriesTypes;\n    f(\"mapline\", \"map\", {\n      lineWidth: 1,\n      fillColor: \"none\"\n    }, {\n      type: \"mapline\",\n      colorProp: \"stroke\",\n      pointAttrToOptions: {\n        stroke: \"color\",\n        \"stroke-width\": \"lineWidth\"\n      },\n      pointAttribs: function pointAttribs(c, f) {\n        c = C.map.prototype.pointAttribs.call(this, c, f);\n        c.fill = this.options.fillColor;\n        return c;\n      },\n      drawLegendSymbol: C.line.prototype.drawLegendSymbol\n    });\n    \"\";\n  });\n  K(C, \"parts-map/MapPointSeries.js\", [C[\"parts/Globals.js\"]], function (c) {\n    var f = c.merge,\n        C = c.Point;\n    c = c.seriesType;\n    c(\"mappoint\", \"scatter\", {\n      dataLabels: {\n        crop: !1,\n        defer: !1,\n        enabled: !0,\n        formatter: function formatter() {\n          return this.point.name;\n        },\n        overflow: !1,\n        style: {\n          color: \"#000000\"\n        }\n      }\n    }, {\n      type: \"mappoint\",\n      forceDL: !0\n    }, {\n      applyOptions: function applyOptions(c, A) {\n        c = void 0 !== c.lat && void 0 !== c.lon ? f(c, this.series.chart.fromLatLonToPoint(c)) : c;\n        return C.prototype.applyOptions.call(this, c, A);\n      }\n    });\n    \"\";\n  });\n  K(C, \"parts-more/BubbleLegend.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var C = f.arrayMax,\n        D = f.arrayMin,\n        A = f.isNumber,\n        E = f.objectEach,\n        p = f.pick;\n    f = c.Series;\n    var y = c.Legend,\n        G = c.Chart,\n        v = c.addEvent,\n        q = c.wrap,\n        k = c.color,\n        m = c.numberFormat,\n        w = c.merge,\n        g = c.noop,\n        e = c.stableSort,\n        b = c.setOptions;\n    b({\n      legend: {\n        bubbleLegend: {\n          borderColor: void 0,\n          borderWidth: 2,\n          className: void 0,\n          color: void 0,\n          connectorClassName: void 0,\n          connectorColor: void 0,\n          connectorDistance: 60,\n          connectorWidth: 1,\n          enabled: !1,\n          labels: {\n            className: void 0,\n            allowOverlap: !1,\n            format: \"\",\n            formatter: void 0,\n            align: \"right\",\n            style: {\n              fontSize: 10,\n              color: void 0\n            },\n            x: 0,\n            y: 0\n          },\n          maxSize: 60,\n          minSize: 10,\n          legendIndex: 0,\n          ranges: {\n            value: void 0,\n            borderColor: void 0,\n            color: void 0,\n            connectorColor: void 0\n          },\n          sizeBy: \"area\",\n          sizeByAbsoluteValue: !1,\n          zIndex: 1,\n          zThreshold: 0\n        }\n      }\n    });\n\n    c.BubbleLegend = function (b, a) {\n      this.init(b, a);\n    };\n\n    c.BubbleLegend.prototype = {\n      init: function init(b, a) {\n        this.options = b;\n        this.visible = !0;\n        this.chart = a.chart;\n        this.legend = a;\n      },\n      setState: g,\n      addToLegend: function addToLegend(b) {\n        b.splice(this.options.legendIndex, 0, this);\n      },\n      drawLegendSymbol: function drawLegendSymbol(b) {\n        var a = this.chart,\n            c = this.options,\n            d = p(b.options.itemDistance, 20),\n            f = c.ranges;\n        var g = c.connectorDistance;\n        this.fontMetrics = a.renderer.fontMetrics(c.labels.style.fontSize.toString() + \"px\");\n        f && f.length && A(f[0].value) ? (e(f, function (a, b) {\n          return b.value - a.value;\n        }), this.ranges = f, this.setOptions(), this.render(), a = this.getMaxLabelSize(), f = this.ranges[0].radius, b = 2 * f, g = g - f + a.width, g = 0 < g ? g : 0, this.maxLabel = a, this.movementX = \"left\" === c.labels.align ? g : 0, this.legendItemWidth = b + g + d, this.legendItemHeight = b + this.fontMetrics.h / 2) : b.options.bubbleLegend.autoRanges = !0;\n      },\n      setOptions: function setOptions() {\n        var b = this.ranges,\n            a = this.options,\n            c = this.chart.series[a.seriesIndex],\n            e = this.legend.baseline,\n            f = {\n          \"z-index\": a.zIndex,\n          \"stroke-width\": a.borderWidth\n        },\n            g = {\n          \"z-index\": a.zIndex,\n          \"stroke-width\": a.connectorWidth\n        },\n            m = this.getLabelStyles(),\n            l = c.options.marker.fillOpacity,\n            q = this.chart.styledMode;\n        b.forEach(function (d, h) {\n          q || (f.stroke = p(d.borderColor, a.borderColor, c.color), f.fill = p(d.color, a.color, 1 !== l ? k(c.color).setOpacity(l).get(\"rgba\") : c.color), g.stroke = p(d.connectorColor, a.connectorColor, c.color));\n          b[h].radius = this.getRangeRadius(d.value);\n          b[h] = w(b[h], {\n            center: b[0].radius - b[h].radius + e\n          });\n          q || w(!0, b[h], {\n            bubbleStyle: w(!1, f),\n            connectorStyle: w(!1, g),\n            labelStyle: m\n          });\n        }, this);\n      },\n      getLabelStyles: function getLabelStyles() {\n        var b = this.options,\n            a = {},\n            c = \"left\" === b.labels.align,\n            e = this.legend.options.rtl;\n        E(b.labels.style, function (b, c) {\n          \"color\" !== c && \"fontSize\" !== c && \"z-index\" !== c && (a[c] = b);\n        });\n        return w(!1, a, {\n          \"font-size\": b.labels.style.fontSize,\n          fill: p(b.labels.style.color, \"#000000\"),\n          \"z-index\": b.zIndex,\n          align: e || c ? \"right\" : \"left\"\n        });\n      },\n      getRangeRadius: function getRangeRadius(b) {\n        var a = this.options;\n        return this.chart.series[this.options.seriesIndex].getRadius.call(this, a.ranges[a.ranges.length - 1].value, a.ranges[0].value, a.minSize, a.maxSize, b);\n      },\n      render: function render() {\n        var b = this.chart.renderer,\n            a = this.options.zThreshold;\n        this.symbols || (this.symbols = {\n          connectors: [],\n          bubbleItems: [],\n          labels: []\n        });\n        this.legendSymbol = b.g(\"bubble-legend\");\n        this.legendItem = b.g(\"bubble-legend-item\");\n        this.legendSymbol.translateX = 0;\n        this.legendSymbol.translateY = 0;\n        this.ranges.forEach(function (b) {\n          b.value >= a && this.renderRange(b);\n        }, this);\n        this.legendSymbol.add(this.legendItem);\n        this.legendItem.add(this.legendGroup);\n        this.hideOverlappingLabels();\n      },\n      renderRange: function renderRange(b) {\n        var a = this.options,\n            c = a.labels,\n            d = this.chart.renderer,\n            e = this.symbols,\n            f = e.labels,\n            g = b.center,\n            k = Math.abs(b.radius),\n            m = a.connectorDistance,\n            q = c.align,\n            p = c.style.fontSize;\n        m = this.legend.options.rtl || \"left\" === q ? -m : m;\n        c = a.connectorWidth;\n        var v = this.ranges[0].radius,\n            u = g - k - a.borderWidth / 2 + c / 2;\n        p = p / 2 - (this.fontMetrics.h - p) / 2;\n        var w = d.styledMode;\n        \"center\" === q && (m = 0, a.connectorDistance = 0, b.labelStyle.align = \"center\");\n        q = u + a.labels.y;\n        var y = v + m + a.labels.x;\n        e.bubbleItems.push(d.circle(v, g + ((u % 1 ? 1 : .5) - (c % 2 ? 0 : .5)), k).attr(w ? {} : b.bubbleStyle).addClass((w ? \"highcharts-color-\" + this.options.seriesIndex + \" \" : \"\") + \"highcharts-bubble-legend-symbol \" + (a.className || \"\")).add(this.legendSymbol));\n        e.connectors.push(d.path(d.crispLine([\"M\", v, u, \"L\", v + m, u], a.connectorWidth)).attr(w ? {} : b.connectorStyle).addClass((w ? \"highcharts-color-\" + this.options.seriesIndex + \" \" : \"\") + \"highcharts-bubble-legend-connectors \" + (a.connectorClassName || \"\")).add(this.legendSymbol));\n        b = d.text(this.formatLabel(b), y, q + p).attr(w ? {} : b.labelStyle).addClass(\"highcharts-bubble-legend-labels \" + (a.labels.className || \"\")).add(this.legendSymbol);\n        f.push(b);\n        b.placed = !0;\n        b.alignAttr = {\n          x: y,\n          y: q + p\n        };\n      },\n      getMaxLabelSize: function getMaxLabelSize() {\n        var b, a;\n        this.symbols.labels.forEach(function (c) {\n          a = c.getBBox(!0);\n          b = b ? a.width > b.width ? a : b : a;\n        });\n        return b || {};\n      },\n      formatLabel: function formatLabel(b) {\n        var a = this.options,\n            d = a.labels.formatter;\n        return (a = a.labels.format) ? c.format(a, b) : d ? d.call(b) : m(b.value, 1);\n      },\n      hideOverlappingLabels: function hideOverlappingLabels() {\n        var b = this.chart,\n            a = this.symbols;\n        !this.options.labels.allowOverlap && a && (b.hideOverlappingLabels(a.labels), a.labels.forEach(function (b, c) {\n          b.newOpacity ? b.newOpacity !== b.oldOpacity && a.connectors[c].show() : a.connectors[c].hide();\n        }));\n      },\n      getRanges: function getRanges() {\n        var b = this.legend.bubbleLegend,\n            a = b.options.ranges,\n            c,\n            e = Number.MAX_VALUE,\n            f = -Number.MAX_VALUE;\n        b.chart.series.forEach(function (a) {\n          a.isBubble && !a.ignoreSeries && (c = a.zData.filter(A), c.length && (e = p(a.options.zMin, Math.min(e, Math.max(D(c), !1 === a.options.displayNegative ? a.options.zThreshold : -Number.MAX_VALUE))), f = p(a.options.zMax, Math.max(f, C(c)))));\n        });\n        var g = e === f ? [{\n          value: f\n        }] : [{\n          value: e\n        }, {\n          value: (e + f) / 2\n        }, {\n          value: f,\n          autoRanges: !0\n        }];\n        a.length && a[0].radius && g.reverse();\n        g.forEach(function (b, c) {\n          a && a[c] && (g[c] = w(!1, a[c], b));\n        });\n        return g;\n      },\n      predictBubbleSizes: function predictBubbleSizes() {\n        var b = this.chart,\n            a = this.fontMetrics,\n            c = b.legend.options,\n            e = \"horizontal\" === c.layout,\n            f = e ? b.legend.lastLineHeight : 0,\n            g = b.plotSizeX,\n            k = b.plotSizeY,\n            l = b.series[this.options.seriesIndex];\n        b = Math.ceil(l.minPxSize);\n        var m = Math.ceil(l.maxPxSize);\n        l = l.options.maxSize;\n        var q = Math.min(k, g);\n        if (c.floating || !/%$/.test(l)) a = m;else if (l = parseFloat(l), a = (q + f - a.h / 2) * l / 100 / (l / 100 + 1), e && k - a >= g || !e && g - a >= k) a = m;\n        return [b, Math.ceil(a)];\n      },\n      updateRanges: function updateRanges(b, a) {\n        var c = this.legend.options.bubbleLegend;\n        c.minSize = b;\n        c.maxSize = a;\n        c.ranges = this.getRanges();\n      },\n      correctSizes: function correctSizes() {\n        var b = this.legend,\n            a = this.chart.series[this.options.seriesIndex];\n        1 < Math.abs(Math.ceil(a.maxPxSize) - this.options.maxSize) && (this.updateRanges(this.options.minSize, a.maxPxSize), b.render());\n      }\n    };\n    v(c.Legend, \"afterGetAllItems\", function (b) {\n      var a = this.bubbleLegend,\n          d = this.options,\n          e = d.bubbleLegend,\n          f = this.chart.getVisibleBubbleSeriesIndex();\n      a && a.ranges && a.ranges.length && (e.ranges.length && (e.autoRanges = !!e.ranges[0].autoRanges), this.destroyItem(a));\n      0 <= f && d.enabled && e.enabled && (e.seriesIndex = f, this.bubbleLegend = new c.BubbleLegend(e, this), this.bubbleLegend.addToLegend(b.allItems));\n    });\n\n    G.prototype.getVisibleBubbleSeriesIndex = function () {\n      for (var b = this.series, a = 0; a < b.length;) {\n        if (b[a] && b[a].isBubble && b[a].visible && b[a].zData.length) return a;\n        a++;\n      }\n\n      return -1;\n    };\n\n    y.prototype.getLinesHeights = function () {\n      var b = this.allItems,\n          a = [],\n          c = b.length,\n          e,\n          f = 0;\n\n      for (e = 0; e < c; e++) {\n        if (b[e].legendItemHeight && (b[e].itemHeight = b[e].legendItemHeight), b[e] === b[c - 1] || b[e + 1] && b[e]._legendItemPos[1] !== b[e + 1]._legendItemPos[1]) {\n          a.push({\n            height: 0\n          });\n          var g = a[a.length - 1];\n\n          for (f; f <= e; f++) {\n            b[f].itemHeight > g.height && (g.height = b[f].itemHeight);\n          }\n\n          g.step = e;\n        }\n      }\n\n      return a;\n    };\n\n    y.prototype.retranslateItems = function (b) {\n      var a,\n          c,\n          d,\n          e = this.options.rtl,\n          f = 0;\n      this.allItems.forEach(function (g, h) {\n        a = g.legendGroup.translateX;\n        c = g._legendItemPos[1];\n        if ((d = g.movementX) || e && g.ranges) d = e ? a - g.options.maxSize / 2 : a + d, g.legendGroup.attr({\n          translateX: d\n        });\n        h > b[f].step && f++;\n        g.legendGroup.attr({\n          translateY: Math.round(c + b[f].height / 2)\n        });\n        g._legendItemPos[1] = c + b[f].height / 2;\n      });\n    };\n\n    v(f, \"legendItemClick\", function () {\n      var b = this.chart,\n          a = this.visible,\n          c = this.chart.legend;\n      c && c.bubbleLegend && (this.visible = !a, this.ignoreSeries = a, b = 0 <= b.getVisibleBubbleSeriesIndex(), c.bubbleLegend.visible !== b && (c.update({\n        bubbleLegend: {\n          enabled: b\n        }\n      }), c.bubbleLegend.visible = b), this.visible = a);\n    });\n    q(G.prototype, \"drawChartBox\", function (b, a, c) {\n      var d = this.legend,\n          e = 0 <= this.getVisibleBubbleSeriesIndex();\n\n      if (d && d.options.enabled && d.bubbleLegend && d.options.bubbleLegend.autoRanges && e) {\n        var f = d.bubbleLegend.options;\n        e = d.bubbleLegend.predictBubbleSizes();\n        d.bubbleLegend.updateRanges(e[0], e[1]);\n        f.placed || (d.group.placed = !1, d.allItems.forEach(function (a) {\n          a.legendGroup.translateY = null;\n        }));\n        d.render();\n        this.getMargins();\n        this.axes.forEach(function (a) {\n          a.visible && a.render();\n          f.placed || (a.setScale(), a.updateNames(), E(a.ticks, function (a) {\n            a.isNew = !0;\n            a.isNewLabel = !0;\n          }));\n        });\n        f.placed = !0;\n        this.getMargins();\n        b.call(this, a, c);\n        d.bubbleLegend.correctSizes();\n        d.retranslateItems(d.getLinesHeights());\n      } else b.call(this, a, c), d && d.options.enabled && d.bubbleLegend && (d.render(), d.retranslateItems(d.getLinesHeights()));\n    });\n  });\n  K(C, \"parts-more/BubbleSeries.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var C = f.arrayMax,\n        D = f.arrayMin,\n        A = f.extend,\n        E = f.isNumber,\n        p = f.pick,\n        y = f.pInt;\n    f = c.Axis;\n    var G = c.color,\n        v = c.noop,\n        q = c.Point,\n        k = c.Series,\n        m = c.seriesType,\n        w = c.seriesTypes;\n    m(\"bubble\", \"scatter\", {\n      dataLabels: {\n        formatter: function formatter() {\n          return this.point.z;\n        },\n        inside: !0,\n        verticalAlign: \"middle\"\n      },\n      animationLimit: 250,\n      marker: {\n        lineColor: null,\n        lineWidth: 1,\n        fillOpacity: .5,\n        radius: null,\n        states: {\n          hover: {\n            radiusPlus: 0\n          }\n        },\n        symbol: \"circle\"\n      },\n      minSize: 8,\n      maxSize: \"20%\",\n      softThreshold: !1,\n      states: {\n        hover: {\n          halo: {\n            size: 5\n          }\n        }\n      },\n      tooltip: {\n        pointFormat: \"({point.x}, {point.y}), Size: {point.z}\"\n      },\n      turboThreshold: 0,\n      zThreshold: 0,\n      zoneAxis: \"z\"\n    }, {\n      pointArrayMap: [\"y\", \"z\"],\n      parallelArrays: [\"x\", \"y\", \"z\"],\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      specialGroup: \"group\",\n      bubblePadding: !0,\n      zoneAxis: \"z\",\n      directTouch: !0,\n      isBubble: !0,\n      pointAttribs: function pointAttribs(c, e) {\n        var b = this.options.marker.fillOpacity;\n        c = k.prototype.pointAttribs.call(this, c, e);\n        1 !== b && (c.fill = G(c.fill).setOpacity(b).get(\"rgba\"));\n        return c;\n      },\n      getRadii: function getRadii(c, e, b) {\n        var d = this.zData,\n            a = this.yData,\n            f = b.minPxSize,\n            g = b.maxPxSize,\n            k = [];\n        var m = 0;\n\n        for (b = d.length; m < b; m++) {\n          var q = d[m];\n          k.push(this.getRadius(c, e, f, g, q, a[m]));\n        }\n\n        this.radii = k;\n      },\n      getRadius: function getRadius(c, e, b, d, a, f) {\n        var g = this.options,\n            h = \"width\" !== g.sizeBy,\n            k = g.zThreshold,\n            m = e - c,\n            l = .5;\n        if (null === f || null === a) return null;\n\n        if (E(a)) {\n          g.sizeByAbsoluteValue && (a = Math.abs(a - k), m = Math.max(e - k, Math.abs(c - k)), c = 0);\n          if (a < c) return b / 2 - 1;\n          0 < m && (l = (a - c) / m);\n        }\n\n        h && 0 <= l && (l = Math.sqrt(l));\n        return Math.ceil(b + l * (d - b)) / 2;\n      },\n      animate: function animate(c) {\n        !c && this.points.length < this.options.animationLimit && (this.points.forEach(function (c) {\n          var b = c.graphic;\n\n          if (b && b.width) {\n            var d = {\n              x: b.x,\n              y: b.y,\n              width: b.width,\n              height: b.height\n            };\n            b.attr({\n              x: c.plotX,\n              y: c.plotY,\n              width: 1,\n              height: 1\n            });\n            b.animate(d, this.options.animation);\n          }\n        }, this), this.animate = null);\n      },\n      hasData: function hasData() {\n        return !!this.processedXData.length;\n      },\n      translate: function translate() {\n        var c,\n            e = this.data,\n            b = this.radii;\n        w.scatter.prototype.translate.call(this);\n\n        for (c = e.length; c--;) {\n          var d = e[c];\n          var a = b ? b[c] : 0;\n          E(a) && a >= this.minPxSize / 2 ? (d.marker = A(d.marker, {\n            radius: a,\n            width: 2 * a,\n            height: 2 * a\n          }), d.dlBox = {\n            x: d.plotX - a,\n            y: d.plotY - a,\n            width: 2 * a,\n            height: 2 * a\n          }) : d.shapeArgs = d.plotY = d.dlBox = void 0;\n        }\n      },\n      alignDataLabel: w.column.prototype.alignDataLabel,\n      buildKDTree: v,\n      applyZones: v\n    }, {\n      haloPath: function haloPath(c) {\n        return q.prototype.haloPath.call(this, 0 === c ? 0 : (this.marker ? this.marker.radius || 0 : 0) + c);\n      },\n      ttBelow: !1\n    });\n\n    f.prototype.beforePadding = function () {\n      var c = this,\n          e = this.len,\n          b = this.chart,\n          d = 0,\n          a = e,\n          f = this.isXAxis,\n          k = f ? \"xData\" : \"yData\",\n          m = this.min,\n          q = {},\n          v = Math.min(b.plotWidth, b.plotHeight),\n          l = Number.MAX_VALUE,\n          t = -Number.MAX_VALUE,\n          w = this.max - m,\n          A = e / w,\n          z = [];\n      this.series.forEach(function (a) {\n        var d = a.options;\n        !a.bubblePadding || !a.visible && b.options.chart.ignoreHiddenSeries || (c.allowZoomOutside = !0, z.push(a), f && ([\"minSize\", \"maxSize\"].forEach(function (a) {\n          var b = d[a],\n              c = /%$/.test(b);\n          b = y(b);\n          q[a] = c ? v * b / 100 : b;\n        }), a.minPxSize = q.minSize, a.maxPxSize = Math.max(q.maxSize, q.minSize), a = a.zData.filter(E), a.length && (l = p(d.zMin, Math.min(l, Math.max(D(a), !1 === d.displayNegative ? d.zThreshold : -Number.MAX_VALUE))), t = p(d.zMax, Math.max(t, C(a))))));\n      });\n      z.forEach(function (b) {\n        var e = b[k],\n            g = e.length;\n        f && b.getRadii(l, t, b);\n        if (0 < w) for (; g--;) {\n          if (E(e[g]) && c.dataMin <= e[g] && e[g] <= c.dataMax) {\n            var h = b.radii ? b.radii[g] : 0;\n            d = Math.min((e[g] - m) * A - h, d);\n            a = Math.max((e[g] - m) * A + h, a);\n          }\n        }\n      });\n      z.length && 0 < w && !this.isLog && (a -= e, A *= (e + Math.max(0, d) - Math.min(a, e)) / e, [[\"min\", \"userMin\", d], [\"max\", \"userMax\", a]].forEach(function (a) {\n        void 0 === p(c.options[a[0]], c[a[1]]) && (c[a[0]] += a[2] / A);\n      }));\n    };\n\n    \"\";\n  });\n  K(C, \"parts-map/MapBubbleSeries.js\", [C[\"parts/Globals.js\"]], function (c) {\n    var f = c.merge,\n        C = c.Point,\n        D = c.seriesType,\n        A = c.seriesTypes;\n    A.bubble && D(\"mapbubble\", \"bubble\", {\n      animationLimit: 500,\n      tooltip: {\n        pointFormat: \"{point.name}: {point.z}\"\n      }\n    }, {\n      xyFromShape: !0,\n      type: \"mapbubble\",\n      pointArrayMap: [\"z\"],\n      getMapData: A.map.prototype.getMapData,\n      getBox: A.map.prototype.getBox,\n      setData: A.map.prototype.setData,\n      setOptions: A.map.prototype.setOptions\n    }, {\n      applyOptions: function applyOptions(c, p) {\n        return c && void 0 !== c.lat && void 0 !== c.lon ? C.prototype.applyOptions.call(this, f(c, this.series.chart.fromLatLonToPoint(c)), p) : A.map.prototype.pointClass.prototype.applyOptions.call(this, c, p);\n      },\n      isValid: function isValid() {\n        return \"number\" === typeof this.z;\n      },\n      ttBelow: !1\n    });\n    \"\";\n  });\n  K(C, \"parts-map/HeatmapSeries.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    var C = f.extend,\n        D = f.pick;\n    f = c.colorMapPointMixin;\n    var A = c.merge,\n        E = c.noop,\n        p = c.fireEvent,\n        y = c.Series,\n        G = c.seriesType,\n        v = c.seriesTypes;\n    G(\"heatmap\", \"scatter\", {\n      animation: !1,\n      borderWidth: 0,\n      nullColor: \"#f7f7f7\",\n      dataLabels: {\n        formatter: function formatter() {\n          return this.point.value;\n        },\n        inside: !0,\n        verticalAlign: \"middle\",\n        crop: !1,\n        overflow: !1,\n        padding: 0\n      },\n      marker: null,\n      pointRange: null,\n      tooltip: {\n        pointFormat: \"{point.x}, {point.y}: {point.value}<br/>\"\n      },\n      states: {\n        hover: {\n          halo: !1,\n          brightness: .2\n        }\n      }\n    }, A(c.colorMapSeriesMixin, {\n      pointArrayMap: [\"y\", \"value\"],\n      hasPointSpecificOptions: !0,\n      getExtremesFromAll: !0,\n      directTouch: !0,\n      init: function init() {\n        v.scatter.prototype.init.apply(this, arguments);\n        var c = this.options;\n        c.pointRange = D(c.pointRange, c.colsize || 1);\n        this.yAxis.axisPointRange = c.rowsize || 1;\n      },\n      translate: function translate() {\n        var c = this.options,\n            f = this.xAxis,\n            m = this.yAxis,\n            v = c.pointPadding || 0,\n            g = function g(b, c, a) {\n          return Math.min(Math.max(c, b), a);\n        },\n            e = this.pointPlacementToXValue();\n\n        this.generatePoints();\n        this.points.forEach(function (b) {\n          var d = (c.colsize || 1) / 2,\n              a = (c.rowsize || 1) / 2,\n              h = g(Math.round(f.len - f.translate(b.x - d, 0, 1, 0, 1, -e)), -f.len, 2 * f.len);\n          d = g(Math.round(f.len - f.translate(b.x + d, 0, 1, 0, 1, -e)), -f.len, 2 * f.len);\n          var k = g(Math.round(m.translate(b.y - a, 0, 1, 0, 1)), -m.len, 2 * m.len);\n          a = g(Math.round(m.translate(b.y + a, 0, 1, 0, 1)), -m.len, 2 * m.len);\n          var q = D(b.pointPadding, v);\n          b.plotX = b.clientX = (h + d) / 2;\n          b.plotY = (k + a) / 2;\n          b.shapeType = \"rect\";\n          b.shapeArgs = {\n            x: Math.min(h, d) + q,\n            y: Math.min(k, a) + q,\n            width: Math.max(Math.abs(d - h) - 2 * q, 0),\n            height: Math.max(Math.abs(a - k) - 2 * q, 0)\n          };\n        });\n        p(this, \"afterTranslate\");\n      },\n      drawPoints: function drawPoints() {\n        var c = this.chart.styledMode ? \"css\" : \"animate\";\n        v.column.prototype.drawPoints.call(this);\n        this.points.forEach(function (f) {\n          f.graphic[c](this.colorAttribs(f));\n        }, this);\n      },\n      hasData: function hasData() {\n        return !!this.processedXData.length;\n      },\n      getValidPoints: function getValidPoints(c, f) {\n        return y.prototype.getValidPoints.call(this, c, f, !0);\n      },\n      animate: E,\n      getBox: E,\n      drawLegendSymbol: c.LegendSymbolMixin.drawRectangle,\n      alignDataLabel: v.column.prototype.alignDataLabel,\n      getExtremes: function getExtremes() {\n        y.prototype.getExtremes.call(this, this.valueData);\n        this.valueMin = this.dataMin;\n        this.valueMax = this.dataMax;\n        y.prototype.getExtremes.call(this);\n      }\n    }), C({\n      haloPath: function haloPath(c) {\n        if (!c) return [];\n        var f = this.shapeArgs;\n        return [\"M\", f.x - c, f.y - c, \"L\", f.x - c, f.y + f.height + c, f.x + f.width + c, f.y + f.height + c, f.x + f.width + c, f.y - c, \"Z\"];\n      }\n    }, f));\n    \"\";\n  });\n  K(C, \"parts-map/GeoJSON.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    function C(c, f) {\n      var q,\n          k = !1,\n          m = c.x,\n          p = c.y;\n      c = 0;\n\n      for (q = f.length - 1; c < f.length; q = c++) {\n        var g = f[c][1] > p;\n        var e = f[q][1] > p;\n        g !== e && m < (f[q][0] - f[c][0]) * (p - f[c][1]) / (f[q][1] - f[c][1]) + f[c][0] && (k = !k);\n      }\n\n      return k;\n    }\n\n    var D = f.extend;\n    f = c.Chart;\n    var A = c.format,\n        E = c.merge,\n        p = c.win,\n        y = c.wrap;\n\n    f.prototype.transformFromLatLon = function (f, v) {\n      if (void 0 === p.proj4) return c.error(21, !1, this), {\n        x: 0,\n        y: null\n      };\n      f = p.proj4(v.crs, [f.lon, f.lat]);\n      var q = v.cosAngle || v.rotation && Math.cos(v.rotation),\n          k = v.sinAngle || v.rotation && Math.sin(v.rotation);\n      f = v.rotation ? [f[0] * q + f[1] * k, -f[0] * k + f[1] * q] : f;\n      return {\n        x: ((f[0] - (v.xoffset || 0)) * (v.scale || 1) + (v.xpan || 0)) * (v.jsonres || 1) + (v.jsonmarginX || 0),\n        y: (((v.yoffset || 0) - f[1]) * (v.scale || 1) + (v.ypan || 0)) * (v.jsonres || 1) - (v.jsonmarginY || 0)\n      };\n    };\n\n    f.prototype.transformToLatLon = function (f, v) {\n      if (void 0 === p.proj4) c.error(21, !1, this);else {\n        f = {\n          x: ((f.x - (v.jsonmarginX || 0)) / (v.jsonres || 1) - (v.xpan || 0)) / (v.scale || 1) + (v.xoffset || 0),\n          y: ((-f.y - (v.jsonmarginY || 0)) / (v.jsonres || 1) + (v.ypan || 0)) / (v.scale || 1) + (v.yoffset || 0)\n        };\n        var q = v.cosAngle || v.rotation && Math.cos(v.rotation),\n            k = v.sinAngle || v.rotation && Math.sin(v.rotation);\n        v = p.proj4(v.crs, \"WGS84\", v.rotation ? {\n          x: f.x * q + f.y * -k,\n          y: f.x * k + f.y * q\n        } : f);\n        return {\n          lat: v.y,\n          lon: v.x\n        };\n      }\n    };\n\n    f.prototype.fromPointToLatLon = function (f) {\n      var p = this.mapTransforms,\n          q;\n\n      if (p) {\n        for (q in p) {\n          if (Object.hasOwnProperty.call(p, q) && p[q].hitZone && C({\n            x: f.x,\n            y: -f.y\n          }, p[q].hitZone.coordinates[0])) return this.transformToLatLon(f, p[q]);\n        }\n\n        return this.transformToLatLon(f, p[\"default\"]);\n      }\n\n      c.error(22, !1, this);\n    };\n\n    f.prototype.fromLatLonToPoint = function (f) {\n      var p = this.mapTransforms,\n          q;\n      if (!p) return c.error(22, !1, this), {\n        x: 0,\n        y: null\n      };\n\n      for (q in p) {\n        if (Object.hasOwnProperty.call(p, q) && p[q].hitZone) {\n          var k = this.transformFromLatLon(f, p[q]);\n          if (C({\n            x: k.x,\n            y: -k.y\n          }, p[q].hitZone.coordinates[0])) return k;\n        }\n      }\n\n      return this.transformFromLatLon(f, p[\"default\"]);\n    };\n\n    c.geojson = function (c, f, q) {\n      var k = [],\n          m = [],\n          p = function p(c) {\n        var e,\n            b = c.length;\n        m.push(\"M\");\n\n        for (e = 0; e < b; e++) {\n          1 === e && m.push(\"L\"), m.push(c[e][0], -c[e][1]);\n        }\n      };\n\n      f = f || \"map\";\n      c.features.forEach(function (c) {\n        var e = c.geometry,\n            b = e.type;\n        e = e.coordinates;\n        c = c.properties;\n        var d;\n        m = [];\n        \"map\" === f || \"mapbubble\" === f ? (\"Polygon\" === b ? (e.forEach(p), m.push(\"Z\")) : \"MultiPolygon\" === b && (e.forEach(function (a) {\n          a.forEach(p);\n        }), m.push(\"Z\")), m.length && (d = {\n          path: m\n        })) : \"mapline\" === f ? (\"LineString\" === b ? p(e) : \"MultiLineString\" === b && e.forEach(p), m.length && (d = {\n          path: m\n        })) : \"mappoint\" === f && \"Point\" === b && (d = {\n          x: e[0],\n          y: -e[1]\n        });\n        d && k.push(D(d, {\n          name: c.name || c.NAME,\n          properties: c\n        }));\n      });\n      q && c.copyrightShort && (q.chart.mapCredits = A(q.chart.options.credits.mapText, {\n        geojson: c\n      }), q.chart.mapCreditsFull = A(q.chart.options.credits.mapTextFull, {\n        geojson: c\n      }));\n      return k;\n    };\n\n    y(f.prototype, \"addCredits\", function (c, f) {\n      f = E(!0, this.options.credits, f);\n      this.mapCredits && (f.href = null);\n      c.call(this, f);\n      this.credits && this.mapCreditsFull && this.credits.attr({\n        title: this.mapCreditsFull\n      });\n    });\n  });\n  K(C, \"parts-map/Map.js\", [C[\"parts/Globals.js\"], C[\"parts/Utilities.js\"]], function (c, f) {\n    function C(c, f, m, p, g, e, b, d) {\n      return [\"M\", c + g, f, \"L\", c + m - e, f, \"C\", c + m - e / 2, f, c + m, f + e / 2, c + m, f + e, \"L\", c + m, f + p - b, \"C\", c + m, f + p - b / 2, c + m - b / 2, f + p, c + m - b, f + p, \"L\", c + d, f + p, \"C\", c + d / 2, f + p, c, f + p - d / 2, c, f + p - d, \"L\", c, f + g, \"C\", c, f + g / 2, c + g / 2, f, c + g, f, \"Z\"];\n    }\n\n    var D = f.extend,\n        A = f.pick,\n        E = c.Chart;\n    f = c.defaultOptions;\n    var p = c.merge,\n        y = c.Renderer,\n        G = c.SVGRenderer,\n        v = c.VMLRenderer;\n    D(f.lang, {\n      zoomIn: \"Zoom in\",\n      zoomOut: \"Zoom out\"\n    });\n    f.mapNavigation = {\n      buttonOptions: {\n        alignTo: \"plotBox\",\n        align: \"left\",\n        verticalAlign: \"top\",\n        x: 0,\n        width: 18,\n        height: 18,\n        padding: 5,\n        style: {\n          fontSize: \"15px\",\n          fontWeight: \"bold\"\n        },\n        theme: {\n          \"stroke-width\": 1,\n          \"text-align\": \"center\"\n        }\n      },\n      buttons: {\n        zoomIn: {\n          onclick: function onclick() {\n            this.mapZoom(.5);\n          },\n          text: \"+\",\n          y: 0\n        },\n        zoomOut: {\n          onclick: function onclick() {\n            this.mapZoom(2);\n          },\n          text: \"-\",\n          y: 28\n        }\n      },\n      mouseWheelSensitivity: 1.1\n    };\n\n    c.splitPath = function (c) {\n      var f;\n      c = c.replace(/([A-Za-z])/g, \" $1 \");\n      c = c.replace(/^\\s*/, \"\").replace(/\\s*$/, \"\");\n      c = c.split(/[ ,]+/);\n\n      for (f = 0; f < c.length; f++) {\n        /[a-zA-Z]/.test(c[f]) || (c[f] = parseFloat(c[f]));\n      }\n\n      return c;\n    };\n\n    c.maps = {};\n\n    G.prototype.symbols.topbutton = function (c, f, m, p, g) {\n      return C(c - 1, f - 1, m, p, g.r, g.r, 0, 0);\n    };\n\n    G.prototype.symbols.bottombutton = function (c, f, m, p, g) {\n      return C(c - 1, f - 1, m, p, 0, 0, g.r, g.r);\n    };\n\n    y === v && [\"topbutton\", \"bottombutton\"].forEach(function (c) {\n      v.prototype.symbols[c] = G.prototype.symbols[c];\n    });\n\n    c.Map = c.mapChart = function (f, k, m) {\n      var q = \"string\" === typeof f || f.nodeName,\n          g = arguments[q ? 1 : 0],\n          e = g,\n          b = {\n        endOnTick: !1,\n        visible: !1,\n        minPadding: 0,\n        maxPadding: 0,\n        startOnTick: !1\n      },\n          d = c.getOptions().credits;\n      var a = g.series;\n      g.series = null;\n      g = p({\n        chart: {\n          panning: \"xy\",\n          type: \"map\"\n        },\n        credits: {\n          mapText: A(d.mapText, \" \\xA9 <a href=\\\"{geojson.copyrightUrl}\\\">{geojson.copyrightShort}</a>\"),\n          mapTextFull: A(d.mapTextFull, \"{geojson.copyright}\")\n        },\n        tooltip: {\n          followTouchMove: !1\n        },\n        xAxis: b,\n        yAxis: p(b, {\n          reversed: !0\n        })\n      }, g, {\n        chart: {\n          inverted: !1,\n          alignTicks: !1\n        }\n      });\n      g.series = e.series = a;\n      return q ? new E(f, g, m) : new E(g, k);\n    };\n  });\n  K(C, \"masters/modules/map.src.js\", [], function () {});\n  K(C, \"masters/highmaps.src.js\", [C[\"masters/highcharts.src.js\"]], function (c) {\n    c.product = \"Highmaps\";\n    return c;\n  });\n  C[\"masters/highmaps.src.js\"]._modules = C;\n  return C[\"masters/highmaps.src.js\"];\n});","map":null,"metadata":{},"sourceType":"script"}